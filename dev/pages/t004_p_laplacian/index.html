<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4 p-Laplacian · Gridap tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gridap tutorials logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap tutorials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="tocitem" href="../t002_validation/">2 Code validation</a></li><li><a class="tocitem" href="../t003_elasticity/">3 Linear elasticity</a></li><li class="is-active"><a class="tocitem" href>4 p-Laplacian</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement-1"><span>Problem statement</span></a></li><li><a class="tocitem" href="#Numerical-scheme-1"><span>Numerical scheme</span></a></li><li><a class="tocitem" href="#Discrete-model-1"><span>Discrete model</span></a></li><li><a class="tocitem" href="#FE-Space-1"><span>FE Space</span></a></li><li><a class="tocitem" href="#Nonlinear-FE-problem-1"><span>Nonlinear FE problem</span></a></li><li><a class="tocitem" href="#Nonlinear-solver-phase-1"><span>Nonlinear solver phase</span></a></li></ul></li><li><a class="tocitem" href="../t005_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="tocitem" href="../t006_dg_discretization/">6 Poisson equation (with DG)</a></li><li><a class="tocitem" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="tocitem" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li><li><a class="tocitem" href="../t009_stokes/">9 Stokes equation</a></li><li><a class="tocitem" href="../t010_advection_diffusion/">10 Advection-diffusion</a></li><li><a class="tocitem" href="../t011_isotropic_damage/">11 Isotropic damage model</a></li><li><a class="tocitem" href="../t012_fsi_tutorial/">12 Fluid-Structure Interaction</a></li><li><a class="tocitem" href="../t013_emscatter/">13 Electromagnetic scattering in 2D</a></li><li><a class="tocitem" href="../t014_validation_DrWatson/">14 On using DrWatson.jl</a></li><li><a class="tocitem" href="../t015_interpolation_fe/">15 Interpolation of CellFields</a></li><li><a class="tocitem" href="../t016_poisson_distributed/">16 Poisson equation on parallel distributed-memory computers</a></li><li><a class="tocitem" href="../t017_transient_linear/">17 Transient Poisson equation</a></li><li><a class="tocitem" href="../t018_transient_nonlinear/">18 Transient nonlinear equation</a></li><li><a class="tocitem" href="../t019_TopOptEMFocus/">19 Topology optimization</a></li><li><a class="tocitem" href="../t020_poisson_unfitted/">20 Poisson on unfitted meshes</a></li><li><a class="tocitem" href="../t021_poisson_amr/">21 Poisson with AMR</a></li><li><a class="tocitem" href="../t022_poisson_hdg/">22 Poisson with HDG</a></li><li><a class="tocitem" href="../t023_poisson_hho/">23 Poisson with HHO on polytopal meshes</a></li><li><a class="tocitem" href="../t024_stokes_blocks/">24 Block assembly and solvers: Incompressible Stokes example</a></li><li><a class="tocitem" href="../t025_lagrange_multipliers/">25 Lagrange multipliers</a></li><li><a class="tocitem" href="../t026_poisson_dev_fe/">26 Low-level API - Poisson equation</a></li><li><a class="tocitem" href="../t027_geometry_dev/">27 Low-level API - Geometry</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>4 p-Laplacian</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>4 p-Laplacian</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Tutorials/blob/master/src/p_laplacian.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="p_laplacian.jl-1"><a class="docs-heading-anchor" href="#p_laplacian.jl-1">Tutorial 4: p-Laplacian</a><a class="docs-heading-anchor-permalink" href="#p_laplacian.jl-1" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t004_p_laplacian.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t004_p_laplacian.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will learn</p><ul><li>How to solve a simple nonlinear PDE in Gridap</li><li>How to define the weak residual and its Jacobian</li><li>How to setup and use a nonlinear solver</li><li>How to define new boundaries from a given discrete model</li></ul><h2 id="Problem-statement-1"><a class="docs-heading-anchor" href="#Problem-statement-1">Problem statement</a><a class="docs-heading-anchor-permalink" href="#Problem-statement-1" title="Permalink"></a></h2><p>The goal of this tutorial is to solve a nonlinear PDE in Gridap. For the sake of simplicity, we consider the <span>$p$</span>-Laplacian equation as the model problem. Specifically, the PDE  we want to solve is: find the scalar-field <span>$u$</span> such that</p><div>\[\left\lbrace
\begin{aligned}
-\nabla \cdot \left( |\nabla u|^{p-2} \ \nabla u \right) = f\ &amp;\text{in}\ \Omega,\\
u = 0 \ &amp;\text{on} \ \Gamma_0,\\
u = g \ &amp;\text{on} \ \Gamma_g,\\
\left( |\nabla u|^{p-2}\ \nabla u \right)\cdot n = 0 \ &amp;\text{on} \ \Gamma_{\rm N},
\end{aligned}
\right.\]</div><p>with <span>$p&gt;2$</span>. The computational domain <span>$\Omega$</span> is the one depicted in next figure, which is the same as in the first tutorial. However, we slightly change the boundary conditions here. We impose homogeneous Dirichlet and homogeneous Neumann boundary conditions on <span>$\Gamma_0$</span> and <span>$\Gamma_{\rm N}$</span>  respectively, and in-homogeneous Dirichlet conditions on <span>$\Gamma_g$</span>. The Dirichlet boundaries <span>$\Gamma_0$</span> and <span>$\Gamma_g$</span> are defined as the closure of the green and blue surfaces in next figure respectively, whereas the Neumann boundary is <span>$\Gamma_{\rm N}\doteq\partial\Omega \setminus (\Gamma_0\cup\Gamma_g)$</span>. In this example, we consider the values <span>$p=3$</span>, <span>$f=1$</span>, and <span>$g=2$</span>.</p><p><img src="../../assets/p_laplacian/model.png" alt/></p><h2 id="Numerical-scheme-1"><a class="docs-heading-anchor" href="#Numerical-scheme-1">Numerical scheme</a><a class="docs-heading-anchor-permalink" href="#Numerical-scheme-1" title="Permalink"></a></h2><p>We discretize the problem with conforming Lagrangian FE spaces. For this formulation, the nonlinear weak form reads: find <span>$u\in U_g$</span> such that <span>$[r(u)](v) = 0$</span> for all <span>$v\in V_0$</span>. As in previous tutorials, the space <span>$U_g$</span> is the set of functions in <span>$H^1(\Omega)$</span> that fulfill the Dirichlet boundary conditions, whereas <span>$V_0$</span> is composed by functions in <span>$H^1(\Omega)$</span> that vanish at the Dirichlet boundary. The weak residual <span>$r(u)$</span> evaluated at a function  <span>$u\in U_g$</span> is the linear form defined as</p><div>\[[r(u)](v) \doteq \int_\Omega \nabla v \cdot \left( |\nabla u|^{p-2}\ \nabla u \right) \ {\rm d}\Omega - \int_\Omega v\ f \ {\rm d}\Omega.\]</div><p>In order to solve this nonlinear weak equation, we consider a Newton-Raphson method, which is associated with a linearization of the problem in an arbitrary direction <span>$\delta u\in V_0$</span>, namely <span>$[r(u+\delta u)](v)\approx [r(u)](v) + [j(u)](\delta u,v)$</span>. In previous formula,  <span>$j(u)$</span> is the Jacobian evaluated at <span>$u\in U_g$</span>, which is the bilinear form</p><div>\[[j(u)](\delta u,v) = \int_\Omega \nabla v \cdot \left( |\nabla u|^{p-2}\ \nabla \delta u \right) \ {\rm d}\Omega + (p-2) \int_\Omega \nabla v \cdot \left(  |\nabla u|^{p-4} (\nabla u \cdot \nabla \delta u) \nabla u  \right) \ {\rm d}\Omega.\]</div><p>Note that the solution of this nonlinear PDE with a Newton-Raphson method, will require to discretize both the residual <span>$r$</span> and the Jacobian <span>$j$</span>. In Gridap, this is done by following an approach similar to the one already shown in previous tutorials for discretizing the bilinear and linear forms associated with a linear FE problem. The specific details are discussed now.</p><h2 id="Discrete-model-1"><a class="docs-heading-anchor" href="#Discrete-model-1">Discrete model</a><a class="docs-heading-anchor-permalink" href="#Discrete-model-1" title="Permalink"></a></h2><p>As in previous tutorials, the first step to solve the PDE is to load a discretization of the computational domain. In this case, we load the model from the same file as in the first tutorial</p><pre><code class="language-julia">using Gridap
model = DiscreteModelFromFile(&quot;../models/model.json&quot;)</code></pre><p>As stated before, we want to impose Dirichlet boundary conditions on <span>$\Gamma_0$</span> and <span>$\Gamma_g$</span>,  but none of these boundaries is identified in the model. E.g., you can easily see by writing the model in vtk format</p><pre><code class="language-julia">writevtk(model,&quot;model&quot;)</code></pre><p>and by opening the file <code>&quot;model_0&quot;</code> in Paraview that the boundary identified as <code>&quot;sides&quot;</code> only includes the vertices in the interior of <span>$\Gamma_0$</span>, but here we want to impose Dirichlet boundary conditions in the closure of <span>$\Gamma_0$</span>, i.e., also on the vertices on the contour of <span>$\Gamma_0$</span>. Fortunately, the objects on the contour of <span>$\Gamma_0$</span> are identified  with the tag <code>&quot;sides_c&quot;</code> (see next figure). Thus, the Dirichlet boundary <span>$\Gamma_0$</span> can be built as the union of the objects identified as <code>&quot;sides&quot;</code> and <code>&quot;sides_c&quot;</code>.</p><p><img src="../../assets/p_laplacian/sides_c.png" alt/></p><p>Gridap provides a convenient way to create new object identifiers (referred to as &quot;tags&quot;) from existing ones. First, we need to extract from the model, the object that holds the information about the boundary identifiers (referred to as <code>FaceLabeling</code>):</p><pre><code class="language-julia">labels = get_face_labeling(model)</code></pre><p>Then, we can add new identifiers (aka &quot;tags&quot;) to it. In the next line, we create a new tag called <code>&quot;diri0&quot;</code> as the union of the objects identified as <code>&quot;sides&quot;</code> and <code>&quot;sides_c&quot;</code>, which is precisely what we need to represent the closure of the Dirichlet boundary <span>$\Gamma_0$</span>.</p><pre><code class="language-julia">add_tag_from_tags!(labels,&quot;diri0&quot;,[&quot;sides&quot;, &quot;sides_c&quot;])</code></pre><p>We follow the same approach to build a new identifier for the closure of the Dirichlet boundary <span>$\Gamma_g$</span>. In this case, the boundary is expressed as the union of the objects identified with the tags <code>&quot;circle&quot;</code>, <code>&quot;circle_c&quot;</code>, <code>&quot;triangle&quot;</code>, <code>&quot;triangle_c&quot;</code>, <code>&quot;square&quot;</code>, <code>&quot;square_c&quot;</code>. Thus, we create a new tag for  <span>$\Gamma_g$</span>, called <code>&quot;dirig&quot;</code> simply as follows:</p><pre><code class="language-julia">add_tag_from_tags!(labels,&quot;dirig&quot;,
  [&quot;circle&quot;,&quot;circle_c&quot;, &quot;triangle&quot;, &quot;triangle_c&quot;, &quot;square&quot;, &quot;square_c&quot;])</code></pre><h2 id="FE-Space-1"><a class="docs-heading-anchor" href="#FE-Space-1">FE Space</a><a class="docs-heading-anchor-permalink" href="#FE-Space-1" title="Permalink"></a></h2><p>Now, we can build the FE space by using the newly defined boundary tags.</p><pre><code class="language-julia">reffe = ReferenceFE(lagrangian,Float64,1)
V0 = TestFESpace(model,reffe,conformity=:H1,labels=labels,dirichlet_tags=[&quot;diri0&quot;, &quot;dirig&quot;])</code></pre><p>The construction of this space is essentially the same as in the first tutorial (we build a continuous scalar-valued Lagrangian interpolation of first order). However, we also pass here the <code>labels</code> object (that contains the newly created boundary tags). From this FE space, we define the trial FE spaces</p><pre><code class="language-julia">g = 1
Ug = TrialFESpace(V0,[0,g])</code></pre><h2 id="Nonlinear-FE-problem-1"><a class="docs-heading-anchor" href="#Nonlinear-FE-problem-1">Nonlinear FE problem</a><a class="docs-heading-anchor-permalink" href="#Nonlinear-FE-problem-1" title="Permalink"></a></h2><p>At this point, we are ready to build the nonlinear FE problem. To this end, we need to define the weak residual and also its corresponding Jacobian. This is done following a similar procedure to the one considered in previous tutorials to define the bilinear and linear forms associated with linear FE problems. We first need to define the usual objects for numerical integration:</p><pre><code class="language-julia">degree=2
Ω = Triangulation(model)
dΩ = Measure(Ω,degree)</code></pre><p>On the one hand, the weak residual is built as follows</p><pre><code class="language-julia">using LinearAlgebra: norm
const p = 3
flux(∇u) = norm(∇u)^(p-2) * ∇u
f(x) = 1
res(u,v) = ∫( ∇(v)⊙(flux∘∇(u)) - v*f )*dΩ</code></pre><p>Function <code>res</code> is the one representing the integrand of the weak residual <span>$[r(u)](v)$</span>. The first argument of function <code>res</code> stands for the function <span>$u\in U_g$</span>, where the residual is evaluated, and the second argument stands for a generic test function <span>$v\in V_0$</span>.</p><p>On the other hand,  we (optionally) implement a function <code>jac</code> representing the Jacobian.</p><pre><code class="language-julia">dflux(∇du,∇u) = (p-2)*norm(∇u)^(p-4)*(∇u⊙∇du)*∇u+norm(∇u)^(p-2)*∇du
jac(u,du,v) = ∫( ∇(v)⊙(dflux∘(∇(du),∇(u))) )*dΩ</code></pre><p>The first argument of function <code>jac</code> stands for function <span>$u\in U_g$</span>, where the Jacobian is evaluated. The second argument is a test function <span>$v\in V_0$</span>, and the third argument represents an arbitrary direction <span>$\delta u \in V_0$</span>.</p><p>We finally construct the nonlinear FE problem</p><pre><code class="language-julia">op = FEOperator(res,jac,Ug,V0)</code></pre><p>Here, we have constructed an instance of <code>FEOperator</code>, which is the type that represents a general nonlinear FE problem in Gridap. The constructor takes the functions representing the weak residual and Jacobian, and the test and trial spaces. If only the function for the residual is provided, the Jacobian is computed internally with automatic differentiation.</p><h2 id="Nonlinear-solver-phase-1"><a class="docs-heading-anchor" href="#Nonlinear-solver-phase-1">Nonlinear solver phase</a><a class="docs-heading-anchor-permalink" href="#Nonlinear-solver-phase-1" title="Permalink"></a></h2><p>We have already built the nonlinear FE problem. Now, the remaining step is to solve it. In Gridap, nonlinear (and also linear) FE problems can be solved with instances of the type <code>FESolver</code>.</p><p>We construct an instance of <code>FESolver</code> as follows:</p><pre><code class="language-julia">using LineSearches: BackTracking
nls = NLSolver(
  show_trace=true, method=:newton, linesearch=BackTracking())
solver = FESolver(nls)</code></pre><p>Note that the <code>NLSolver</code> function used above internally calls the <code>nlsolve</code> function of the <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve</a> package with the provided key-word arguments. Thus, one can use any of the nonlinear methods available via the function <code>nlsolve</code> to solve the nonlinear FE problem. Here, we have selected a Newton-Raphson method with a back-tracking line-search from the <a href="https://github.com/JuliaNLSolvers/LineSearches.jl">LineSearches</a> package.</p><p>We are finally in place to solve the nonlinear FE problem. The initial guess is a <code>FEFunction</code>, which we build from a vector of random (free) nodal values:</p><pre><code class="language-julia">import Random
Random.seed!(1234)
x = rand(Float64,num_free_dofs(Ug))
uh0 = FEFunction(Ug,x)
uh, = solve!(uh0,solver,op)</code></pre><p>We finish this tutorial by writing the computed solution for visualization (see next figure).</p><pre><code class="language-julia">writevtk(Ω,&quot;results&quot;,cellfields=[&quot;uh&quot;=&gt;uh])</code></pre><p><img src="../../assets/p_laplacian/sol-plap.png" alt/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t003_elasticity/">« 3 Linear elasticity</a><a class="docs-footer-nextpage" href="../t005_hyperelasticity/">5 Hyper-elasticity »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 18 June 2025 23:39">Wednesday 18 June 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
