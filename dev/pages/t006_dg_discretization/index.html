<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>6 Poisson equation (with DG) · Gridap tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gridap tutorials logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap tutorials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="tocitem" href="../t002_validation/">2 Code validation</a></li><li><a class="tocitem" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="tocitem" href="../t004_p_laplacian/">4 p-Laplacian</a></li><li><a class="tocitem" href="../t005_hyperelasticity/">5 Hyper-elasticity</a></li><li class="is-active"><a class="tocitem" href>6 Poisson equation (with DG)</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement-1"><span>Problem statement</span></a></li><li><a class="tocitem" href="#Numerical-Scheme-1"><span>Numerical Scheme</span></a></li><li><a class="tocitem" href="#Manufactured-solution-1"><span>Manufactured solution</span></a></li><li><a class="tocitem" href="#Cartesian-mesh-generation-1"><span>Cartesian mesh generation</span></a></li><li><a class="tocitem" href="#FE-spaces-1"><span>FE spaces</span></a></li><li><a class="tocitem" href="#Numerical-integration-1"><span>Numerical integration</span></a></li><li><a class="tocitem" href="#Weak-form-1"><span>Weak form</span></a></li><li><a class="tocitem" href="#Discretization-error-1"><span>Discretization error</span></a></li><li><a class="tocitem" href="#References-1"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="tocitem" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li><li><a class="tocitem" href="../t009_stokes/">9 Stokes equation</a></li><li><a class="tocitem" href="../t010_advection_diffusion/">10 Advection-diffusion</a></li><li><a class="tocitem" href="../t011_isotropic_damage/">11 Isotropic damage model</a></li><li><a class="tocitem" href="../t012_fsi_tutorial/">12 Fluid-Structure Interaction</a></li><li><a class="tocitem" href="../t013_emscatter/">13 Electromagnetic scattering in 2D</a></li><li><a class="tocitem" href="../t014_validation_DrWatson/">14 On using DrWatson.jl</a></li><li><a class="tocitem" href="../t015_interpolation_fe/">15 Interpolation of CellFields</a></li><li><a class="tocitem" href="../t016_poisson_distributed/">16 Poisson equation on parallel distributed-memory computers</a></li><li><a class="tocitem" href="../t017_transient_linear/">17 Transient Poisson equation</a></li><li><a class="tocitem" href="../t018_transient_nonlinear/">18 Transient nonlinear equation</a></li><li><a class="tocitem" href="../t019_TopOptEMFocus/">19 Topology optimization</a></li><li><a class="tocitem" href="../t020_poisson_unfitted/">20 Poisson on unfitted meshes</a></li><li><a class="tocitem" href="../t021_poisson_amr/">21 Poisson with AMR</a></li><li><a class="tocitem" href="../t022_poisson_hdg/">22 Poisson with HDG</a></li><li><a class="tocitem" href="../t023_poisson_hho/">23 Poisson with HHO on polytopal meshes</a></li><li><a class="tocitem" href="../t024_stokes_blocks/">24 Block assembly and solvers: Incompressible Stokes example</a></li><li><a class="tocitem" href="../t025_lagrange_multipliers/">25 Lagrange multipliers</a></li><li><a class="tocitem" href="../t026_poisson_dev_fe/">26 Low-level API - Poisson equation</a></li><li><a class="tocitem" href="../t027_geometry_dev/">27 Low-level API - Geometry</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>6 Poisson equation (with DG)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>6 Poisson equation (with DG)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Tutorials/blob/master/src/dg_discretization.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="dg_discretization.jl-1"><a class="docs-heading-anchor" href="#dg_discretization.jl-1">Tutorial 6: Poisson equation (with DG)</a><a class="docs-heading-anchor-permalink" href="#dg_discretization.jl-1" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t006_dg_discretization.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t006_dg_discretization.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will learn</p><ul><li>How to solve a simple PDE with a DG method</li><li>How to compute jumps and averages of quantities on the mesh skeleton</li><li>How to implement the method of manufactured solutions</li><li>How to integrate error norms</li><li>How to generate Cartesian meshes in arbitrary dimensions</li></ul><h2 id="Problem-statement-1"><a class="docs-heading-anchor" href="#Problem-statement-1">Problem statement</a><a class="docs-heading-anchor-permalink" href="#Problem-statement-1" title="Permalink"></a></h2><p>The goal of this tutorial is to solve a PDE using a Discontinuous Galerkin (DG) formulation. For simplicity, we take the Poisson equation on the unit cube <span>$\Omega \doteq (0,1)^3$</span> as the model problem, namely</p><div>\[\left\lbrace
\begin{aligned}
-\Delta u = f  \ &amp;\text{in} \ \Omega,\\
u = g \ &amp;\text{on}\ \Gamma \doteq \partial\Omega,\\
\end{aligned}
\right.\]</div><p>where <span>$f$</span> is the source term and <span>$g$</span> is the prescribed Dirichlet boundary function. In this tutorial, we follow the method of manufactured solutions since we want to illustrate how to compute discretization errors. We take <span>$u(x) = 3 x_1 + x_2^2 + 2 x_3^3 + x_1 x_2 x_3 $ as the exact solution of the problem, for which $f(x)= -2 - 12x_3 $ and $g(x) = u(x)$</span>. The selected manufactured solution <span>$u$</span> is a third order multi-variate polynomial, which can be represented exactly by the FE discretization that we are going to define below. In this scenario, the discretization error has to be close to the machine precision. We will use this result to validate the proposed implementation.</p><h2 id="Numerical-Scheme-1"><a class="docs-heading-anchor" href="#Numerical-Scheme-1">Numerical Scheme</a><a class="docs-heading-anchor-permalink" href="#Numerical-Scheme-1" title="Permalink"></a></h2><p>We consider a DG formulation to approximate the problem. In particular, we consider the symmetric interior penalty method (see, e.g. [1], for specific details). For this formulation, the approximation space is made of discontinuous piece-wise polynomials, namely</p><div>\[V \doteq \{ v\in L^2(\Omega):\ v|_{T}\in Q_p(T) \text{ for all } T\in\mathcal{T}  \},\]</div><p>where <span>$\mathcal{T}$</span> is the set of all cells <span>$T$</span> of the FE mesh, and <span>$Q_p(T)$</span> is a polynomial space of degree <span>$p$</span> defined on a generic cell <span>$T$</span>. For simplicity, we consider Cartesian meshes in this tutorial. In this case, the space <span>$Q_p(T)$</span> is made of multi-variate polynomials up to degree <span>$p$</span> in each spatial coordinate.</p><p>In order to write the weak form of the problem, we need to introduce some notation. The sets of interior and boundary facets associated with the FE mesh <span>$\mathcal{T}$</span> are denoted here as <span>$\mathcal{F}_\Lambda$</span> and <span>$\mathcal{F}_{\Gamma}$</span> respectively. In addition, for a given function <span>$v\in V$</span> restricted to the interior facets <span>$\mathcal{F}_\Lambda$</span>, we introduce the well known jump and mean value operators,</p><div>\[\begin{aligned}
\lbrack\!\lbrack v\ n \rbrack\!\rbrack &amp;\doteq v^+\ n^+ + v^- n^-,\\
\{\! \!\{\nabla v\}\! \!\} &amp;\doteq \dfrac{ \nabla v^+ + \nabla v^-}{2},
\end{aligned}\]</div><p>with <span>$v^+$</span>, and <span>$v^-$</span> being the restrictions of <span>$v\in V$</span> to the cells <span>$T^+$</span>, <span>$T^-$</span> that share a generic interior facet in <span>$\mathcal{F}_\Lambda$</span>, and <span>$n^+$</span>, and <span>$n^-$</span> are the facet outward unit normals from either the perspective of <span>$T^+$</span> and <span>$T^-$</span> respectively.</p><p>With this notation, the weak form associated with the interior penalty formulation of our problem reads: find <span>$u\in V$</span> such that <span>$a(u,v) = l(v)$</span> for all <span>$v\in V$</span>. The bilinear and linear forms <span>$a(\cdot,\cdot)$</span> and <span>$l(\cdot)$</span> have contributions associated with the bulk of <span>$\Omega$</span>, the boundary facets <span>$\mathcal{F}_{\Gamma}$</span>, and the interior facets <span>$\mathcal{F}_\Lambda$</span>, namely</p><div>\[\begin{aligned}
a(u,v) &amp;= a_{\Omega}(u,v) + a_{\Gamma}(u,v) + a_{\Lambda}(u,v),\\
l(v) &amp;= l_{\Omega}(v) + l_{\Gamma}(v).
\end{aligned}\]</div><p>These contributions are defined as</p><div>\[\begin{aligned}
a_{\Omega}(u,v) &amp;\doteq \sum_{T\in\mathcal{T}} \int_{T} \nabla v \cdot \nabla u \ {\rm d}T,
\\
l_{\Omega}(v) &amp;\doteq \int_{\Omega} v\ f \ {\rm d}\Omega,
\end{aligned}\]</div><p>for the volume,</p><div>\[\begin{aligned}
a_{\Gamma}(u,v)
   \doteq
   &amp; - \sum_{F\in\mathcal{F}_{\Gamma}} \int_{F} v\ (\nabla u \cdot n)  \ {\rm d}F
\\ &amp; - \sum_{F\in\mathcal{F}_{\Gamma}} \int_{F} (\nabla v \cdot n)\ u  \ {\rm d}F
\\ &amp; + \sum_{F\in\mathcal{F}_{\Gamma}} \dfrac{\gamma}{|F|} \int_{F} v\ u \ {\rm d}F,
\\
l_{\Gamma}(v)
\doteq
   &amp; - \sum_{F\in\mathcal{F}_{\Gamma}} \int_{F} (\nabla v \cdot n)\ g  \ {\rm d}F
\\ &amp; + \sum_{F\in\mathcal{F}_{\Gamma}} \dfrac{\gamma}{|F|} \int_{F} v\ g \ {\rm d}F,
\end{aligned}\]</div><p>for the boundary facets and,</p><div>\[\begin{aligned}
a_{\Lambda}(u,v)
\doteq
   &amp; - \sum_{F\in\mathcal{F}_{\Lambda}} \int_{F} \lbrack\!\lbrack v\ n \rbrack\!\rbrack\cdot \{\! \!\{\nabla u\}\! \!\} \ {\rm d}F
\\ &amp; - \sum_{F\in\mathcal{F}_{\Lambda}} \int_{F} \{\! \!\{\nabla v\}\! \!\}\cdot \lbrack\!\lbrack u\ n \rbrack\!\rbrack \ {\rm d}F
\\ &amp; + \sum_{F\in\mathcal{F}_{\Lambda}} \dfrac{\gamma}{|F|} \int_{F} \lbrack\!\lbrack v\ n \rbrack\!\rbrack\cdot \lbrack\!\lbrack u\ n \rbrack\!\rbrack \ {\rm d}F,
\end{aligned}\]</div><p>for the interior facets. In previous expressions, <span>$|F|$</span> denotes the diameter  of the face <span>$F$</span> (in our Cartesian grid, this is equivalent to the  characteristic mesh size <span>$h$</span>), and <span>$\gamma$</span> is a stabilization parameter that  should be chosen large enough such that the bilinear form <span>$a(\cdot,\cdot)$</span> is  stable and continuous. Here, we take <span>$\gamma = p\ (p+1)$</span> as done in the  numerical experiments in reference [2].</p><h2 id="Manufactured-solution-1"><a class="docs-heading-anchor" href="#Manufactured-solution-1">Manufactured solution</a><a class="docs-heading-anchor-permalink" href="#Manufactured-solution-1" title="Permalink"></a></h2><p>We start by loading the Gridap library and defining the manufactured solution <span>$u$</span> and the associated source term <span>$f$</span> and Dirichlet function <span>$g$</span>.</p><pre><code class="language-julia">using Gridap
u(x) = 3*x[1] + x[2]^2 + 2*x[3]^3 + x[1]*x[2]*x[3]
f(x) = -2 - 12*x[3]
g(x) = u(x)</code></pre><p>We also need to define the gradient of <span>$u$</span> since we will compute the <span>$H^1$</span> error norm later. In that case, the gradient is simply defined as</p><pre><code class="language-julia">∇u(x) = VectorValue(3        + x[2]*x[3],
                    2*x[2]   + x[1]*x[3],
                    6*x[3]^2 + x[1]*x[2])</code></pre><p>In addition, we need to tell the Gridap library that the gradient of the function <code>u</code> is available in the function <code>∇u</code> (at this moment <code>u</code> and <code>∇u</code> are two standard Julia functions without any connection between them). This is done by adding an extra method to the function <code>gradient</code> (aka <code>∇</code>) defined in Gridap:</p><pre><code class="language-julia">import Gridap: ∇
∇(::typeof(u)) = ∇u</code></pre><p>Now, it is possible to recover function <code>∇u</code> from function <code>u</code> as <code>∇(u)</code>. You  can check that the following expression evaluates to <code>true</code>.</p><pre><code class="language-julia">∇(u) === ∇u</code></pre><h2 id="Cartesian-mesh-generation-1"><a class="docs-heading-anchor" href="#Cartesian-mesh-generation-1">Cartesian mesh generation</a><a class="docs-heading-anchor-permalink" href="#Cartesian-mesh-generation-1" title="Permalink"></a></h2><p>In order to discretize the geometry of the unit cube, we use the Cartesian mesh generator available in Gridap.</p><pre><code class="language-julia">L = 1.0
domain = (0.0, L, 0.0, L, 0.0, L)
n = 4
partition = (n,n,n)
model = CartesianDiscreteModel(domain,partition)</code></pre><p>The type <code>CartesianDiscreteModel</code> is a concrete type that inherits from <code>DiscreteModel</code>, which is specifically designed for building Cartesian meshes. The <code>CartesianDiscreteModel</code> constructor takes a tuple containing limits of the box we want to discretize plus a tuple with the number of cells to be generated in each direction (here <span>$4\times4\times4$</span> cells). You can write the model in vtk format to visualize it (see next figure).</p><pre><code class="language-julia">mkpath(&quot;output_path&quot;)
writevtk(model,&quot;output_path/model&quot;)</code></pre><p><img src="../../assets/dg_discretization/model.png" alt/></p><p>Note that the <code>CaresianDiscreteModel</code> is implemented for arbitrary  dimensions. For instance, the following lines build a  <code>CartesianDiscreteModel</code> for the unit square <span>$(0,1)^2$</span> with 4 cells per  direction</p><pre><code class="language-julia">domain2D = (0.0, L, 0.0, L)
partition2D = (n,n)
model2D = CartesianDiscreteModel(domain2D,partition2D)</code></pre><p>You could also generate a mesh for the unit tesseract <span>$(0,1)^4$</span> (i.e., the unit cube in 4D). Look how the 2D and 3D models are built and just follow the sequence.</p><h2 id="FE-spaces-1"><a class="docs-heading-anchor" href="#FE-spaces-1">FE spaces</a><a class="docs-heading-anchor-permalink" href="#FE-spaces-1" title="Permalink"></a></h2><p>On top of the discrete model, we create the discontinuous space <span>$V$</span> as follows</p><pre><code class="language-julia">order = 3
V = TestFESpace(model,
                ReferenceFE(lagrangian,Float64,order),
                conformity=:L2)</code></pre><p>We have select a Lagrangian, scalar-valued interpolation of order <span>$3$</span> within the cells of the discrete model. Since the cells are hexahedra, the resulting Lagrangian shape functions are tri-cubic polynomials. In contrast to previous tutorials, where we have constructed <span>$H^1$</span>-conforming (i.e., continuous) FE spaces, here we construct a <span>$L^2$</span>-conforming (i.e., discontinuous) FE space. That is, we do not impose any type of continuity of the shape function on the cell boundaries, which leads to the discontinuous FE space <span>$V$</span> of the DG formulation. Note also that we do not pass any information about the Dirichlet boundary to the <code>TestFESpace</code> constructor since the Dirichlet boundary conditions are not imposed strongly in this example.</p><p>From the <code>V</code> object we have constructed in previous code snippet, we build the trial FE space as usual.</p><pre><code class="language-julia">U = TrialFESpace(V)</code></pre><p>Note that we do not pass any Dirichlet function to the <code>TrialFESpace</code> constructor since we do not impose Dirichlet boundary conditions strongly here.</p><h2 id="Numerical-integration-1"><a class="docs-heading-anchor" href="#Numerical-integration-1">Numerical integration</a><a class="docs-heading-anchor-permalink" href="#Numerical-integration-1" title="Permalink"></a></h2><p>Once the FE spaces are ready, the next step is to set up the numerical integration. In this example, we need to integrate in three different domains: the volume covered by the cells <span>$\mathcal{T}$</span> (i.e., the computational domain <span>$\Omega$</span>), the surface covered by the boundary facets <span>$\mathcal{F}_{\Gamma}$</span> (i.e., the boundary <span>$\Gamma = \partial \Omega$</span>), and the surface covered by the interior facets <span>$\mathcal{F}_{\Lambda}$</span> (i.e. the so-called mesh skeleton). In order to integrate in <span>$\Omega$</span> and on its boundary <span>$\Gamma$</span>, we use <code>Triangulation</code> and <code>BoundaryTriangulation</code> objects as already discussed in previous tutorials.</p><pre><code class="language-julia">Ω = Triangulation(model)
Γ = BoundaryTriangulation(model)</code></pre><p>Here, we do not pass any boundary identifier to the <code>BoundaryTriangulation</code> constructor. In this case, an integration mesh for the entire boundary <span>$\Gamma$</span> is constructed by default (which is just what we need in this example).</p><p>In order to generate an integration mesh for the interior facets <span>$\mathcal{F}_{\Lambda}$</span>, we use a new type of <code>Triangulation</code> referred to as <code>SkeletonTriangulation</code>. It can be constructed from a <code>DiscreteModel</code> object as follows:</p><pre><code class="language-julia">Λ = SkeletonTriangulation(model)</code></pre><p>As any other type of <code>Triangulation</code>, an <code>SkeletonTriangulation</code> can be written into a vtk file for its visualization (see next figure, where the interior facets <span>$\mathcal{F}_\Lambda$</span> are clearly observed).</p><pre><code class="language-julia">writevtk(Λ,&quot;output_path/strian&quot;)</code></pre><p><img src="../../assets/dg_discretization/skeleton_trian.png" alt/></p><p>Once we have constructed the triangulations needed in this example, we define the corresponding quadrature rules by passing the triangulations together with the desired degree to the <code>Measure</code> function.</p><pre><code class="language-julia">degree = 2*order

dΩ = Measure(Ω,degree)
dΓ = Measure(Γ,degree)
dΛ = Measure(Λ,degree)</code></pre><p>We still need a way to represent the unit outward normal vector to the boundary <span>$\Gamma$</span>, and the unit normal vector on the interior faces <span>$\mathcal{F}_\Lambda$</span>. This is done with the <code>get_normal_vector</code> getter.</p><pre><code class="language-julia">n_Γ = get_normal_vector(Γ)
n_Λ = get_normal_vector(Λ)</code></pre><p>The <code>get_normal_vector</code> getter takes either a boundary or a skeleton triangulation and returns an object representing the normal vector to the corresponding surface. For boundary triangulations, the returned normal vector is the unit outwards one, whereas for skeleton triangulations the orientation of the returned normal is arbitrary. In the current implementation (Gridap v0.5.0), the unit normal is outwards to the cell with smaller id among the two cells that share an interior facet in <span>$\mathcal{F}_\Lambda$</span>.</p><h2 id="Weak-form-1"><a class="docs-heading-anchor" href="#Weak-form-1">Weak form</a><a class="docs-heading-anchor-permalink" href="#Weak-form-1" title="Permalink"></a></h2><p>With these ingredients we can define the different terms in the weak form. First, we start with the terms <span>$a_\Omega(\cdot,\cdot)$</span> , and <span>$l_\Omega(\cdot)$</span> associated with integrals in the volume <span>$\Omega$</span>. This is done as in the tutorial for the Poisson equation.</p><pre><code class="language-julia">a_Ω(u,v) = ∫( ∇(v)⊙∇(u) )dΩ
l_Ω(v) = ∫( v*f )dΩ</code></pre><p>The terms <span>$a_{\Gamma}(\cdot,\cdot)$</span> and <span>$l_{\Gamma}(\cdot)$</span> associated with integrals on the boundary <span>$\Gamma$</span> are defined using an analogous approach:</p><pre><code class="language-julia">h = L / n
γ = order*(order+1)
a_Γ(u,v) = ∫( - v*(∇(u)⋅n_Γ) - (∇(v)⋅n_Γ)*u + (γ/h)*v*u )dΓ
l_Γ(v)   = ∫(                - (∇(v)⋅n_Γ)*g + (γ/h)*v*g )dΓ</code></pre><p>Note that in the definition of the functions <code>a_Γ</code> and <code>b_Γ</code>, we have used the object <code>n_Γ</code> representing the outward unit normal to the boundary <span>$\Gamma$</span>. The code definition of <code>a_Γ</code> and <code>b_Γ</code> is indeed very close to the mathematical definition of the forms <span>$a_{\Gamma}(\cdot,\cdot)$</span> and <span>$b_{\Gamma}(\cdot)$</span>.</p><p>Finally, we need to define the term <span>$a_\Lambda(\cdot,\cdot)$</span> integrated on the interior facets <span>$\mathcal{F}_\Lambda$</span>,</p><pre><code class="language-julia">a_Λ(u,v) = ∫( - jump(v*n_Λ)⊙mean(∇(u))
              - mean(∇(v))⊙jump(u*n_Λ)
              + (γ/h)*jump(v*n_Λ)⊙jump(u*n_Λ) )dΛ</code></pre><p>Note that the arguments <code>v</code>, <code>u</code> of function <code>a_Λ</code> represent a test and trial function <em>restricted</em> to the interior facets <span>$\mathcal{F}_\Lambda$</span>. As mentioned before in the presentation of the DG formulation, the restriction of a function <span>$v\in V$</span> to the interior faces leads to two different values <span>$v^+$</span> and <span>$v^-$</span> . In order to compute jumps and averages of the quantities <span>$v^+$</span> and <span>$v^-$</span>, we use the functions <code>jump</code> and <code>mean</code>, which represent the jump and mean value operators <span>$\lbrack\!\lbrack \cdot \rbrack\!\rbrack$</span> and <span>$\{\! \!\{\cdot\}\! \!\}$</span> respectively. Note also that we have used the object <code>n_Λ</code> representing the unit normal vector on the interior facets. As a result, the notation used to define function <code>a_Λ</code> is very close to the mathematical definition of the terms in the bilinear form <span>$a_\Lambda(\cdot,\cdot)$</span>.</p><p>Once the different terms of the weak form have been defined, we build and solve the FE problem.</p><pre><code class="language-julia">a(u,v) = a_Ω(u,v) + a_Γ(u,v) + a_Λ(u,v)
l(v) = l_Ω(v) + l_Γ(v)

op = AffineFEOperator(a, l, U, V)
uh = solve(op)</code></pre><h2 id="Discretization-error-1"><a class="docs-heading-anchor" href="#Discretization-error-1">Discretization error</a><a class="docs-heading-anchor-permalink" href="#Discretization-error-1" title="Permalink"></a></h2><p>We end this tutorial by quantifying the discretization error associated with the computed numerical solution <code>uh</code>. In DG methods a simple error indicator is the jump of the computed (discontinuous) approximation on the interior faces. We compute and visualize the jump of these values as follows (see next figure):</p><pre><code class="language-julia">writevtk(Λ,&quot;output_path/jumps&quot;,cellfields=[&quot;jump_u&quot;=&gt;jump(uh)])</code></pre><p>Note that the jump of the numerical solution is very small, close to the machine precision (as expected in this example with manufactured solution). <img src="../../assets/dg_discretization/jump_u.png" alt/></p><p>A more rigorous way of quantifying the error is to measure it with a norm.  Here, we use the <span>$L^2$</span> and <span>$H^1$</span> norms, namely</p><div>\[\begin{aligned}
 \| w \|_{L^2}^2 &amp; \doteq \int_{\Omega} w^2 \ \text{d}\Omega, \\
 \| w \|_{H^1}^2 &amp; \doteq \int_{\Omega} w^2 + \nabla w \cdot \nabla w \ \text{d}\Omega.
\end{aligned}\]</div><p>The discretization error can be computed in this example as the difference of the manufactured and numerical solutions.</p><pre><code class="language-julia">e = u - uh</code></pre><p>We compute the error norms as follows. First, we implement the integrands of the norms we want to compute.</p><pre><code class="language-julia">l2(u) = sqrt(sum( ∫( u⊙u )*dΩ ))
h1(u) = sqrt(sum( ∫( u⊙u + ∇(u)⊙∇(u) )*dΩ ))</code></pre><p>Then, we compute the corresponding integrals with the <code>integrate</code> function.</p><pre><code class="language-julia">el2 = l2(e)
eh1 = h1(e)</code></pre><p>The <code>integrate</code> function returns a lazy object representing the contribution to the integral of each cell in the underlying triangulation. To end up with the desired error norms, one has to sum these contributions and take the square root. You can check that the computed error norms are close to machine precision (as one would expect).</p><pre><code class="language-julia">tol = 1.e-10
@assert el2 &lt; tol
@assert eh1 &lt; tol</code></pre><h2 id="References-1"><a class="docs-heading-anchor" href="#References-1">References</a><a class="docs-heading-anchor-permalink" href="#References-1" title="Permalink"></a></h2><p>[1] D. N. Arnold, F. Brezzi, B. Cockburn, and L. Donatella Marini. Unified analysis of discontinuous Galerkin methods for elliptic problems. <em>SIAM Journal on Numerical Analysis</em>, 39 (5):1749–1779, 2001. doi:<a href="http://dx.doi.org/10.1137/S0036142901384162">10.1137/S0036142901384162</a>.</p><p>[2] B. Cockburn, G. Kanschat, and D. Schötzau. An equal-order DG method for the incompressible Navier-Stokes equations. <em>Journal of Scientific Computing</em>, 40(1-3):188–210, 2009. doi:<a href="http://dx.doi.org/10.1007/s10915-008-9261-1">10.1007/s10915-008-9261-1</a>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t005_hyperelasticity/">« 5 Hyper-elasticity</a><a class="docs-footer-nextpage" href="../t007_darcy/">7 Darcy equation (with RT) »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 25 September 2025 00:53">Thursday 25 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
