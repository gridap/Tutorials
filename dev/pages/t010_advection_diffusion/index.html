<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>10 Advection-diffusion · Gridap tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gridap tutorials logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap tutorials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="tocitem" href="../t002_validation/">2 Code validation</a></li><li><a class="tocitem" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="tocitem" href="../t004_p_laplacian/">4 p-Laplacian</a></li><li><a class="tocitem" href="../t005_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="tocitem" href="../t006_dg_discretization/">6 Poisson equation (with DG)</a></li><li><a class="tocitem" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="tocitem" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li><li><a class="tocitem" href="../t009_stokes/">9 Stokes equation</a></li><li class="is-active"><a class="tocitem" href>10 Advection-diffusion</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement-1"><span>Problem statement</span></a></li><li><a class="tocitem" href="#Model-geometry-in-Gmsh-1"><span>Model geometry in Gmsh</span></a></li><li><a class="tocitem" href="#Numerical-Scheme-1"><span>Numerical Scheme</span></a></li><li><a class="tocitem" href="#FE-spaces-1"><span>FE spaces</span></a></li><li><a class="tocitem" href="#Weak-form-1"><span>Weak form</span></a></li><li><a class="tocitem" href="#Solution-1"><span>Solution</span></a></li><li><a class="tocitem" href="#Visualization-1"><span>Visualization</span></a></li></ul></li><li><a class="tocitem" href="../t011_isotropic_damage/">11 Isotropic damage model</a></li><li><a class="tocitem" href="../t012_fsi_tutorial/">12 Fluid-Structure Interaction</a></li><li><a class="tocitem" href="../t013_emscatter/">13 Electromagnetic scattering in 2D</a></li><li><a class="tocitem" href="../t014_poisson_dev_fe/">14 Low-level API Poisson equation</a></li><li><a class="tocitem" href="../t015_validation_DrWatson/">15 On using DrWatson.jl</a></li><li><a class="tocitem" href="../t016_interpolation_fe/">16 Interpolation of CellFields</a></li><li><a class="tocitem" href="../t017_poisson_distributed/">17 Poisson equation on parallel distributed-memory computers</a></li><li><a class="tocitem" href="../t018_transient_linear/">18 Transient Poisson equation</a></li><li><a class="tocitem" href="../t019_transient_nonlinear/">19 Transient nonlinear equation</a></li><li><a class="tocitem" href="../t020_TopOptEMFocus/">20 Topology optimization</a></li><li><a class="tocitem" href="../t021_unfitted_poisson/">21 Unfitted Poisson</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>10 Advection-diffusion</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>10 Advection-diffusion</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Tutorials/blob/master/src/advection_diffusion.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="advection_diffusion.jl-1"><a class="docs-heading-anchor" href="#advection_diffusion.jl-1">Tutorial 10: Advection-diffusion</a><a class="docs-heading-anchor-permalink" href="#advection_diffusion.jl-1" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t010_advection_diffusion.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t010_advection_diffusion.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will learn:</p><ul><li>Advection and diffusion term explanation</li><li>How to create models with arbitrary geometry in Gmsh</li><li>How to define the equation in the weak form</li><li>How to solve for and visualize the results</li></ul><h2 id="Problem-statement-1"><a class="docs-heading-anchor" href="#Problem-statement-1">Problem statement</a><a class="docs-heading-anchor-permalink" href="#Problem-statement-1" title="Permalink"></a></h2><p>In this tutorial we will solve the steady-state advection-diffusion equation.</p><p>In fluid mechanics, advection refers to the transport of a substance or property (such as heat, mass and momentum) by the motion of the fluid itself. It is a key mechanism in which quantities are carried along with the bulk movement of the fluid. As opposed to advection, diffusion refers to the process where substances spread out due to concentration gradients, moving from regions of higher concentration to regions of lower concentration.</p><p>The advection-diffusion equation combines the effects of both mechanisms, making it a powerful tool for modeling real-world transport processes where substances are not only carried by the flow of a fluid but also spread out over time due to diffusion. The best example of an advection-diffusion equation in the real case is the temperature distribution in a flow field.</p><p>Formally, a steady-state advection-diffusion equation with Dirichlet boundary conditions could be defined as:</p><p>$ \nabla \cdot \left ( D\nabla T - \vec{V}T  \right ) =0 $ ,<br/>$ T = g $ on boundaries,</p><p>where:</p><ul><li><span>$T$</span> is the scalar quantity being transported (here T refers to temperature);</li><li><span>$\vec{V}$</span> is the velocity vector of the fluid (representing advection);</li><li><span>$D$</span> is the diffusion coefficient (a constant that characterizes the rate of diffusion).</li></ul><p>In order to help users get to know the strong feasibility of Gmsh, where users can create the geometry needed for Gridap, we will define the domain in the shape of a pentagon. We will see both result plottings with and without advection effect.</p><h2 id="Model-geometry-in-Gmsh-1"><a class="docs-heading-anchor" href="#Model-geometry-in-Gmsh-1">Model geometry in Gmsh</a><a class="docs-heading-anchor-permalink" href="#Model-geometry-in-Gmsh-1" title="Permalink"></a></h2><p>This is one of  the most important parts of this tutorial. In this case, we make fully use of <code>Gmsh</code>, an open-source finite element mesh generator with a built-in CAD engine and post-processor. Gmsh is the tool highly bound to <code>Gridap.jl</code>, and it has its own scripting language (<code>.geo</code> scripts), and the scripts could be loaded to a very nice-designed user interface, <code>ONELAB</code>. In <code>ONELAB</code>, you could easily run the script you wrote, and generate the mesh you want. Here we would illustrate the whole process of creating a 2D model in a pentagon shape using <code>Gmsh</code> step by step.</p><p>Note that all the code in this part (&quot;Model geometry in Gmsh&quot;) is for the <code>.geo</code> scripts.</p><p>First thing we need to create is the point, which is the simplest entity we can define in <code>Gmsh</code>. Note that in <code>Gmsh</code>, all points are uniquely identified by a tag (a strictly positive integer) and defined by a list of four numbers: three coordinates (<code>X</code>, <code>Y</code> and <code>Z</code>) and the target mesh size (we always use <code>lc</code>, which stands for characteristic length) close to the point.</p><p>Here we would like to define a pentagon with side length of 2, and <code>lc</code> as following:</p><pre><code class="language-js">lc = 1e-1;</code></pre><p>So, all five points could be defined as:</p><pre><code class="language-js">Point(1) = {0, -1.0000, 0, lc};
Point(2) = {0, 1.0000,  0, lc};
Point(3) = {1.9015, 1.6190, 0, lc};
Point(4) = {3.0777, 0, 0, lc};
Point(5) = {1.9015, -1.6190, 0, lc};</code></pre><p>Once we have the points, we could naturally try to define the lines. Obviously here we have 5 sides of the pentagon to define. The definition of lines is pretty much the same as points. A straight line is defined by a list of two-point tags, and itself can also be identified by a tag.</p><pre><code class="language-js">Line(1) = {1, 2};
Line(2) = {2, 3};
Line(3) = {3, 4};
Line(4) = {4, 5};
Line(5) = {5, 1};</code></pre><p>With the lines defined, we can now define the curve loop, which we could utilize to make a surface. A curve loop is defined by an ordered list of connected lines.</p><pre><code class="language-js">Curve Loop(1) = {1, 2, 3, 4, 5};</code></pre><p>And now is the final step, that is to define the surface. Until now Gmsh has totally understand what we are going to design with the model.</p><pre><code class="language-js">Plane Surface(1) = {1};</code></pre><p>There is another option here: we can try to define physical groups among the entities we defined before. By defining physical groups, we can better assign the “roles” to the entities we defined. Here for example:</p><pre><code class="language-js">Physical Line(&quot;l1&quot;) = {1};
Physical Line(&quot;l2&quot;) = {2};
Physical Line(&quot;l3&quot;) = {3};
Physical Line(&quot;l4&quot;) = {4};
Physical Line(&quot;l5&quot;) = {5};</code></pre><p>Once we have the model geometry, we can simply click <code>2D</code> under the <code>mesh</code> category and then click <code>save</code>. Then Gmsh would generate a <code>.msh</code> file for us. Or we could use code below to ouput the <code>.msh</code> file directly:</p><pre><code class="language-js">Mesh 2;
Save &quot;pentagon_mesh.msh&quot;;</code></pre><p>The meshed model is like following:</p><p><img src="Pentagon_2D_Mesh.png" alt="Pentagon_2D_Mesh"/></p><h2 id="Numerical-Scheme-1"><a class="docs-heading-anchor" href="#Numerical-Scheme-1">Numerical Scheme</a><a class="docs-heading-anchor-permalink" href="#Numerical-Scheme-1" title="Permalink"></a></h2><p>The weak form of a PDE is a reformulation that allows the problem to be solved in a broader function space. Instead of requiring the solution to satisfy the PDE at every point (as in the strong form), the weak form requires the solution to satisfy an integral equation. This makes it particularly suitable for numerical methods such as the Finite Element Method.</p><p>Since we already hcave the original PDE (strong form), we can multiply each side by a test function <span>$v \in H^1(\Omega)$</span>(functions with square-integrable first derivatives). <span>$v$</span> satisfies the Dirichlet boundary condition of <span>$0$</span>. Make integral on both sides.</p><p>The weak form associated with this formulation is, find <span>$T \in H^1(\Omega)$</span>, such that: $ \int_\Omega v (\mathbf{u} \cdot \nabla T) \, \mathrm{d}\Omega</p><ul><li>\int_\Omega D \nabla T \cdot \nabla v \, \mathrm{d}\Omega</li></ul><p>= 0 $</p><h2 id="FE-spaces-1"><a class="docs-heading-anchor" href="#FE-spaces-1">FE spaces</a><a class="docs-heading-anchor-permalink" href="#FE-spaces-1" title="Permalink"></a></h2><p>First, import <code>Gridap.jl</code>.</p><pre><code class="language-julia">using Gridap
using GridapGmsh</code></pre><p>Import the model from file using GmshDiscreteModel:</p><pre><code class="language-julia">model_pentagon = GmshDiscreteModel(&quot;pentagon_mesh.msh&quot;)</code></pre><p>Set up the test FE space <span>$V_0$</span>, which conforms the zero value boundary conditions.</p><pre><code class="language-julia">order = 1
reffe = ReferenceFE(lagrangian,Float64,order)
V_0 = TestFESpace(model_pentagon,reffe;conformity=:H1,dirichlet_tags=[&quot;l1&quot;,&quot;l2&quot;,&quot;l3&quot;,&quot;l4&quot;,&quot;l5&quot;])</code></pre><p>Set up the boundary conditions. Here we set 5 values, representing 5 different temperatures on 5 sides of the pentagon. Notw that <span>$l1$</span> is the most left vertical side, we would like to define this as 200. We define the middle two 2 sides as 100, and the most right two sides as 0. Define the trial space <span>$U_g$</span>.</p><pre><code class="language-julia">boundary_cond = [200,100,0,0,100];
U_g = TrialFESpace(V_0,boundary_cond)</code></pre><p>Do the integration over domain <span>$\Omega$</span>.</p><pre><code class="language-julia">degree = 2
Ω = Triangulation(model_pentagon)
dΩ = Measure(Ω,degree)</code></pre><h2 id="Weak-form-1"><a class="docs-heading-anchor" href="#Weak-form-1">Weak form</a><a class="docs-heading-anchor-permalink" href="#Weak-form-1" title="Permalink"></a></h2><p>Define the velocity field <span>$\vec{V}T = (u_1,u_2)$</span>. Here we have two options:</p><ul><li>zero velocity;</li><li><span>$u_1 = 0$</span>, and <span>$u_2 = 2$</span>. That means the flow is going up at a velocity of 2.</li></ul><pre><code class="language-julia">velocity_zero = VectorValue(0.0, 0.0);

velocity_nonzero = VectorValue(0.0, 2.0);
nothing #hide</code></pre><p>Duffusion coefficient is defined as:</p><pre><code class="language-julia">D = 0.1;
nothing #hide</code></pre><p>The weak form can thus be represented as:</p><pre><code class="language-julia">a_zero(u, v)     = ∫(v * (velocity_zero ⋅∇(u))    + ∇(v) ⋅ (D * ∇(u))) * dΩ
a_non_zero(u, v) = ∫(v * (velocity_nonzero ⋅∇(u)) + ∇(v) ⋅ (D * ∇(u))) * dΩ
b(v) = 0.0</code></pre><h2 id="Solution-1"><a class="docs-heading-anchor" href="#Solution-1">Solution</a><a class="docs-heading-anchor-permalink" href="#Solution-1" title="Permalink"></a></h2><p>Now build the FE problem and use the solver. We are solving for both zero and non-zero flow velocity.</p><pre><code class="language-julia">op_zero = AffineFEOperator(a_zero,b,U_g,V_0)
uh_zero = Gridap.Algebra.solve(op_zero)

op_non_zero = AffineFEOperator(a_non_zero,b,U_g,V_0)
uh_non_zero = Gridap.Algebra.solve(op_non_zero)</code></pre><p>Ouput the result as a <code>.vtk</code> file.</p><pre><code class="language-julia">writevtk(Ω,&quot;results_zero&quot;,cellfields=[&quot;uh_zero&quot;=&gt;uh_zero])

writevtk(Ω,&quot;results_non_zero&quot;,cellfields=[&quot;uh_non_zero&quot;=&gt;uh_non_zero])</code></pre><h2 id="Visualization-1"><a class="docs-heading-anchor" href="#Visualization-1">Visualization</a><a class="docs-heading-anchor-permalink" href="#Visualization-1" title="Permalink"></a></h2><p>We can use the ParaView to preview the results clearly. Here is the temperature distribution without any flow velocity:</p><p><img src="Result_zero.png" alt="Result_zero"/></p><p>Here is the temperature distribution with a flow velocity of 2 going up:</p><p><img src="Result_non_zero.png" alt="Result_zero"/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t009_stokes/">« 9 Stokes equation</a><a class="docs-footer-nextpage" href="../t011_isotropic_damage/">11 Isotropic damage model »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 5 March 2025 02:27">Wednesday 5 March 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
