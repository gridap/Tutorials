<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>13 Electromagnetic scattering in 2D · Gridap tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gridap tutorials logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap tutorials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="tocitem" href="../t002_validation/">2 Code validation</a></li><li><a class="tocitem" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="tocitem" href="../t004_p_laplacian/">4 p-Laplacian</a></li><li><a class="tocitem" href="../t005_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="tocitem" href="../t006_dg_discretization/">6 Poisson equation (with DG)</a></li><li><a class="tocitem" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="tocitem" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li><li><a class="tocitem" href="../t009_stokes/">9 Stokes equation</a></li><li><a class="tocitem" href="../t010_advection_diffusion/">10 Advection-diffusion</a></li><li><a class="tocitem" href="../t011_isotropic_damage/">11 Isotropic damage model</a></li><li><a class="tocitem" href="../t012_fsi_tutorial/">12 Fluid-Structure Interaction</a></li><li class="is-active"><a class="tocitem" href>13 Electromagnetic scattering in 2D</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement-1"><span>Problem statement</span></a></li><li><a class="tocitem" href="#Numerical-scheme-1"><span>Numerical scheme</span></a></li><li><a class="tocitem" href="#Setup-1"><span>Setup</span></a></li><li><a class="tocitem" href="#Discrete-Model-1"><span>Discrete Model</span></a></li><li><a class="tocitem" href="#FE-spaces-1"><span>FE spaces</span></a></li><li><a class="tocitem" href="#Numerical-integration-1"><span>Numerical integration</span></a></li><li><a class="tocitem" href="#PML-formulation-1"><span>PML formulation</span></a></li><li><a class="tocitem" href="#Weak-form-1"><span>Weak form</span></a></li><li><a class="tocitem" href="#Solver-phase-1"><span>Solver phase</span></a></li><li><a class="tocitem" href="#Analytical-solution-1"><span>Analytical solution</span></a></li><li><a class="tocitem" href="#Output-and-compare-results-1"><span>Output and compare results</span></a></li><li><a class="tocitem" href="#References-1"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../t014_validation_DrWatson/">14 On using DrWatson.jl</a></li><li><a class="tocitem" href="../t015_interpolation_fe/">15 Interpolation of CellFields</a></li><li><a class="tocitem" href="../t016_poisson_distributed/">16 Poisson equation on parallel distributed-memory computers</a></li><li><a class="tocitem" href="../t017_transient_linear/">17 Transient Poisson equation</a></li><li><a class="tocitem" href="../t018_transient_nonlinear/">18 Transient nonlinear equation</a></li><li><a class="tocitem" href="../t019_TopOptEMFocus/">19 Topology optimization</a></li><li><a class="tocitem" href="../t020_poisson_unfitted/">20 Poisson on unfitted meshes</a></li><li><a class="tocitem" href="../t021_poisson_amr/">21 Poisson with AMR</a></li><li><a class="tocitem" href="../t022_poisson_hdg/">22 Poisson with HDG</a></li><li><a class="tocitem" href="../t023_poisson_hho/">23 Poisson with HHO on polytopal meshes</a></li><li><a class="tocitem" href="../t024_stokes_blocks/">24 Block assembly and solvers: Incompressible Stokes example</a></li><li><a class="tocitem" href="../t025_lagrange_multipliers/">25 Lagrange multipliers</a></li><li><a class="tocitem" href="../t026_poisson_dev_fe/">26 Low-level API - Poisson equation</a></li><li><a class="tocitem" href="../t027_geometry_dev/">27 Low-level API - Geometry</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>13 Electromagnetic scattering in 2D</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>13 Electromagnetic scattering in 2D</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Tutorials/blob/master/src/emscatter.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="emscatter.jl-1"><a class="docs-heading-anchor" href="#emscatter.jl-1">Tutorial 13: Electromagnetic scattering in 2D</a><a class="docs-heading-anchor-permalink" href="#emscatter.jl-1" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t013_emscatter.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t013_emscatter.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will learn:</p><ul><li>How to formulate the weak form for a scalar time-harmonic electromagnetic problem</li><li>How to implement a perfectly matched layer (PML) to absorb outgoing waves</li><li>How to impose periodic boundary conditions in Gridap</li><li>How to discretize PDEs with complex-valued solutions</li></ul><h2 id="Problem-statement-1"><a class="docs-heading-anchor" href="#Problem-statement-1">Problem statement</a><a class="docs-heading-anchor-permalink" href="#Problem-statement-1" title="Permalink"></a></h2><p>We are going to solve a scalar electromagnetic wave scattering problem: a plane wave (Hz-polarized <span>$H_{inc}$</span>) scattering of a dielectric cylinder (of radius <span>$R$</span> and permittivity <span>$\varepsilon$</span>), as illustrated below. The computational cell is of height <span>$H$</span> and length <span>$L$</span>, and we employ a perfectly matched layer (PML) thickness of <span>$d_{pml}$</span> to implement outgoing (radiation) boundary conditions for this finite domain.</p><p><img src="../../assets/emscatter/Illustration.png" alt/></p><p>From Maxwell&#39;s equations, considering a time-harmonic electromagnetic field, we can derive the governing equation of this problem in 2D (Helmholtz equation) [1]:</p><div>\[\left[-\nabla\cdot\frac{1}{\varepsilon(x)}\nabla -k^2\mu(x)\right] H = f(x),\]</div><p>where <span>$k=\omega/c$</span> is the wave number in free space and <span>$f(x)$</span> is the source term (which corresponds to a magnetic current density in Maxwell&#39;s equations).</p><p>In order to simulate this scattering problem in a finite computation cell, we need outgoing (radiation) boundary conditions such that all waves at the boundary would not be reflected back since we are simulating an infinite space. One commonly used technique to simulate such infinite space is through the so called &quot;perfectly matched layers&quot; (PML) [2]. Actually, PML is not a boundary condition but an artificial absorbing &quot;layer&quot; that absorbs waves with minimal reflections (going to zero as the resolution increases). There are many formulations of PML. Here, we use one of the most flexible formulations, the &quot;stretched-coordinate&quot; formulation, which takes the following replace in the PDE [3]:</p><div>\[\frac{\partial}{\partial x}\rightarrow \frac{1}{1+\mathrm{i}\sigma(u_x)/\omega}\frac{\partial}{\partial x},\]</div><div>\[\frac{\partial}{\partial y}\rightarrow \frac{1}{1+\mathrm{i}\sigma(u_y)/\omega}\frac{\partial}{\partial y},\]</div><p>where <span>$u_{x/y}$</span> is the depth into the PML, <span>$\sigma$</span> is a profile function (here we chose <span>$\sigma(u)=\sigma_0(u/d_{pml})^2$</span>) and different derivative corresponds to different absorption directions. Note that at a finite mesh resolution, PML reflects some waves, and the standard technique to mitigate this is to &quot;turn on&quot; the PML absorption gradually—in this case we use a quadratic profile. The amplitude <span>$\sigma_0$</span> is chosen so that in the limit of infinite resolution the &quot;round-trip&quot; normal-incidence is some small number.</p><p>Since PML absorbs all waves in <span>$x/y$</span> direction, the associated boundary condition is then usually the zero Dirichlet boundary condition. Here, the boundary conditions are zero Dirichlet boundary on the top and bottom side <span>$\Gamma_D$</span> but periodic boundary condition on the left (<span>$\Gamma_L$</span>) and right side (<span>$\Gamma_R$</span>). The reason that we use a periodic boundary condition for the left and right side instead of zero Dirichlet boundary condition is that we want to simulate a plane wave excitation, which then requires a periodic boundary condition.</p><p>Consider <span>$\mu(x)=1$</span> (which is mostly the case in electromagnetic problems) and denote <span>$\Lambda=\operatorname{diagm}(\Lambda_x,\Lambda_y)$</span> where <span>$\Lambda_{x/y}=\frac{1}{1+\mathrm{i}\sigma(u_{x/y})/\omega}$</span>, we can formulate the problem as</p><div>\[\left\{ \begin{aligned}
\left[-\Lambda\nabla\cdot\frac{1}{\varepsilon(x)}\Lambda\nabla -k^2\right] H &amp;= f(x) &amp; \text{ in } \Omega,\\
H&amp;=0 &amp; \text{ on } \Gamma_D,\\
H|_{\Gamma_L}&amp;=H|_{\Gamma_R},&amp;\\
\end{aligned}\right.\]</div><p>For convenience, in the weak form and Julia implementation below we represent <span>$\Lambda$</span> as a vector instead of a diagonal <span>$2 \times 2$</span> matrix, in which case <span>$\Lambda\nabla$</span> becomes the element-wise product.</p><h2 id="Numerical-scheme-1"><a class="docs-heading-anchor" href="#Numerical-scheme-1">Numerical scheme</a><a class="docs-heading-anchor-permalink" href="#Numerical-scheme-1" title="Permalink"></a></h2><p>Similar to the previous tutorials, we need to construct the weak form for the above PDEs. After integral by part and removing the zero boundary integral term, we get:</p><div>\[a(u,v) = \int_\Omega \left[\nabla(\Lambda v)\cdot\frac{1}{\varepsilon(x)}\Lambda\nabla u-k^2uv\right]\mathrm{d}\Omega\]</div><div>\[b(v) = \int_\Omega vf\mathrm{d}\Omega\]</div><p>Notice that the <span>$\nabla(\Lambda v)$</span> is also a element-wise &quot;product&quot; of two vectors <span>$\nabla$</span> and <span>$\Lambda v$</span>.</p><h2 id="Setup-1"><a class="docs-heading-anchor" href="#Setup-1">Setup</a><a class="docs-heading-anchor-permalink" href="#Setup-1" title="Permalink"></a></h2><p>We import the packages that will be used, define the geometry and physics parameters.</p><pre><code class="language-julia">using Gridap
using GridapGmsh
using Gridap.Fields
using Gridap.Geometry

λ = 1.0          # Wavelength (arbitrary unit)
L = 4.0          # Width of the area
H = 6.0          # Height of the area
xc = [0 -1.0]    # Center of the cylinder
r = 1.0          # Radius of the cylinder
d_pml = 0.8      # Thickness of the PML
k = 2*π/λ        # Wave number
const ϵ₁ = 3.0   # Relative electric permittivity for cylinder</code></pre><h2 id="Discrete-Model-1"><a class="docs-heading-anchor" href="#Discrete-Model-1">Discrete Model</a><a class="docs-heading-anchor-permalink" href="#Discrete-Model-1" title="Permalink"></a></h2><p>We import the model from the <code>geometry.msh</code> mesh file using the <code>GmshDiscreteModel</code> function defined in <code>GridapGmsh</code>. The mesh file is created with GMSH in Julia (see the file ../assets/emscatter/MeshGenerator.jl). Note that this mesh file already contains periodic boundary information for the left and right side, and that is enough for gridap to realize a periodic boundary condition should be implemented.</p><pre><code class="language-julia">model = GmshDiscreteModel(&quot;../models/geometry.msh&quot;)</code></pre><h2 id="FE-spaces-1"><a class="docs-heading-anchor" href="#FE-spaces-1">FE spaces</a><a class="docs-heading-anchor-permalink" href="#FE-spaces-1" title="Permalink"></a></h2><p>We use the first-order Lagrangian as the finite element function space basis. The Dirichlet edges are labeled with <code>DirichletEdges</code> in the mesh file. Since our problem involves complex numbers (because of PML), we need to assign the <code>vector_type</code> to be <code>Vector{ComplexF64}</code>.</p><h3 id="Test-and-trial-finite-element-function-space-1"><a class="docs-heading-anchor" href="#Test-and-trial-finite-element-function-space-1">Test and trial finite element function space</a><a class="docs-heading-anchor-permalink" href="#Test-and-trial-finite-element-function-space-1" title="Permalink"></a></h3><pre><code class="language-julia">order = 1
reffe = ReferenceFE(lagrangian,Float64,order)
V = TestFESpace(model,reffe,dirichlet_tags=&quot;DirichletEdges&quot;,vector_type=Vector{ComplexF64})
U = V # mathematically equivalent to TrialFESpace(V,0)</code></pre><h2 id="Numerical-integration-1"><a class="docs-heading-anchor" href="#Numerical-integration-1">Numerical integration</a><a class="docs-heading-anchor-permalink" href="#Numerical-integration-1" title="Permalink"></a></h2><p>We generate the triangulation and a second-order Gaussian quadrature for the numerical integration. Note that we create a boundary triangulation from a <code>Source</code> tag for the line excitation. Generally, we do not need such additional mesh tags for the source, we can use a delta function to approximate such line source excitation. However, by generating a line mesh, we can increase the accuracy of this source excitation.</p><h3 id="Generate-triangulation-and-quadrature-from-model-1"><a class="docs-heading-anchor" href="#Generate-triangulation-and-quadrature-from-model-1">Generate triangulation and quadrature from model</a><a class="docs-heading-anchor-permalink" href="#Generate-triangulation-and-quadrature-from-model-1" title="Permalink"></a></h3><pre><code class="language-julia">degree = 2
Ω = Triangulation(model)
dΩ = Measure(Ω,degree)</code></pre><h3 id="Source-triangulation-1"><a class="docs-heading-anchor" href="#Source-triangulation-1">Source triangulation</a><a class="docs-heading-anchor-permalink" href="#Source-triangulation-1" title="Permalink"></a></h3><pre><code class="language-julia">Γ = BoundaryTriangulation(model;tags=&quot;Source&quot;)
dΓ = Measure(Γ,degree)</code></pre><h2 id="PML-formulation-1"><a class="docs-heading-anchor" href="#PML-formulation-1">PML formulation</a><a class="docs-heading-anchor-permalink" href="#PML-formulation-1" title="Permalink"></a></h2><p>Here we first define a <code>s_PML</code> function: <span>$s(x)=1+\mathrm{i}\sigma(u)/\omega,$</span> and its derivative <code>ds_PML</code>. The parameter <code>LH</code> indicates the size of the inner boundary of the PML regions. Finally, we create a function-like object <code>Λ</code> that returns the PML factors and define its derivative in gridap. Note that here we are defining a &quot;callable object&quot; of type <code>Λ</code> that encapsulates all of the PML parameters. This is convenient, both because we can pass lots of parameters around easily and also because we can define additional methods on <code>Λ</code>, e.g. to express the <code>∇(Λv)</code> operation.</p><h3 id="PML-parameters-1"><a class="docs-heading-anchor" href="#PML-parameters-1">PML parameters</a><a class="docs-heading-anchor-permalink" href="#PML-parameters-1" title="Permalink"></a></h3><pre><code class="language-julia">Rpml = 1e-12      # Tolerance for PML reflection
σ = -3/4*log(Rpml)/d_pml # σ_0
LH = (L,H) # Size of the PML inner boundary (a rectangular center at (0,0))</code></pre><h3 id="PML-coordinate-stretching-functions-1"><a class="docs-heading-anchor" href="#PML-coordinate-stretching-functions-1">PML coordinate stretching functions</a><a class="docs-heading-anchor-permalink" href="#PML-coordinate-stretching-functions-1" title="Permalink"></a></h3><pre><code class="language-julia">function s_PML(x,σ,k,LH,d_pml)
    u = abs.(Tuple(x)).-LH./2  # get the depth into PML
    return @. ifelse(u &gt; 0,  1+(1im*σ/k)*(u/d_pml)^2, $(1.0+0im))
end

function ds_PML(x,σ,k,LH,d_pml)
    u = abs.(Tuple(x)).-LH./2 # get the depth into PML
    ds = @. ifelse(u &gt; 0, (2im*σ/k)*(1/d_pml)^2*u, $(0.0+0im))
    return ds.*sign.(Tuple(x))
end

struct Λ&lt;:Function
    σ::Float64
    k::Float64
    LH::NTuple{2,Float64}
    d_pml::Float64
end

function (Λf::Λ)(x)
    s_x,s_y = s_PML(x,Λf.σ,Λf.k,Λf.LH,Λf.d_pml)
    return VectorValue(1/s_x,1/s_y)
end

Fields.∇(Λf::Λ) = x-&gt;TensorValue{2,2,ComplexF64}(-(Λf(x)[1])^2*ds_PML(x,Λf.σ,Λf.k,Λf.LH,Λf.d_pml)[1],0,0,-(Λf(x)[2])^2*ds_PML(x,Λf.σ,Λf.k,Λf.LH,Λf.d_pml)[2])</code></pre><h2 id="Weak-form-1"><a class="docs-heading-anchor" href="#Weak-form-1">Weak form</a><a class="docs-heading-anchor-permalink" href="#Weak-form-1" title="Permalink"></a></h2><p>In the mesh file, we labeled the cylinder region with <code>Cylinder</code> to distinguish it from other regions. Using this tag, we can assign material properties correspondingly (basically a function with different value in different regions). The weak form is very similar to its mathematical form in gridap.</p><h3 id="Intermediate-variables-1"><a class="docs-heading-anchor" href="#Intermediate-variables-1">Intermediate variables</a><a class="docs-heading-anchor-permalink" href="#Intermediate-variables-1" title="Permalink"></a></h3><pre><code class="language-julia">labels = get_face_labeling(model)
dimension = num_cell_dims(model)
tags = get_face_tag(labels,dimension)
const cylinder_tag = get_tag_from_name(labels,&quot;Cylinder&quot;)

function ξ(tag)
    if tag == cylinder_tag
        return 1/ϵ₁
    else
        return 1.0
    end
end

τ = CellField(tags,Ω)
Λf = Λ(σ,k,LH,d_pml)</code></pre><h3 id="Bi-linear-term-(from-weak-form)-1"><a class="docs-heading-anchor" href="#Bi-linear-term-(from-weak-form)-1">Bi-linear term (from weak form)</a><a class="docs-heading-anchor-permalink" href="#Bi-linear-term-(from-weak-form)-1" title="Permalink"></a></h3><p>Note that we use a element-wise product .* here for the vector-vector product <span>$\Lambda \nabla$</span></p><pre><code class="language-julia">a(u,v) = ∫(  (∇.*(Λf*v))⊙((ξ∘τ)*(Λf.*∇(u))) - (k^2*(v*u))  )dΩ</code></pre><h3 id="Source-term-(uniform-line-source)-1"><a class="docs-heading-anchor" href="#Source-term-(uniform-line-source)-1">Source term (uniform line source)</a><a class="docs-heading-anchor-permalink" href="#Source-term-(uniform-line-source)-1" title="Permalink"></a></h3><pre><code class="language-julia">b(v) = ∫(v)*dΓ</code></pre><h2 id="Solver-phase-1"><a class="docs-heading-anchor" href="#Solver-phase-1">Solver phase</a><a class="docs-heading-anchor-permalink" href="#Solver-phase-1" title="Permalink"></a></h2><p>We can assemble the finite element operator in Gridap with the bi-linear and linear form, then solve for the field.</p><pre><code class="language-julia">op = AffineFEOperator(a,b,U,V)
uh = solve(op)</code></pre><h2 id="Analytical-solution-1"><a class="docs-heading-anchor" href="#Analytical-solution-1">Analytical solution</a><a class="docs-heading-anchor-permalink" href="#Analytical-solution-1" title="Permalink"></a></h2><h3 id="Theoretical-analysis-1"><a class="docs-heading-anchor" href="#Theoretical-analysis-1">Theoretical analysis</a><a class="docs-heading-anchor-permalink" href="#Theoretical-analysis-1" title="Permalink"></a></h3><p>In this section, we construct the semi-analytical solution to this scattering problem, for comparison to the numerical solution. This is possible because of the symmetry of the cylinder, which allows us to expand the solutions of the Helmholtz equation in Bessel functions and match boundary conditions at the cylinder interface. (In 3d, the analogous process with spherical harmonics is known as &quot;Mie scattering&quot;.) For more information on this technique, see Ref [4]. In 2D cylinder coordinates, we can expand the plane wave in terms of Bessel functions (this is the Jacobi–Anger identity [5]):</p><div>\[H_0=\sum_m i^mJ_m(kr)e^{im\theta},\]</div><p>where <span>$m=0,\pm 1,\pm 2,\dots$</span> and <span>$J_m(z)$</span> is the Bessel function of the first kind.</p><p>For simplicity, we start with only the <span>$m$</span>-th component and take it as the incident part:</p><div>\[H_{inc}=J_m(kr).\]</div><p>For the scattered field, since the scattered wave should be going out, we can then expand it in terms of the Hankel function of the first kind (outgoing and incoming cylindrical waves are Hankel functions of the first and second kind [6]):</p><div>\[H_1=\alpha_mH_m^1(kr).\]</div><p>For the fields inside the cylinder, we require the field to be finite at <span>$r=0$</span>, which then constrains the field to be only the expansion of the Bessel functions:</p><div>\[H_2=\beta_mJ_m(nkr),\]</div><p>where <span>$n=\sqrt{\varepsilon}$</span> is the refractive index.</p><p>Applying the boundary conditions (tangential part of the electric and magnetic field to be continuous):</p><div>\[H_{inc}+H_1=H_2|_{r=R},\]</div><div>\[\frac{\partial H_{inc}}{\partial r}+\frac{\partial H_1}{\partial r}=\frac{1}{\epsilon}\frac{\partial H_2}{\partial r}|_{r=R}.\]</div><p>After some math, we get:</p><div>\[\alpha_m=\frac{J_m(nkR)J_m(kR)^\prime-\frac{1}{n}J_m(kR)J_m(nkR)^\prime}{\frac{1}{n}H_m^1(kR)J_m(nkr)^\prime-J_m(nkr)H_m^1(kr)^\prime},\]</div><div>\[\beta_m = \frac{H_m^1(kR)J_m(kR)^\prime-J_m(kR)H_m^1(kR)^\prime}{\frac{1}{n}J_m(nkR)^\prime H_m^1(kR)-J_m(nkR)H_m^1(kR)^\prime},\]</div><p>where <span>$^\prime$</span> denotes the derivative, and the derivatives of the Bessel functions are obtained with the recurrent relations:</p><div>\[Y_m(z)^\prime=\frac{Y_{m-1}(z)-Y_{m+1}(z)}{2}\]</div><p>where <span>$Y_m$</span> denotes any Bessel functions (Hankel functions).</p><p>Finally, the analytical field is (<span>$1/2k$</span> is the amplitude that comes from the unit line source excitation):</p><div>\[H(r&gt;R)=\frac{1}{2k}\sum_m\left[\alpha_mi^mH_m^1(kr)+J_m(kr)\right]e^{im\theta}\]</div><div>\[H(r\leq R)=\frac{1}{2k}\sum_m\beta_mi^mJ_m(nkr)e^{im\theta}\]</div><h3 id="Define-the-analytical-functions-1"><a class="docs-heading-anchor" href="#Define-the-analytical-functions-1">Define the analytical functions</a><a class="docs-heading-anchor-permalink" href="#Define-the-analytical-functions-1" title="Permalink"></a></h3><pre><code class="language-julia">using SpecialFunctions
dbesselj(m,z) = (besselj(m-1,z)-besselj(m+1,z))/2
dhankelh1(m,z)= (hankelh1(m-1,z)-hankelh1(m+1,z))/2
α(m,n,z) = (besselj(m,n*z)*dbesselj(m,z)-1/n*besselj(m,z)*dbesselj(m,n*z))/(1/n*hankelh1(m,z)*dbesselj(m,n*z)-besselj(m,n*z)*dhankelh1(m,z))
β(m,n,z) = (hankelh1(m,z)*dbesselj(m,z)-besselj(m,z)*dhankelh1(m,z))/(1/n*dbesselj(m,n*z)*hankelh1(m,z)-besselj(m,n*z)*dhankelh1(m,z))

function H_t(x,xc,r,ϵ,λ)
    n = √ϵ
    k = 2*π/λ
    θ = angle(x[1]-xc[1]+1im*(x[2]-xc[2]))+π
    M = 40 # Number of Bessel function basis used
    H0 = 0
    if norm([x[1]-xc[1],x[2]-xc[2]])&lt;=r
        for m=-M:M
            H0 += β(m,n,k*r)*cis(m*θ)*besselj(m,n*k*norm([x[1]-xc[1],x[2]-xc[2]]))
        end
    else
        for m=-M:M
            H0 += α(m,n,k*r)*cis(m*θ)*hankelh1(m,k*norm([x[1]-xc[1],x[2]-xc[2]]))+cis(m*θ)*besselj(m,k*norm([x[1]-xc[1],x[2]-xc[2]]))
        end
    end
    return 1im/(2*k)*H0
end</code></pre><h3 id="Construct-the-analytical-solution-in-finite-element-basis-1"><a class="docs-heading-anchor" href="#Construct-the-analytical-solution-in-finite-element-basis-1">Construct the analytical solution in finite element basis</a><a class="docs-heading-anchor-permalink" href="#Construct-the-analytical-solution-in-finite-element-basis-1" title="Permalink"></a></h3><pre><code class="language-julia">uh_t = CellField(x-&gt;H_t(x,xc,r,ϵ₁,λ),Ω)</code></pre><h2 id="Output-and-compare-results-1"><a class="docs-heading-anchor" href="#Output-and-compare-results-1">Output and compare results</a><a class="docs-heading-anchor-permalink" href="#Output-and-compare-results-1" title="Permalink"></a></h2><p>The simulated field is shown below. We can see that the simulated fields and the analytical solution matched closed except for the top and PML regions. This is because the simulated source generate plane waves in two directions but we only consider the downward propagating wave in the analytical solution and the PML effect is also not considered in the analytical solution. Therefore, we just need to focus on the &quot;center&quot; regions which excludes the PML and top region above the source, the difference is within 6% of the field amplitude integral. As we increase the resolution, this difference should decrease (until it becomes limited by the PML reflection coefficient from <span>$\sigma_0$</span>, the number of Bessel function basis <span>$M$</span> or by floating-point error.) <img src="../../assets/emscatter/Results.png" alt/></p><h3 id="Save-to-file-and-view-1"><a class="docs-heading-anchor" href="#Save-to-file-and-view-1">Save to file and view</a><a class="docs-heading-anchor-permalink" href="#Save-to-file-and-view-1" title="Permalink"></a></h3><pre><code class="language-julia">mkpath(&quot;output_path&quot;)
writevtk(Ω,&quot;output_path/demo&quot;,cellfields=[&quot;Real&quot;=&gt;real(uh),
        &quot;Imag&quot;=&gt;imag(uh),
        &quot;Norm&quot;=&gt;abs2(uh),
        &quot;Real_t&quot;=&gt;real(uh_t),
        &quot;Imag_t&quot;=&gt;imag(uh_t),
        &quot;Norm_t&quot;=&gt;abs2(uh_t),
        &quot;Difference&quot;=&gt;abs(uh_t-uh)])</code></pre><h3 id="Compare-the-difference-in-the-&quot;center&quot;-region-1"><a class="docs-heading-anchor" href="#Compare-the-difference-in-the-&quot;center&quot;-region-1">Compare the difference in the &quot;center&quot; region</a><a class="docs-heading-anchor-permalink" href="#Compare-the-difference-in-the-&quot;center&quot;-region-1" title="Permalink"></a></h3><pre><code class="language-julia">function AnalyticalBox(x) # Get the &quot;center&quot; region
    if abs(x[1])&lt;L/2 &amp;&amp; abs(x[2]+0.5)&lt;2.5
        return 1
    else
        return 0
    end
end

Difference=sqrt(sum(∫(abs2(uh_t-uh)*AnalyticalBox)*dΩ)/sum(∫(abs2(uh_t)*AnalyticalBox)*dΩ))

@assert Difference &lt; 0.1</code></pre><h2 id="References-1"><a class="docs-heading-anchor" href="#References-1">References</a><a class="docs-heading-anchor-permalink" href="#References-1" title="Permalink"></a></h2><p>[1] <a href="https://en.wikipedia.org/wiki/Electromagnetic_wave_equation">Wikipedia: Electromagnetic wave equation</a></p><p>[2] <a href="https://en.wikipedia.org/wiki/Perfectly_matched_layer">Wikipedia: Perfectly matched layer</a></p><p>[3] A. Oskooi and S. G. Johnson, “<a href="http://math.mit.edu/~stevenj/papers/OskooiJo11.pdf">Distinguishing correct from incorrect PML proposals and a corrected unsplit PML for anisotropic, dispersive media</a>,” Journal of Computational Physics, vol. 230, pp. 2369–2377, April 2011.</p><p>[4] Stratton, J. A. (1941). Electromagnetic Theory. New York: McGraw-Hill.</p><p>[5] <a href="https://en.wikipedia.org/wiki/Jacobi%E2%80%93Anger_expansion">Wikipedia: Jacobi–Anger expansion</a></p><p>[6] <a href="https://en.wikipedia.org/wiki/Bessel_function">Wikipedia: Bessel function</a></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t012_fsi_tutorial/">« 12 Fluid-Structure Interaction</a><a class="docs-footer-nextpage" href="../t014_validation_DrWatson/">14 On using DrWatson.jl »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 25 September 2025 00:53">Thursday 25 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
