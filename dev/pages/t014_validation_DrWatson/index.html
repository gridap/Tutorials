<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>14 On using DrWatson.jl · Gridap tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gridap tutorials logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap tutorials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="tocitem" href="../t002_validation/">2 Code validation</a></li><li><a class="tocitem" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="tocitem" href="../t004_p_laplacian/">4 p-Laplacian</a></li><li><a class="tocitem" href="../t005_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="tocitem" href="../t006_dg_discretization/">6 Poisson equation (with DG)</a></li><li><a class="tocitem" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="tocitem" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li><li><a class="tocitem" href="../t009_stokes/">9 Stokes equation</a></li><li><a class="tocitem" href="../t010_advection_diffusion/">10 Advection-diffusion</a></li><li><a class="tocitem" href="../t011_isotropic_damage/">11 Isotropic damage model</a></li><li><a class="tocitem" href="../t012_fsi_tutorial/">12 Fluid-Structure Interaction</a></li><li><a class="tocitem" href="../t013_emscatter/">13 Electromagnetic scattering in 2D</a></li><li class="is-active"><a class="tocitem" href>14 On using DrWatson.jl</a><ul class="internal"><li><a class="tocitem" href="#.-Activate-your-project-1"><span>1. Activate your project</span></a></li><li><a class="tocitem" href="#.-Prepare-the-simulations-1"><span>2. Prepare the simulations</span></a></li><li><a class="tocitem" href="#.-Run-and-save-1"><span>3. Run and save</span></a></li><li><a class="tocitem" href="#.-Listing-the-simulations-1"><span>4. Listing the simulations</span></a></li><li><a class="tocitem" href="#.-Generate-the-plot-1"><span>5. Generate the plot</span></a></li></ul></li><li><a class="tocitem" href="../t015_interpolation_fe/">15 Interpolation of CellFields</a></li><li><a class="tocitem" href="../t016_poisson_distributed/">16 Poisson equation on parallel distributed-memory computers</a></li><li><a class="tocitem" href="../t017_transient_linear/">17 Transient Poisson equation</a></li><li><a class="tocitem" href="../t018_transient_nonlinear/">18 Transient nonlinear equation</a></li><li><a class="tocitem" href="../t019_TopOptEMFocus/">19 Topology optimization</a></li><li><a class="tocitem" href="../t020_poisson_unfitted/">20 Poisson on unfitted meshes</a></li><li><a class="tocitem" href="../t021_poisson_amr/">21 Poisson with AMR</a></li><li><a class="tocitem" href="../t022_poisson_hdg/">22 Poisson with HDG</a></li><li><a class="tocitem" href="../t023_poisson_hho/">23 Poisson with HHO on polytopal meshes</a></li><li><a class="tocitem" href="../t024_stokes_blocks/">24 Block assembly and solvers: Incompressible Stokes example</a></li><li><a class="tocitem" href="../t025_lagrange_multipliers/">25 Lagrange multipliers</a></li><li><a class="tocitem" href="../t026_poisson_dev_fe/">26 Low-level API - Poisson equation</a></li><li><a class="tocitem" href="../t027_geometry_dev/">27 Low-level API - Geometry</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>14 On using DrWatson.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>14 On using DrWatson.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Tutorials/blob/master/src/validation_DrWatson.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="validation_DrWatson.jl-1"><a class="docs-heading-anchor" href="#validation_DrWatson.jl-1">Tutorial 14: On using DrWatson.jl</a><a class="docs-heading-anchor-permalink" href="#validation_DrWatson.jl-1" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t014_validation_DrWatson.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t014_validation_DrWatson.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will learn</p><ul><li>How to use <code>DrWatson.jl</code> to accelerate and reproduce our Gridap simulation workflows</li></ul><p><a href="https://github.com/JuliaDynamics/DrWatson.jl">DrWatson.jl</a> is a Julia package that helps managing a typical scientific workflow through all its phases, see a summary <a href="https://juliadynamics.github.io/DrWatson.jl/stable/workflow/">here</a>.</p><p>All its functionalities can be accessed with (non-invasive) simple function calls.</p><p>In order to illustrate how to benefit from <code>DrWatson.jl</code> in <code>Gridap.jl</code> simulations, we refactor here the convergence test from the <code>Code validation</code> tutorial.</p><p>Instead of implementing a helper function to carry out the convergence test, we will generate them using <code>DrWatson.jl</code> functions.</p><h2 id=".-Activate-your-project-1"><a class="docs-heading-anchor" href="#.-Activate-your-project-1">1. Activate your project</a><a class="docs-heading-anchor-permalink" href="#.-Activate-your-project-1" title="Permalink"></a></h2><p>The first step is to activate our project using <code>quickactivate</code>. This does not only activate the project, it also sets the relative paths within the project, so you can safely use the functions <code>projectdir()</code> and its derivatives <code>datadir()</code>, <code>plotsdir()</code>, <code>srcdir()</code>, etc. Beware of this <a href="https://juliadynamics.github.io/DrWatson.jl/dev/project/#DrWatson.quickactivate">warning</a>, you must activate the project before using other packages.</p><pre><code class="language-julia">using DrWatson
@quickactivate &quot;Tutorials&quot;</code></pre><p>Although this tutorial is already in a Project (and git repo), we could also start our scientific project from scratch with <code>DrWatson.jl</code>, using function <code>initialize_project</code>. This function initiates, on the working directory, (1) a git repo with a folder structure enriched for scientific workflows, e.g. folders <code>data</code>, <code>plots</code>, <code>papers</code>, etc., and (2)<code>Project.toml</code> and <code>Manifest.toml</code> files. More details <a href="https://juliadynamics.github.io/DrWatson.jl/dev/workflow/#.-Setup-the-project-1">here</a>.</p><p>Once the project is activated, we ensure that all packages we use have the versions dictated by our activated project.</p><pre><code class="language-julia">using Gridap
import Gridap: ∇</code></pre><h2 id=".-Prepare-the-simulations-1"><a class="docs-heading-anchor" href="#.-Prepare-the-simulations-1">2. Prepare the simulations</a><a class="docs-heading-anchor-permalink" href="#.-Prepare-the-simulations-1" title="Permalink"></a></h2><p>We consider the Poisson equation in the unit square <span>$\Omega\doteq (0,1)^2$</span> as a model problem,</p><div>\[\left\lbrace
\begin{aligned}
-\Delta u = f  \ \text{in} \ \Omega\\
u = g \ \text{on}\ \partial\Omega.\\
\end{aligned}
\right.\]</div><p>We are going to perform a convergence test with the manufactured solution <span>$u(x) = x_1^3 + x_2^3$</span>.</p><p>To this end, we want to solve our computational model for many combinations of mesh size and order of FE approximation (<em>parameters</em>) and extract the L2- and H1-norm errors (<em>output data</em>).</p><p>We first group all parameters and parameter values in a single dictionary</p><pre><code class="language-julia">params = Dict(
  &quot;cells_per_axis&quot; =&gt; [8,16,32,64],
  &quot;fe_order&quot; =&gt; [1,2]
)</code></pre><p>and then we use DrWatson&#39;s <code>dict_list</code> to expand all the parameters into a vector of dictionaries. Each dictionary contains the parameter-value combinations corresponding to a single simulation case.</p><pre><code class="language-julia">dicts = dict_list(params)</code></pre><p><strong>Warning!</strong> Be careful when combining parameters of different value type. You may end up with dictionaries that do not have a concrete type and experience a significant type-inference overhead when running the simulations.</p><p>We wrap next in a function a run of our computational model for a single pair <code>(cells_per_axis,fe_order)</code>. The function returns the L2- and H1-error norms.</p><p>We define the manufactured function, as usual</p><pre><code class="language-julia">p = 3
u(x) = x[1]^p+x[2]^p
∇u(x) = VectorValue(p*x[1]^(p-1),p*x[2]^(p-1))
f(x) = -p*(p-1)*(x[1]^(p-2)+x[2]^(p-2))
∇(::typeof(u)) = ∇u</code></pre><p>And the function that runs a single case of our parametric space reads</p><pre><code class="language-julia">function run(n::Int,k::Int)

  domain = (0,1,0,1)
  partition = (n,n)
  model = CartesianDiscreteModel(domain,partition)

  reffe = ReferenceFE(lagrangian,Float64,k)
  V0 = TestFESpace(model,reffe,conformity=:H1,dirichlet_tags=&quot;boundary&quot;)
  U = TrialFESpace(V0,u)

  degree = 2*p
  Ω = Triangulation(model)
  dΩ = Measure(Ω,degree)

  a(u,v) = ∫( ∇(u)⊙∇(v) ) * dΩ
  b(v) = ∫( v*f ) * dΩ

  op = AffineFEOperator(a,b,U,V0)

  uh = solve(op)

  e = u - uh

  el2 = sqrt(sum( ∫( e*e )*dΩ ))
  eh1 = sqrt(sum( ∫( e*e + ∇(e)⋅∇(e) )*dΩ ))

  (el2, eh1)

end</code></pre><p>In order to communicate with <code>DrWatson.jl</code> helper functions, we need to add an extra layer on top of <code>run</code>, such that the input and output are dictionaries.</p><p>Note the use of functions <a href="https://juliadynamics.github.io/DrWatson.jl/dev/name/#UnPack.@unpack">@unpack</a> and <a href="https://juliadynamics.github.io/DrWatson.jl/dev/name/#DrWatson.@dict">@dict</a> to decompose and compose the dictionaries. You can check in <code>DrWatson.jl</code>&#39;s documentation further functions to manipulate dictionaries.</p><pre><code class="language-julia">function run(case::Dict)
  @unpack cells_per_axis, fe_order = case
  el2, eh1 = run(cells_per_axis,fe_order)
  h = 1.0/cells_per_axis
  results = @strdict el2 eh1 h
  merge(case,results)
end</code></pre><h2 id=".-Run-and-save-1"><a class="docs-heading-anchor" href="#.-Run-and-save-1">3. Run and save</a><a class="docs-heading-anchor-permalink" href="#.-Run-and-save-1" title="Permalink"></a></h2><p>While running the simulations, we need to save the results. <code>DrWatson.jl</code> frees you from the burden of generating the filenames for each case. For this purpose, it provides the functions <a href="https://juliadynamics.github.io/DrWatson.jl/stable/name/#DrWatson.savename">savename</a>, <a href="https://juliadynamics.github.io/DrWatson.jl/stable/save/#DrWatson.@tagsave">@tagsave</a> or <a href="https://juliadynamics.github.io/DrWatson.jl/stable/save/#DrWatson.produce_or_load">produce<em>or</em>load</a>, among others.</p><p>Among them, we recommend using <a href="https://juliadynamics.github.io/DrWatson.jl/stable/save/#DrWatson.produce_or_load">produce<em>or</em>load</a>. The special feature of this function is that it checks whether the file containing the output data of the case already exists. If that happens, then the function loads the file, instead of running the case. In this way, we avoid repeating simulations that have already been run.</p><p>Thus, in order to run all simulation cases, it suffices to map all cases in <code>dicts</code> to the <code>produce_or_load</code> function:</p><pre><code class="language-julia">function run_or_load(case::Dict)
  produce_or_load(
    projectdir(&quot;notebooks&quot;,&quot;output_path&quot;),
    case,
    run,
    prefix=&quot;res&quot;,
    tag=true,
    verbose=true
  )
  return true
end

map(run_or_load,dicts)</code></pre><p>Note that the results of each case are stored in a binary database file in the <code>projectdir(&quot;notebooks&quot;,&quot;output_path&quot;)</code> folder. Each result file stores the output dictionary that returns from <code>run(case)</code>.</p><p>We also observe that we set <code>tag=true</code> in <code>produce_or_load</code>. This option is <em>key to preserve reproducibility</em>. It adds to the output dictionary the field <code>:gitcommit</code>, thus allowing us to trace the status of the code, at which we obtained those results. Furthermore, if the git repo is dirty, one more field <code>:gitpatch</code> is added, storing the difference string.</p><p>In some situations, you will prefer to repeat all simulations and track their evolution as you change the code. To this end, check out <a href="https://juliadynamics.github.io/DrWatson.jl/dev/save/#DrWatson.safesave">safesave</a>.</p><h2 id=".-Listing-the-simulations-1"><a class="docs-heading-anchor" href="#.-Listing-the-simulations-1">4. Listing the simulations</a><a class="docs-heading-anchor-permalink" href="#.-Listing-the-simulations-1" title="Permalink"></a></h2><p>Results stored by <code>DrWatson.jl</code> in databases are handled with the <a href="https://dataframes.juliadata.org/stable/">DataFrames.jl</a> package, a powerful Julia package to manipulate tabular data.</p><pre><code class="language-julia">using DataFrames</code></pre><p>To collect all simulation results, it suffices to use the <code>collect_results!</code> function from <code>DrWatson.jl</code> from the folder where the results are stored.</p><pre><code class="language-julia">df = collect_results(projectdir(&quot;notebooks&quot;,&quot;output_path&quot;))</code></pre><p>We order next the database by (ascending) mesh size and we extract the arrays of mesh sizes and errors</p><pre><code class="language-julia">sort!(df,:h)
hs = df[(df.fe_order .== 1),:h]
el2s1 = df[(df.fe_order .== 1),:el2]
eh1s1 = df[(df.fe_order .== 1),:eh1]
el2s2 = df[(df.fe_order .== 2),:el2]
eh1s2 = df[(df.fe_order .== 2),:eh1]</code></pre><h2 id=".-Generate-the-plot-1"><a class="docs-heading-anchor" href="#.-Generate-the-plot-1">5. Generate the plot</a><a class="docs-heading-anchor-permalink" href="#.-Generate-the-plot-1" title="Permalink"></a></h2><p>With the generated data, we do the classical convergence plot and interpret it in the same way as in the validation tutorial.</p><pre><code class="language-julia">using Plots

plot(hs,[el2s1 eh1s1 el2s2 eh1s2],
    xaxis=:log, yaxis=:log,
    label=[&quot;L2 k=1&quot; &quot;H1 k=1&quot; &quot;L2 k=2&quot; &quot;H1 k=2&quot;],
    shape=:auto,
    xlabel=&quot;h&quot;,ylabel=&quot;error norm&quot;)</code></pre><p>If you run the code in a notebook, you will see a figure like this one: <img src="../../assets/validation_DrWatson/conv.png" alt/></p><p>Congrats, another tutorial done!</p><hr/><p>If you use DrWatson.jl in a scientific project that leads to a publication, please do not forget to cite the paper associated with it:</p><pre><code class="language-none">@article{Datseris2020,
 doi = {10.21105/joss.02673},
 url = {https://doi.org/10.21105/joss.02673},
 year = {2020},
 publisher = {The Open Journal},
 volume = {5},
 number = {54},
 pages = {2673},
 author = {George Datseris and Jonas Isensee and Sebastian Pech and Tamás Gál},
 title = {DrWatson: the perfect sidekick for your scientific inquiries},
 journal = {Journal of Open Source Software}
}</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t013_emscatter/">« 13 Electromagnetic scattering in 2D</a><a class="docs-footer-nextpage" href="../t015_interpolation_fe/">15 Interpolation of CellFields »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 25 September 2025 00:53">Thursday 25 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
