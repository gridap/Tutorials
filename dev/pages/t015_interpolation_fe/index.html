<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>15 Interpolation of CellFields ¬∑ Gridap tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gridap tutorials logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap tutorials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="tocitem" href="../t002_validation/">2 Code validation</a></li><li><a class="tocitem" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="tocitem" href="../t004_p_laplacian/">4 p-Laplacian</a></li><li><a class="tocitem" href="../t005_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="tocitem" href="../t006_dg_discretization/">6 Poisson equation (with DG)</a></li><li><a class="tocitem" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="tocitem" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li><li><a class="tocitem" href="../t009_stokes/">9 Stokes equation</a></li><li><a class="tocitem" href="../t010_advection_diffusion/">10 Advection-diffusion</a></li><li><a class="tocitem" href="../t011_isotropic_damage/">11 Isotropic damage model</a></li><li><a class="tocitem" href="../t012_fsi_tutorial/">12 Fluid-Structure Interaction</a></li><li><a class="tocitem" href="../t013_emscatter/">13 Electromagnetic scattering in 2D</a></li><li><a class="tocitem" href="../t014_validation_DrWatson/">14 On using DrWatson.jl</a></li><li class="is-active"><a class="tocitem" href>15 Interpolation of CellFields</a><ul class="internal"><li><a class="tocitem" href="#Problem-Statement-1"><span>Problem Statement</span></a></li><li><a class="tocitem" href="#Setup-1"><span>Setup</span></a></li><li><a class="tocitem" href="#Background-1"><span>Background</span></a></li><li><a class="tocitem" href="#Interpolating-between-Lagrangian-FE-Spaces-1"><span>Interpolating between Lagrangian FE Spaces</span></a></li><li><a class="tocitem" href="#Interpolating-between-Raviart-Thomas-FESpaces-1"><span>Interpolating between Raviart-Thomas FESpaces</span></a></li><li><a class="tocitem" href="#Interpolating-vector-valued-functions-1"><span>Interpolating vector-valued functions</span></a></li><li><a class="tocitem" href="#Interpolating-Multi-field-Functions-1"><span>Interpolating Multi-field Functions</span></a></li><li><a class="tocitem" href="#Acknowledgements-1"><span>Acknowledgements</span></a></li></ul></li><li><a class="tocitem" href="../t016_poisson_distributed/">16 Poisson equation on parallel distributed-memory computers</a></li><li><a class="tocitem" href="../t017_transient_linear/">17 Transient Poisson equation</a></li><li><a class="tocitem" href="../t018_transient_nonlinear/">18 Transient nonlinear equation</a></li><li><a class="tocitem" href="../t019_TopOptEMFocus/">19 Topology optimization</a></li><li><a class="tocitem" href="../t020_poisson_unfitted/">20 Poisson on unfitted meshes</a></li><li><a class="tocitem" href="../t021_poisson_amr/">21 Poisson with AMR</a></li><li><a class="tocitem" href="../t022_poisson_hdg/">22 Poisson with HDG</a></li><li><a class="tocitem" href="../t023_poisson_hho/">23 Poisson with HHO on polytopal meshes</a></li><li><a class="tocitem" href="../t024_stokes_blocks/">24 Block assembly and solvers: Incompressible Stokes example</a></li><li><a class="tocitem" href="../t025_lagrange_multipliers/">25 Lagrange multipliers</a></li><li><a class="tocitem" href="../t026_poisson_dev_fe/">26 Low-level API - Poisson equation</a></li><li><a class="tocitem" href="../t027_geometry_dev/">27 Low-level API - Geometry</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>15 Interpolation of CellFields</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>15 Interpolation of CellFields</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Tutorials/blob/master/src/interpolation_fe.jl" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="interpolation_fe.jl-1"><a class="docs-heading-anchor" href="#interpolation_fe.jl-1">Tutorial 15: Interpolation of CellFields</a><a class="docs-heading-anchor-permalink" href="#interpolation_fe.jl-1" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t015_interpolation_fe.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t015_interpolation_fe.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will look at how to</p><ul><li>Evaluate <code>CellFields</code> at arbitrary points</li><li>Interpolate finite element functions defined on different</li></ul><p>triangulations. We will consider examples for</p><ul><li>Lagrangian finite element spaces</li><li>Raviart Thomas finite element spaces</li><li>Vector-Valued Spaces</li><li>Multifield finite element spaces</li></ul><h2 id="Problem-Statement-1"><a class="docs-heading-anchor" href="#Problem-Statement-1">Problem Statement</a><a class="docs-heading-anchor-permalink" href="#Problem-Statement-1" title="Permalink"></a></h2><p>Let <span>$\mathcal{T}_1$</span> and <span>$\mathcal{T}_2$</span> be two triangulations of a domain <span>$\Omega$</span>. Let <span>$V_i$</span> be the finite element space defined on the triangulation <span>$\mathcal{T}_i$</span> for <span>$i=1,2$</span>. Let <span>$f_h \in V_1$</span>. The interpolation problem is to find <span>$g_h \in V_2$</span> such that</p><div>\[dof_k^{V_2}(g_h) = dof_k^{V_2}(f_h),\quad \forall k \in
\{1,\dots,N_{dof}^{V_2}\}\]</div><h2 id="Setup-1"><a class="docs-heading-anchor" href="#Setup-1">Setup</a><a class="docs-heading-anchor-permalink" href="#Setup-1" title="Permalink"></a></h2><p>For the purpose of this tutorial we require <code>Test</code>, <code>Gridap</code> along with the following submodules of <code>Gridap</code></p><pre><code class="language-julia">using Test
using Gridap
using Gridap.CellData
using Gridap.Visualization</code></pre><p>We now create a computational domain on the unit square <span>$[0,1]^2$</span> consisting of 5 cells per direction</p><pre><code class="language-julia">domain = (0,1,0,1)
partition = (5,5)
ùíØ‚ÇÅ = CartesianDiscreteModel(domain, partition)</code></pre><h2 id="Background-1"><a class="docs-heading-anchor" href="#Background-1">Background</a><a class="docs-heading-anchor-permalink" href="#Background-1" title="Permalink"></a></h2><p><code>Gridap</code> offers the feature to evaluate functions at arbitrary points in the domain. This will be shown in the next section. Interpolation then takes advantage of this feature to obtain the <code>FEFunction</code> in the new space from the old one by evaluating the appropriate degrees of freedom. Interpolation works using the composite type <code>Interpolable</code> to tell <code>Gridap</code> that the argument can be interpolated between triangulations.</p><h2 id="Interpolating-between-Lagrangian-FE-Spaces-1"><a class="docs-heading-anchor" href="#Interpolating-between-Lagrangian-FE-Spaces-1">Interpolating between Lagrangian FE Spaces</a><a class="docs-heading-anchor-permalink" href="#Interpolating-between-Lagrangian-FE-Spaces-1" title="Permalink"></a></h2><p>Let us define the infinite dimensional function</p><pre><code class="language-julia">f(x) = x[1] + x[2]</code></pre><p>This function will be interpolated to the source <code>FESpace</code> <span>$V_1$</span>. The space can be built using</p><pre><code class="language-julia">reffe‚ÇÅ = ReferenceFE(lagrangian, Float64, 1)
V‚ÇÅ = FESpace(ùíØ‚ÇÅ, reffe‚ÇÅ)</code></pre><p>Finally to build the function <span>$f_h$</span>, we do</p><pre><code class="language-julia">f‚Çï = interpolate_everywhere(f,V‚ÇÅ)</code></pre><p>To construct arbitrary points in the domain, we use <code>Random</code> package:</p><pre><code class="language-julia">using Random
pt = Point(rand(2))
pts = [Point(rand(2)) for i in 1:3]</code></pre><p>The finite element function <span>$f_h$</span> can be evaluated at arbitrary points (or array of points) by</p><pre><code class="language-julia">f‚Çï(pt), f‚Çï.(pts)</code></pre><p>We can also check our results using</p><pre><code class="language-julia">@test f‚Çï(pt) ‚âà f(pt)
@test f‚Çï.(pts) ‚âà f.(pts)</code></pre><p>Now let us define the new triangulation <span>$\mathcal{T}_2$</span> of <span>$\Omega$</span>. We build the new triangulation using a partition of 20 cells per direction. The map can be passed as an argument to <code>CartesianDiscreteModel</code> to define the position of the vertices in the new mesh.</p><pre><code class="language-julia">partition = (20,20)
ùíØ‚ÇÇ = CartesianDiscreteModel(domain,partition)</code></pre><p>As before, we define the new <code>FESpace</code> consisting of second order elements</p><pre><code class="language-julia">reffe‚ÇÇ = ReferenceFE(lagrangian, Float64, 2)
V‚ÇÇ = FESpace(ùíØ‚ÇÇ, reffe‚ÇÇ)</code></pre><p>Now we interpolate <span>$f_h$</span> onto <span>$V_2$</span> to obtain the new function <span>$g_h$</span>. The first step is to create the <code>Interpolable</code> version of <span>$f_h$</span>.</p><pre><code class="language-julia">if‚Çï = Interpolable(f‚Çï)</code></pre><p>Then to obtain <span>$g_h$</span>, we dispatch <code>if‚Çï</code> and the new <code>FESpace</code> <span>$V_2$</span> to the <code>interpolate_everywhere</code> method of <code>Gridap</code>.</p><pre><code class="language-julia">g‚Çï = interpolate_everywhere(if‚Çï, V‚ÇÇ)</code></pre><p>We can also use <code>interpolate</code> if interpolating only on the free dofs or <code>interpolate_dirichlet</code> if interpolating the Dirichlet dofs of the <code>FESpace</code>.</p><pre><code class="language-julia">gÃÑ‚Çï = interpolate(if‚Çï, V‚ÇÇ)</code></pre><p>The finite element function <span>$\bar{g}_h$</span> is the same as <span>$g_h$</span> in this example since all the dofs are free.</p><pre><code class="language-julia">@test g‚Çï.cell_dof_values ==  gÃÑ‚Çï.cell_dof_values</code></pre><p>Now we obtain a finite element function using <code>interpolate_dirichlet</code></p><pre><code class="language-julia">gÃÉ‚Çï = interpolate_dirichlet(if‚Çï, V‚ÇÇ)</code></pre><p>Now <span>$\tilde{g}_h$</span> will be equal to 0 since there are no Dirichlet nodes defined in the <code>FESpace</code>. We can check by running</p><pre><code class="language-julia">gÃÉ‚Çï.cell_dof_values</code></pre><p>Like earlier we can check our results for <code>g‚Çï</code>:</p><pre><code class="language-julia">@test f‚Çï(pt) ‚âà g‚Çï(pt) ‚âà f(pt)
@test f‚Çï.(pts) ‚âà g‚Çï.(pts) ‚âà f.(pts)</code></pre><p>We can visualize the results using Paraview</p><pre><code class="language-julia">writevtk(get_triangulation(f‚Çï), &quot;source&quot;, cellfields=[&quot;f‚Çï&quot;=&gt;f‚Çï])
writevtk(get_triangulation(g‚Çï), &quot;target&quot;, cellfields=[&quot;g‚Çï&quot;=&gt;g‚Çï])</code></pre><p>which produces the following output</p><p><img src="../../assets/interpolation_fe/source_and_target.png" alt="Target"/></p><h2 id="Interpolating-between-Raviart-Thomas-FESpaces-1"><a class="docs-heading-anchor" href="#Interpolating-between-Raviart-Thomas-FESpaces-1">Interpolating between Raviart-Thomas FESpaces</a><a class="docs-heading-anchor-permalink" href="#Interpolating-between-Raviart-Thomas-FESpaces-1" title="Permalink"></a></h2><p>The procedure is identical to Lagrangian finite element spaces, as discussed in the previous section. The extra thing here is that functions in Raviart-Thomas spaces are vector-valued. The degrees of freedom of the RT spaces are fluxes of the function across the edge of the element. Refer to the <a href="../t007_darcy/#darcy.jl-1">tutorial</a> on Darcy equation with RT for more information on the RT elements.</p><p>Assuming a function</p><pre><code class="language-julia">f(x) = VectorValue([x[1], x[2]])</code></pre><p>on the domain, we build the associated finite dimensional version <span>$f_h \in V_1$</span>.</p><pre><code class="language-julia">reffe‚ÇÅ = ReferenceFE(raviart_thomas, Float64, 1) # RT space of order 1
V‚ÇÅ = FESpace(ùíØ‚ÇÅ, reffe‚ÇÅ)
f‚Çï = interpolate_everywhere(f, V‚ÇÅ)</code></pre><p>As before, we can evaluate the RT function on any arbitrary point in the domain.</p><pre><code class="language-julia">f‚Çï(pt), f‚Çï.(pts)</code></pre><p>Constructing the target RT space and building the <code>Interpolable</code> object,</p><pre><code class="language-julia">reffe‚ÇÇ = ReferenceFE(raviart_thomas, Float64, 1) # RT space of order 1
V‚ÇÇ = FESpace(ùíØ‚ÇÇ, reffe‚ÇÇ)
if‚Çï = Interpolable(f‚Çï)</code></pre><p>we can construct the new <code>FEFunction</code> <span>$g_h \in V_2$</span> from <span>$f_h$</span></p><pre><code class="language-julia">g‚Çï = interpolate_everywhere(if‚Çï, V‚ÇÇ)</code></pre><p>Like earlier we can check our results</p><pre><code class="language-julia">@test g‚Çï(pt) ‚âà f(pt) ‚âà f‚Çï(pt)</code></pre><h2 id="Interpolating-vector-valued-functions-1"><a class="docs-heading-anchor" href="#Interpolating-vector-valued-functions-1">Interpolating vector-valued functions</a><a class="docs-heading-anchor-permalink" href="#Interpolating-vector-valued-functions-1" title="Permalink"></a></h2><p>We can also interpolate vector-valued functions across triangulations. First, we define a vector-valued function on a two-dimensional mesh.</p><pre><code class="language-julia">f(x) = VectorValue([x[1], x[1]+x[2]])</code></pre><p>We then create a vector-valued reference element containing linear elements along with the source finite element space <span>$V_1$</span>.</p><pre><code class="language-julia">reffe‚ÇÅ = ReferenceFE(lagrangian, VectorValue{2,Float64}, 1)
V‚ÇÅ = FESpace(ùíØ‚ÇÅ, reffe‚ÇÅ)
f‚Çï = interpolate_everywhere(f, V‚ÇÅ)</code></pre><p>The target finite element space <span>$V_2$</span> can be defined in a similar manner.</p><pre><code class="language-julia">reffe‚ÇÇ = ReferenceFE(lagrangian, VectorValue{2,Float64}, 2)
V‚ÇÇ = FESpace(ùíØ‚ÇÇ, reffe‚ÇÇ)</code></pre><p>The rest of the process is similar to the previous sections, i.e., define the <code>Interpolable</code> version of <span>$f_h$</span> and use <code>interpolate_everywhere</code> to find <span>$g_h \in V‚ÇÇ$</span>.</p><pre><code class="language-julia">if‚Çï = Interpolable(f‚Çï)
g‚Çï = interpolate_everywhere(if‚Çï, V‚ÇÇ)</code></pre><p>We can then check the results</p><pre><code class="language-julia">@test g‚Çï(pt) ‚âà f(pt) ‚âà f‚Çï(pt)</code></pre><h2 id="Interpolating-Multi-field-Functions-1"><a class="docs-heading-anchor" href="#Interpolating-Multi-field-Functions-1">Interpolating Multi-field Functions</a><a class="docs-heading-anchor-permalink" href="#Interpolating-Multi-field-Functions-1" title="Permalink"></a></h2><p>Similarly, it is possible to interpolate between multi-field finite element functions. First, we define the components <span>$h_1(x), h_2(x)$</span> of a multi-field function <span>$h(x)$</span> as follows.</p><pre><code class="language-julia">h‚ÇÅ(x) = x[1]+x[2]
h‚ÇÇ(x) = x[1]</code></pre><p>Next we create a Lagrangian finite element space containing linear elements.</p><pre><code class="language-julia">reffe‚ÇÅ = ReferenceFE(lagrangian, Float64, 1)
V‚ÇÅ = FESpace(ùíØ‚ÇÅ, reffe‚ÇÅ)</code></pre><p>Next we create a <code>MultiFieldFESpace</code> <span>$V_1 \times V_1$</span> and interpolate the function <span>$h(x)$</span> to the source space <span>$V_1$</span>.</p><pre><code class="language-julia">V‚ÇÅxV‚ÇÅ = MultiFieldFESpace([V‚ÇÅ,V‚ÇÅ])
f‚Çï = interpolate_everywhere([h‚ÇÅ, h‚ÇÇ], V‚ÇÅxV‚ÇÅ)</code></pre><p>Similarly, the target multi-field finite element space is created using <span>$\Omega_2$</span>.</p><pre><code class="language-julia">reffe‚ÇÇ = ReferenceFE(lagrangian, Float64, 2)
V‚ÇÇ = FESpace(ùíØ‚ÇÇ, reffe‚ÇÇ)
V‚ÇÇxV‚ÇÇ = MultiFieldFESpace([V‚ÇÇ,V‚ÇÇ])</code></pre><p>Now, to find <span>$g_h \in V_2 \times V_2$</span>, we first extract the components of <span>$f_h$</span> and obtain the <code>Interpolable</code> version of the components.</p><pre><code class="language-julia">f‚Çï¬π, f‚Çï¬≤ = f‚Çï
if‚Çï¬π = Interpolable(f‚Çï¬π)
if‚Çï¬≤ = Interpolable(f‚Çï¬≤)</code></pre><p>We can then use <code>interpolate_everywhere</code> on the <code>Interpolable</code> version of the components and obtain <span>$g_h \in V_2 \times V_2$</span> as follows.</p><pre><code class="language-julia">g‚Çï = interpolate_everywhere([if‚Çï¬π,if‚Çï¬≤], V‚ÇÇxV‚ÇÇ)</code></pre><p>We can then check the results of the interpolation, component-wise.</p><pre><code class="language-julia">g‚Çï¬π, g‚Çï¬≤ = g‚Çï
@test f‚Çï¬π(pt) ‚âà g‚Çï¬π(pt)
@test f‚Çï¬≤(pt) ‚âà g‚Çï¬≤(pt)</code></pre><h2 id="Acknowledgements-1"><a class="docs-heading-anchor" href="#Acknowledgements-1">Acknowledgements</a><a class="docs-heading-anchor-permalink" href="#Acknowledgements-1" title="Permalink"></a></h2><p>Gridap contributors acknowledge support received from Google, Inc. through the Google Summer of Code 2021 project <a href="https://summerofcode.withgoogle.com/projects/#6175012823760896">A fast finite element interpolator in Gridap.jl</a>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t014_validation_DrWatson/">¬´ 14 On using DrWatson.jl</a><a class="docs-footer-nextpage" href="../t016_poisson_distributed/">16 Poisson equation on parallel distributed-memory computers ¬ª</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 18 June 2025 23:39">Wednesday 18 June 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
