<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>18 Transient nonlinear equation · Gridap tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gridap tutorials logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap tutorials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="tocitem" href="../t002_validation/">2 Code validation</a></li><li><a class="tocitem" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="tocitem" href="../t004_p_laplacian/">4 p-Laplacian</a></li><li><a class="tocitem" href="../t005_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="tocitem" href="../t006_dg_discretization/">6 Poisson equation (with DG)</a></li><li><a class="tocitem" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="tocitem" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li><li><a class="tocitem" href="../t009_stokes/">9 Stokes equation</a></li><li><a class="tocitem" href="../t010_isotropic_damage/">10 Isotropic damage model</a></li><li><a class="tocitem" href="../t011_fsi_tutorial/">11 Fluid-Structure Interaction</a></li><li><a class="tocitem" href="../t012_emscatter/">12 Electromagnetic scattering in 2D</a></li><li><a class="tocitem" href="../t013_poisson_dev_fe/">13 Low-level API Poisson equation</a></li><li><a class="tocitem" href="../t014_validation_DrWatson/">14 On using DrWatson.jl</a></li><li><a class="tocitem" href="../t015_interpolation_fe/">15 Interpolation of CellFields</a></li><li><a class="tocitem" href="../t016_poisson_distributed/">16 Poisson equation on parallel distributed-memory computers</a></li><li><a class="tocitem" href="../t017_transient_linear/">17 Transient Poisson equation</a></li><li class="is-active"><a class="tocitem" href>18 Transient nonlinear equation</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement-1"><span>Problem statement</span></a></li><li><a class="tocitem" href="#Discrete-model,-FE-spaces,-triangulation-and-quadrature-1"><span>Discrete model, FE spaces, triangulation and quadrature</span></a></li><li><a class="tocitem" href="#Nonlinear-weak-form-1"><span>Nonlinear weak form</span></a></li><li><a class="tocitem" href="#Transient-solver-1"><span>Transient solver</span></a></li><li><a class="tocitem" href="#Postprocessing-1"><span>Postprocessing</span></a></li></ul></li><li><a class="tocitem" href="../t019_TopOptEMFocus/">19 Topology optimization</a></li><li><a class="tocitem" href="../t020_unfitted_poisson/">20 Unfitted Poisson</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>18 Transient nonlinear equation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>18 Transient nonlinear equation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Tutorials/blob/master/src/transient_nonlinear.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="transient_nonlinear.jl-1"><a class="docs-heading-anchor" href="#transient_nonlinear.jl-1">Tutorial 18: Transient nonlinear equation</a><a class="docs-heading-anchor-permalink" href="#transient_nonlinear.jl-1" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t018_transient_nonlinear.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t018_transient_nonlinear.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will learn</p><ul><li>How to write a nonlinear transient weak form in Gridap</li><li>How to setup a time-marching scheme for a nonlinear ODE</li></ul><p>We assume that the reader is familiar with Gridap&#39;s API for linear transient PDEs, introduced in <a href="../t017_transient_linear/#transient_linear.jl-1">Tutorial 17</a>. We focus here on more advanced features of the ODE module of Gridap, applied to a nonlinear time-dependent PDE.</p><h2 id="Problem-statement-1"><a class="docs-heading-anchor" href="#Problem-statement-1">Problem statement</a><a class="docs-heading-anchor-permalink" href="#Problem-statement-1" title="Permalink"></a></h2><p>We consider the same problem as in <a href="../t017_transient_linear/#transient_linear.jl-1">Tutorial 17</a>, and use the same notations: find <span>$u(t): \Omega \to \mathbb{R}$</span> such that</p><div>\[\left\lbrace
\begin{aligned}
\rho(t, x) c(t, x) \partial_{t} u(t, x) - \nabla \cdot (k(t, x) \nabla u(t, x)) &amp;= q(t, x) &amp; \text{ in } \Omega, \\
u(t, x) &amp;= g(t, x) &amp; \text{ on } \partial \Omega, \\
u(t_{0}, x) &amp;= u_{0}(x) &amp; \text{ in } \Omega \\
\end{aligned}
\right.\]</div><p>In this tutorial we consider a nonlinear (quadratic) conductivity coefficient <span>$\alpha(t, x, u) = \alpha_{0}(t, x) + \alpha_{1}(t, x) u(t, x) + \alpha_{2}(t, x) u(t, x)^{2}$</span>. Here again, we assume that the <span>$\alpha_{i}$</span> are continuous in time. The weak form of the problem reads: find <span>$u(t) \in U_{g}(t)$</span> such that <span>$b(t, u, v) = \ell(t, v)$</span> for all <span>$t \geq t_{0}$</span> and <span>$v \in V_{0}$</span>, where the time-dependent bilinear and linear forms <span>$b(t, \cdot, \cdot)$</span> and <span>$\ell(t, \cdot)$</span> are defined as</p><div>\[\begin{aligned}
b(t, u, v) &amp;= m(t, u, v) + a(t, u, v), \\
m(t, u, v) &amp;= \int_{\Omega} v \partial_{t} u(t) \ {\rm d} \Omega, \\
a(t, u, v) &amp;= \int_{\Omega} \nabla v \cdot [(\alpha_{0}(t) + \alpha_{1}(t) u(t) + \alpha_{2}(t) u(t)^{2}) \nabla u(t)] \ {\rm d} \Omega, \\
\ell(t, v) &amp;= \int_{\Omega} v f(t) \ {\rm d} \Omega,
\end{aligned}\]</div><p>and the the functional spaces are <span>$U_{g}(t) = \{u \in H^{1}_{g(t)}(\Omega), u \nabla u \in \boldsymbol{L}^{2}(\Omega), u^{2} \nabla u \in \boldsymbol{L}^{2}(\Omega)\}$</span> and <span>$V_{0} = H^{1}_{0}(\Omega)$</span>. In addition to the regularity conditions of Tutorial 17 on <span>$f$</span>, <span>$g$</span> and <span>$u_{0}$</span>, we assume that for all <span>$t \geq t_{0}$</span>, it holds <span>$\alpha_{i}(t) \in L^{\infty}(\Omega)$</span> and <span>$(x, X) \mapsto \alpha_{0}(t, x) + \alpha_{1}(t, x) X + \alpha_{2}(t, x) X^{2}$</span> is uniformly positive in <span>$\Omega \times \mathbb{R}$</span>, i.e. <span>$\alpha_{2}(t)$</span> and <span>$4 \alpha_{0}(t) \alpha_{2}(t) - \alpha_{1}^{2}(t)$</span> are uniformly positive.</p><h2 id="Discrete-model,-FE-spaces,-triangulation-and-quadrature-1"><a class="docs-heading-anchor" href="#Discrete-model,-FE-spaces,-triangulation-and-quadrature-1">Discrete model, FE spaces, triangulation and quadrature</a><a class="docs-heading-anchor-permalink" href="#Discrete-model,-FE-spaces,-triangulation-and-quadrature-1" title="Permalink"></a></h2><p>We consider the same mesh, FE spaces, triangulation and quadrature as in Tutorial 17:</p><pre><code class="language-julia">using Gridap
domain = (-1, +1, -1, +1)
partition = (20, 20)
model = CartesianDiscreteModel(domain, partition)

order = 1
reffe = ReferenceFE(lagrangian, Float64, order)

V0 = TestFESpace(model, reffe, dirichlet_tags=&quot;boundary&quot;)

g(t) = x -&gt; exp(-2 * t) * sinpi(t * x[1]) * (x[2]^2 - 1)
Ug = TransientTrialFESpace(V0, g)

degree = 2
Ω = Triangulation(model)
dΩ = Measure(Ω, degree)</code></pre><h2 id="Nonlinear-weak-form-1"><a class="docs-heading-anchor" href="#Nonlinear-weak-form-1">Nonlinear weak form</a><a class="docs-heading-anchor-permalink" href="#Nonlinear-weak-form-1" title="Permalink"></a></h2><p>We define the diffusion coefficients <span>$\alpha$</span> and <span>$\beta$</span>, the total nonlinear diffusion coefficient <span>$\kappa$</span> as well as the forcing term <span>$f$</span>.</p><pre><code class="language-julia">α₀(t) = x -&gt; 1 + sin(t) * (x[1]^2 + x[2]^2) / 4
α₁(t) = x -&gt; cos(t) * x[1]^2 / 2
α₂(t) = x -&gt; 1 + t * (x[1]^2 + x[2]^2)
α(t, u) = α₀(t) + α₁(t) * u + α₂(t) * u * u
f(t) = x -&gt; sin(t) * sinpi(x[1]) * sinpi(x[2])</code></pre><p>We now write the nonlinear weak form. Similar to steady nonlinear problems, we provide the residual and its Jacobian, here with respect to <span>$u$</span> and <span>$\partial_{t} u$</span>. The mass, stiffness and forcing terms are written as follows.</p><pre><code class="language-julia">m(t, u, v) = ∫(v * ∂t(u))dΩ
a(t, u, v) = ∫(∇(v) ⋅ (α(t, u) * ∇(u)))dΩ
l(t, v) = ∫(v * f(t))dΩ</code></pre><p>The Jacobians of the mass and the stiffness are</p><pre><code class="language-julia">jac_m(t, u, dtu, v) = ∫(v * dtu)dΩ
jac_α(t, u, du) = α₁(t) * du + α₂(t) * (2 * u * du)
jac_a(t, u, du, v) = ∫(∇(v) ⋅ (α(t, u) * ∇(du)))dΩ + ∫(∇(v) ⋅ (jac_α(t, u, du) * ∇(u)))dΩ</code></pre><p>We can now write the residual and its Jacobians with respect to <span>$u$</span> and <span>$\partial_{t} u$</span> as follows</p><pre><code class="language-julia">res(t, u, v) = m(t, u, v) + a(t, u, v) - l(t, v)
jac(t, u, du, v) = jac_a(t, u, du, v)
jac_t(t, u, dtu, v) = jac_m(t, u, dtu, v)</code></pre><p>The most general way of constructing a transient FE operator is by using the <code>TransientFEOperator</code> constructor, which receives a residual, a Jacobian with respect to the unknown and a Jacobian with respect to the time derivative.</p><pre><code class="language-julia">op = TransientFEOperator(res, (jac, jac_t), Ug, V0)</code></pre><p>In this example, the mass term is linear so this ODE belongs to the class of quasilinear ODEs. We can indicate this additional structure to Gridap as follows</p><pre><code class="language-julia">mass_ql(t, u, dtu, v) = ∫(dtu * v)dΩ
res_ql(t, u, v) = a(t, u, v) - l(t, v)
jac_ql(t, u, du, v) = jac_a(t, u, du, v)
jac_t_ql(t, u, dtu, v) = jac_m(t, u, dtu, v)
op_ql = TransientQuasilinearFEOperator(mass_ql, res_ql, (jac_ql, jac_t_ql), Ug, V0)</code></pre><p>In fact, this ODE further classifies as semilinear because its mass term does not involve <span>$u$</span>. In our case, the mass term is also constant in time, so the optimal operator is as follows. Note that the signature of the mass term does not involve <code>u</code> anymore, as this is the condition for an ODE to be semilinear.</p><pre><code class="language-julia">mass_sl(t, dtu, v) = ∫(dtu * v)dΩ
res_sl(t, u, v) = a(t, u, v) - l(t, v)
jac_sl(t, u, du, v) = jac_a(t, u, du, v)
jac_t_sl(t, u, dtu, v) = mass_sl(t, dtu, v)
op_sl = TransientSemilinearFEOperator(
  mass_sl, res_sl, (jac_sl, jac_t_sl),
  Ug, V0, constant_mass=true
)</code></pre><p>In all cases above, it is also possible to take advantage of automatic differentiation techniques to compute both Jacobians and build the transient FE operator from the residual and the FE spaces only.</p><h2 id="Transient-solver-1"><a class="docs-heading-anchor" href="#Transient-solver-1">Transient solver</a><a class="docs-heading-anchor-permalink" href="#Transient-solver-1" title="Permalink"></a></h2><p>We proceed to the definition of the ODE solver. If the ODE is described via a general nonlinear FE operator, we will need to provide these schemes with a nonlinear solver for systems of equations. If the operator is quasilinear and the scheme is explicit, one only needs a linear solver. Here we draw from <code>NLSolvers.jl</code> and rely on a Newton-Raphson solver based on Gridap&#39;s <code>LUSolver</code>.</p><p>For example, for the <code>ThetaMethod</code>, one would write</p><pre><code class="language-julia">lin_solver = LUSolver()
nl_solver = NLSolver(lin_solver, method=:newton, iterations=10, show_trace=false)

Δt = 0.05
θ = 0.5
solver = ThetaMethod(nl_solver, Δt, θ)</code></pre><p>For a two-stage singly-diagonally-implicit scheme (of order 2), it would be</p><pre><code class="language-julia">tableau = :SDIRK_2_2
solver_rk = RungeKutta(nl_solver, lin_solver, Δt, tableau)</code></pre><p>We define the initial condition and the solution using the <code>solve</code> function as in Tutorial 17:</p><pre><code class="language-julia">t0, tF = 0.0, 10.0
uh0 = interpolate_everywhere(g(t0), Ug(t0))
uh = solve(solver, op_sl, t0, tF, uh0)</code></pre><h2 id="Postprocessing-1"><a class="docs-heading-anchor" href="#Postprocessing-1">Postprocessing</a><a class="docs-heading-anchor-permalink" href="#Postprocessing-1" title="Permalink"></a></h2><p>Here again, we export the solution at each time step as follows</p><pre><code class="language-julia">if !isdir(&quot;tmp_nl&quot;)
  mkdir(&quot;tmp_nl&quot;)
end

createpvd(&quot;results_nl&quot;) do pvd
  pvd[0] = createvtk(Ω, &quot;tmp_nl/results_0&quot; * &quot;.vtu&quot;, cellfields=[&quot;u&quot; =&gt; uh0])
  for (tn, uhn) in uh
    pvd[tn] = createvtk(Ω, &quot;tmp_nl/results_$tn&quot; * &quot;.vtu&quot;, cellfields=[&quot;u&quot; =&gt; uhn])
  end
end</code></pre><p><img src="../../assets/transient_nonlinear/result.gif" alt/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t017_transient_linear/">« 17 Transient Poisson equation</a><a class="docs-footer-nextpage" href="../t019_TopOptEMFocus/">19 Topology optimization »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 4 March 2025 22:03">Tuesday 4 March 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
