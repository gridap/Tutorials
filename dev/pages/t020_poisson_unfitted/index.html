<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>20 Poisson on unfitted meshes · Gridap tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gridap tutorials logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap tutorials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="tocitem" href="../t002_validation/">2 Code validation</a></li><li><a class="tocitem" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="tocitem" href="../t004_p_laplacian/">4 p-Laplacian</a></li><li><a class="tocitem" href="../t005_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="tocitem" href="../t006_dg_discretization/">6 Poisson equation (with DG)</a></li><li><a class="tocitem" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="tocitem" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li><li><a class="tocitem" href="../t009_stokes/">9 Stokes equation</a></li><li><a class="tocitem" href="../t010_advection_diffusion/">10 Advection-diffusion</a></li><li><a class="tocitem" href="../t011_isotropic_damage/">11 Isotropic damage model</a></li><li><a class="tocitem" href="../t012_fsi_tutorial/">12 Fluid-Structure Interaction</a></li><li><a class="tocitem" href="../t013_emscatter/">13 Electromagnetic scattering in 2D</a></li><li><a class="tocitem" href="../t014_validation_DrWatson/">14 On using DrWatson.jl</a></li><li><a class="tocitem" href="../t015_interpolation_fe/">15 Interpolation of CellFields</a></li><li><a class="tocitem" href="../t016_poisson_distributed/">16 Poisson equation on parallel distributed-memory computers</a></li><li><a class="tocitem" href="../t017_transient_linear/">17 Transient Poisson equation</a></li><li><a class="tocitem" href="../t018_transient_nonlinear/">18 Transient nonlinear equation</a></li><li><a class="tocitem" href="../t019_TopOptEMFocus/">19 Topology optimization</a></li><li class="is-active"><a class="tocitem" href>20 Poisson on unfitted meshes</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement-1"><span>Problem statement</span></a></li><li><a class="tocitem" href="#Numerical-scheme-1"><span>Numerical scheme</span></a></li></ul></li><li><a class="tocitem" href="../t021_poisson_amr/">21 Poisson with AMR</a></li><li><a class="tocitem" href="../t022_poisson_hdg/">22 Poisson with HDG</a></li><li><a class="tocitem" href="../t023_poisson_hho/">23 Poisson with HHO on polytopal meshes</a></li><li><a class="tocitem" href="../t024_stokes_blocks/">24 Block assembly and solvers: Incompressible Stokes example</a></li><li><a class="tocitem" href="../t025_lagrange_multipliers/">25 Lagrange multipliers</a></li><li><a class="tocitem" href="../t026_poisson_dev_fe/">26 Low-level API - Poisson equation</a></li><li><a class="tocitem" href="../t027_geometry_dev/">27 Low-level API - Geometry</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>20 Poisson on unfitted meshes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>20 Poisson on unfitted meshes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Tutorials/blob/master/src/poisson_unfitted.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="poisson_unfitted.jl-1"><a class="docs-heading-anchor" href="#poisson_unfitted.jl-1">Tutorial 20: Poisson on unfitted meshes</a><a class="docs-heading-anchor-permalink" href="#poisson_unfitted.jl-1" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t020_poisson_unfitted.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t020_poisson_unfitted.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this <strong>tutorial</strong>, we will learn</p><ul><li>How to use <a href="https://github.com/gridap/GridapEmbedded.jl">GridapEmbedded</a></li><li>How to formulate an unfitted finite element method</li><li>How to construct an unfitted boundary geometry setup</li><li>How to use the Aggregated Finite Element Method</li><li>How to impose Dirichlet boundary conditions <em>weakly</em></li></ul><h2 id="Problem-statement-1"><a class="docs-heading-anchor" href="#Problem-statement-1">Problem statement</a><a class="docs-heading-anchor-permalink" href="#Problem-statement-1" title="Permalink"></a></h2><p>We want to solve the <strong>Poisson equation</strong> on the crescent moon 2D shape shown in the next figure</p><p><img src="../../assets/unfitted_poisson/crescent_moon.png" alt="fig0a"/></p><p>We prescribe the linear solution to the problem <span>$u(x) = x - y$</span> and Dirichlet boundary conditions on the whole boundary. Thus, the problem to solve is: find the scalar field <span>$u$</span> such that</p><div>\[\left\lbrace
\begin{aligned}
-\Delta u &amp;= 0 \ &amp;\text{in} \ \Omega,\\
u &amp;= x - y \ &amp;\text{on}\ \partial\Omega
\end{aligned}
\right.\]</div><h2 id="Numerical-scheme-1"><a class="docs-heading-anchor" href="#Numerical-scheme-1">Numerical scheme</a><a class="docs-heading-anchor-permalink" href="#Numerical-scheme-1" title="Permalink"></a></h2><p>To solve this PDE, we will use an unfitted technique. The idea behind <em>unfitted</em>, aka <em>embedded</em> or <em>immersed boundary</em>, methods is quite simple: Instead of relying on a mesh that fits to the domain boundary, we embed the domain in a background grid, upon which we will define our finite elements.</p><table><tr><th style="text-align: right">Body-fitted</th><th style="text-align: right">Unfitted</th></tr><tr><td style="text-align: right"><img src="../../assets/unfitted_poisson/fig_2_body-fitted_a_bis.png" alt="fig0b"/></td><td style="text-align: right"><img src="../../assets/unfitted_poisson/fig_3_unfitted.png" alt="fig0c"/></td></tr></table><p>Unfitted methods allow one to circumvent the meshing bottleneck when dealing with very complex geometries. But, as usual, this comes at a price. In unfitted methods, integration of the weak form and imposition of Dirichlet boundary conditions becomes more involved. In addition, we have to be careful with the small cut cell problem, which refers to stability and ill-conditioning issues that appear in presence of very small intersections between the background cells and the domain.</p><p>Fortunately, there are plenty of solutions available to take care of all these challenges. For more details, we refer to this recent review:</p><blockquote><p>F. de Prenter, C. Verhoosel, H. van Brummelen, M. Larson, S. Badia, <em>Stability and conditioning of immersed finite element methods: analysis and remedies</em> arXiv preprint <a href="https://arxiv.org/pdf/2208.08538.pdf">arXiv:2208.08538</a></p></blockquote><p>In this tutorial, we will use the functionality available at <a href="https://github.com/gridap/GridapEmbedded.jl">GridapEmbedded</a> to formulate and solve the unfitted problem above. We will illustrate a typical unfitted FE simulation pipeline in <a href="https://github.com/gridap/GridapEmbedded.jl">GridapEmbedded</a>, including how we setup the embedded geometry, how we deal with the integration of the weak form and the imposition of Dirichlet boundary conditions.</p><p>We will discretise the problem with the aggregated finite element method, which is robust to the small cut cell problem. For more details, we refer to:</p><blockquote><p>S. Badia, A.F. Martín, F. Verdugo, <em><a href="https://www.sciencedirect.com/science/article/pii/S0045782518301476">The aggregated unfitted finite element method for elliptic problems</a></em>, Computer Methods in Applied Mechanics and Engineering 336 (2018), 533-553.</p></blockquote><p>We recommend to read both references above to grasp the details of this tutorial.</p><p>The first step is to load the <a href="https://github.com/gridap/Gridap.jl">Gridap</a> and <a href="https://github.com/gridap/GridapEmbedded.jl">GridapEmbedded</a> packages.</p><pre><code class="language-julia">using Gridap
using GridapEmbedded</code></pre><h3 id="Implicit-boundary-representation-1"><a class="docs-heading-anchor" href="#Implicit-boundary-representation-1">Implicit boundary representation</a><a class="docs-heading-anchor-permalink" href="#Implicit-boundary-representation-1" title="Permalink"></a></h3><p>The next step is to generate the embedded geometry. The most straightforward way to represent the geometry is with the level-set method. It amounts to represent a closed curve (2D) or surface (3D) <span>$\Gamma$</span> using an auxiliary function <span>$\psi$</span>, called the level-set function. <span>$\Gamma$</span> is represented as the zero-level-set of <span>$\psi$</span> by</p><div>\[\Gamma = \{ (x,y) \ | \ \psi(x,y) = 0 \}\]</div><p>and the level-set method manipulates <span>$\Gamma$</span> <em>implicitly</em>, through the function <span>$\psi$</span>. This function <span>$\psi$</span> is assumed to take negative values inside the region delimited by <span>$\Gamma$</span> and positive values outside.</p><p><a href="https://github.com/gridap/GridapEmbedded.jl">GridapEmbedded</a> offers out-of-the-box level set surface descriptions for the <code>disk</code>, <code>cylinder</code>, <code>sphere</code>, <code>square</code>, <code>tube</code>, among others. You can also implement your own level-set function.</p><p>Interestingly, you can also construct complex domains from simple level-set descriptions. This is done by translating Boolean set operations and geometric transformations into simple manipulations of the level-set functions. For instance, given two level-set functions <span>$\psi_1$</span> and <span>$\psi_2$</span>, representing the domains <span>$\Omega_1$</span> and <span>$\Omega_2$</span>, the level-set function <span>$\psi = \min(\psi_1,\psi_2)$</span> gives the domain <span>$\Omega_1 \cup \Omega_2$</span>.</p><p>We will use the former properties to generate the crescent moon shape with <a href="https://github.com/gridap/GridapEmbedded.jl">GridapEmbedded</a> as follows. First, we note that the crescent moon shape is the outcome of subtracting to a disk of radius <span>$R=1/2$</span> another disk of radius R, whose center is at a relative position <span>$(-R/2,R/2)$</span>.</p><p><img src="../../assets/unfitted_poisson/crescent_moon_setup.png" alt="fig1"/></p><p>Defining this geometry in <a href="https://github.com/gridap/GridapEmbedded.jl">GridapEmbedded</a> is done as follows:</p><pre><code class="language-julia">R  = 0.5
L  = 0.5*R
p1 = Point(0.0,0.0)
p2 = p1 + VectorValue(-L,L)

geo1 = disk(R,x0=p1)
geo2 = disk(R,x0=p2)
geo3 = setdiff(geo1,geo2)</code></pre><p>Where we have used the <code>setdiff</code> function to subtract the disk <code>geo2</code> to the disk <code>geo1</code>. This is a very simple example of constructive solid geometry. <a href="https://github.com/gridap/GridapEmbedded.jl">GridapEmbedded</a> allows to create more complex CSG geometries as shown <a href="https://github.com/gridap/GridapEmbedded.jl#constructive-solid-geometry-csg">here</a>. For more general shapes, <a href="https://github.com/gridap/GridapEmbedded.jl">GridapEmbedded</a> admits an STL description of the implicit geometry, see package <a href="https://github.com/gridap/STLCutters.jl">STLCutters</a> for more details.</p><h3 id="Unfitted-triangulations-1"><a class="docs-heading-anchor" href="#Unfitted-triangulations-1">Unfitted triangulations</a><a class="docs-heading-anchor-permalink" href="#Unfitted-triangulations-1" title="Permalink"></a></h3><p>As explained, the rationale of unfitted methods is to embed the domain of interest in a background Cartesian grid (or, more generally, any easy-to-generate mesh). In our case, we generate a 30x30 Cartesian grid model containing the geometry as</p><pre><code class="language-julia">t = 1.01
pmin = p1-t*R
pmax = p1+t*R

n = 30
partition = (n,n)
bgmodel = CartesianDiscreteModel(pmin,pmax,partition)
dp = pmax - pmin</code></pre><p>Unfitted FE formulations in <a href="https://github.com/gridap/GridapEmbedded.jl">GridapEmbedded</a> hang on two different type of triangulations: &quot;Active&quot; and &quot;Physical&quot;. In order to generate them, we need first to cut the embedded geometry against the model with the function <code>cut</code>.</p><pre><code class="language-julia">cutgeo = cut(bgmodel,geo3)</code></pre><p><code>cut</code> generates an <code>EmbeddedDiscretization</code> instance (here, <code>cutgeo</code>). An <code>EmbeddedDiscretization</code> classifies all cells and facets from the background model into inside, outside or cutting the embedded geometry. Cells and facets of the background model outside the embedded geometry play no role in the unfitted formulation, they are <em>inactive</em>, thus it is convenient to remove them and restrict the triangulations to the <em>active</em> portion of the model (i.e., cut and interior cells and facets). In <a href="https://github.com/gridap/GridapEmbedded.jl">GridapEmbedded</a> we can do this using the classification from <code>cutgeo</code> and the <code>ACTIVE</code> keyword.</p><pre><code class="language-julia">Ω_act = Triangulation(cutgeo,ACTIVE)</code></pre><p>To illustrate this concept, we can plot both the background and active triangulations to compare them.</p><pre><code class="language-julia">Ω_bg = Triangulation(bgmodel)
mkpath(&quot;output_path&quot;)
writevtk(Ω_bg,&quot;output_path/bg_trian&quot;)
writevtk(Ω_act,&quot;output_path/act_trian&quot;)</code></pre><p>In the picture below of the background grid, white cells are <em>inactive</em>, whereas gray cells are <em>active</em>.</p><p><img src="../../assets/unfitted_poisson/fig_active_triangulation.png" alt="fig2"/></p><p>As we will see later, we define our unfitted FE spaces on <em>active</em> triangulations.</p><p>An <code>EmbeddedDiscretization</code> instance (here, <code>cutgeo</code>) also generates subtriangulations on each cut cells to represent the portion of the cell which is inside the domain of analysis. We use these subtriangulations to generate the so called <em>physical</em> triangulations. Physical triangulations are nothing other than a body-fitted mesh of our domain <span>$\Omega$</span>, but <em>we only use them to integrate the weak form</em> of the problem in <span>$\Omega$</span>, we won&#39;t define FE spaces and assign DoFs on top of them. In <a href="https://github.com/gridap/GridapEmbedded.jl">GridapEmbedded</a> we build physical triangulations using the <code>PHYSICAL</code> keyword.</p><pre><code class="language-julia">Ω = Triangulation(cutgeo,PHYSICAL)
writevtk(Ω,&quot;output_path/phys_trian&quot;)</code></pre><p>Once again, we can combine plots of the physical and active triangulations to illustrate these concepts. In the first plot, we show the physical triangulation within the background one.</p><p><img src="../../assets/unfitted_poisson/fig_physical_trian_1.png" alt="fig3"/></p><p>Note that cut cells are subtriangulated to approximate the embedded geometry, as exposed in the following close-up plot.</p><p><img src="../../assets/unfitted_poisson/fig_physical_trian_2.png" alt="fig4"/></p><p>In the third plot, we show the region represented by physical triangulation (shaded in gray) embedded in the active grid (black-contoured cells).</p><p><img src="../assets/unfitted_poisson/fig_physical_trian_3.png&quot; width=&quot;420&quot;" alt="fig5"/></p><p><strong>In a nutshell,</strong> to define the unfitted FE formulation of the problem we need the \&quot;active\&quot; and \&quot;physical\&quot; triangulations of the domain. The former triangulation is used to define the FE spaces, whereas the latter is used to integrate the weak form. We use a level-set function to derive both of them.</p><table><tr><th style="text-align: right">Active</th><th style="text-align: right">Physical</th></tr><tr><td style="text-align: right"><em>For</em> FE spaces</td><td style="text-align: right"><em>For</em> measures</td></tr><tr><td style="text-align: right"><img src="../../assets/unfitted_poisson/fig_active_triangulation.png" alt="fig6"/></td><td style="text-align: right"><img src="../../assets/unfitted_poisson/fig_physical_trian_1.png" alt="fig7"/></td></tr></table><h3 id="Unfitted-FE-spaces-1"><a class="docs-heading-anchor" href="#Unfitted-FE-spaces-1">Unfitted FE spaces</a><a class="docs-heading-anchor-permalink" href="#Unfitted-FE-spaces-1" title="Permalink"></a></h3><p>Standard FE methods, i.e. the usual ones for body-fitted meshes, are exposed to the small cut cell problem, which leads to stability and conditioning issues due to the presence of arbitrarily small cut cells. In unfitted FEM, it is impractical to have control over how the mesh intersects the geometry, so we need to treat these numerical issues.</p><p>As said, in this tutorial, we leverage the aggregated unfitted finite element method (AgFEM), see the figure below. The main idea is to remove DoFs on cut cells, whose basis functions potentially have very small local support. In order to do that, we constrain exterior DoFs <span>${\color{red}\times}$</span> in terms of interior DOFs <span>${\color{blue}\bullet}$</span> (see figure below) as follows:</p><ol><li>We map every exterior DoF <span>${\color{red}\times}$</span> to an interior cell <span>$\tilde{K}({\color{red}\times})$</span> of the active triangulation using a cell aggregation scheme (thus the name of the method).</li><li>We extrapolate the value at the exterior DoF <span>${\color{red}\times}$</span> with the local FE basis at the interior cell <span>$\tilde{K}({\color{red}\times})$</span>. This leads to:</li></ol><div>\[  u_{{\color{red}\times}} = \sum_{{\color{blue}\bullet}\in \tilde{K}({\color{red}\times})} \varphi_{{\color{blue}\bullet}}(x_{{\color{red}\times}})u_{{\color{blue}\bullet}}, \quad \forall {\color{red}\times}\]</div><p>Hence, we end up extrapolating exterior DoFs <span>${\color{red}\times}$</span>, in terms of interior ones <span>${\color{blue}\bullet}$</span>.</p><p><img src="../../assets/unfitted_poisson/fig_agfemspace.png" alt="fig8"/></p><p>We define the AgFEM space of our problem as follows. First, we generate a standard linear FE space <strong>on the <code>ACTIVE</code> triangulation</strong>. We do not prescribe Dirichlet boundaries on the standard FE space for reasons that will be clear later in the tutorial.</p><pre><code class="language-julia">order = 1
reffe = ReferenceFE(lagrangian,Float64,order)
Vstd = TestFESpace(Ω_act,reffe,conformity=:H1)</code></pre><p>After this, we construct the aggregates which will be used to build the map of exterior DoFs to interior ones.</p><pre><code class="language-julia">strategy = AggregateAllCutCells()
aggregates = aggregate(strategy,cutgeo)</code></pre><p>Note the following remark:</p><blockquote><p>Here, we aggregate all cut cells. Alternatively, we can leave out large enough cut cells using <code>AggregateCutCellsByThreshold(t)</code>, where <code>t</code> is a real number. Given a cut cell, if the ratio of the cut region volume and the background cell volume is larger than <code>t</code>, then this cell is <em>not</em> aggregated.</p></blockquote><p>We can color the aggregates and easily inspect them on the background mesh.</p><pre><code class="language-julia">colors = color_aggregates(aggregates,bgmodel)
Ω_bg = Triangulation(bgmodel)
writevtk(Ω_bg,&quot;output_path/aggs_on_bg_trian&quot;,celldata=[&quot;aggregate&quot;=&gt;aggregates,&quot;color&quot;=&gt;colors])</code></pre><p>Finally, we use the aggregates to constrain the exterior DoFs of <code>Vstd</code> in terms of the interior ones. This leads to the AgFEM space.</p><pre><code class="language-julia">V = AgFEMSpace(Vstd,aggregates)
U = TrialFESpace(V)</code></pre><p>Note that <code>V</code> is a test FE space and the trial FE space <code>U</code> does not receive Dirichlet functions, because we have not prescribed Dirichlet boundaries in the standard test FE space <code>Vstd</code>.</p><h3 id="Unfitted-measures-1"><a class="docs-heading-anchor" href="#Unfitted-measures-1">Unfitted measures</a><a class="docs-heading-anchor-permalink" href="#Unfitted-measures-1" title="Permalink"></a></h3><p>We define next the integration measures <strong>on the <code>PHYSICAL</code> triangulation</strong>.</p><pre><code class="language-julia">degree = 2*order
dΩ = Measure(Ω,degree)</code></pre><p>Although <code>degree = 2*order</code> is enough for this particular linear case. In general, we need to enforce <code>degree = 2*dim*order</code> on cut cells. This is a detail. We just leave a brief explanation of the reason below.</p><blockquote><p>Since interior cells are rectangular, Fubini theorem applies and we can separate the integrals of the weak form by dimensions. Thus, we can take as quadrature degree <code>2*order</code> as usual. However, in the case of cut cells, Fubini theorem does not hold. So, to take into account that we cannot separate the integrals, the quadrature degree on cut cells must be premultiplied by the problem dimension, i.e. <code>degree = 2*dim*order</code>.</p></blockquote><h3 id="Imposing-Dirichlet-boundary-conditions-1"><a class="docs-heading-anchor" href="#Imposing-Dirichlet-boundary-conditions-1">Imposing Dirichlet boundary conditions</a><a class="docs-heading-anchor-permalink" href="#Imposing-Dirichlet-boundary-conditions-1" title="Permalink"></a></h3><p>In unfitted FEMs, we cannot impose Dirichlet boundary contions on the Poisson problem as in body-fitted ones. The reason is apparent in the figure below.</p><p>We assume a Poisson problem defined on a 2D shape with Dirichlet <span>$\Gamma_D$</span> and Neumann <span>$\Gamma_N$</span> BCs and a close-up on the Dirichlet boundary.</p><table><tr><th style="text-align: right">Model problem</th><th style="text-align: right">Body-fitted</th><th style="text-align: right">Unfitted</th></tr><tr><td style="text-align: right"><img src="../../assets/unfitted_poisson/fig_cp_bcs.png" alt="fig9"/></td><td style="text-align: right"><img src="../../assets/unfitted_poisson/fig_bf_bcs.png" alt="fig10"/></td><td style="text-align: right"><img src="../../assets/unfitted_poisson/fig_ud_bcs.png" alt="fig11"/></td></tr></table><p>Clearly, on body-fitted meshes, we can impose Dirichlet BCs <em>strongly</em>, i.e. remove the basis functions associated to Dirichlet DoFs from the FE space. On unfitted meshes, we must enforce these conditions weakly. In order to do that we resort to Nitsche&#39;s method:</p><div>\[\begin{aligned}
a_K(u,v) &amp;\doteq \int_{\Omega \cap K} \nabla u \cdot \nabla v \ \mathrm{d}\Omega + \int_{\Gamma_{\rm D} \cap K} \beta_K uv -  (\nabla u \cdot \boldsymbol{n} ) v - (\nabla v \cdot \boldsymbol{n} ) u \ \mathrm{d}\Omega \\
l_K(v) &amp;\doteq \int_{\Omega \cap K} f v \ \mathrm{d}\Omega + \int_{\Gamma_{\rm N} \cap K} g v \ \mathrm{d}\Gamma + \int_{\Gamma_{\rm D} \cap K} \beta_K u_{\rm D}v - (\nabla v \cdot \boldsymbol{n} ) u_{\rm D} \ \mathrm{d}\Omega
\end{aligned}\]</div><p>where <span>$\beta_K$</span> must be large enough to ensure coercivity of the problem.</p><p>This means we need to integrate boundary tems along the embedded boundary. For this purpose we generate the embedded boundary triangulation and measure.</p><pre><code class="language-julia">Γ = EmbeddedBoundary(cutgeo)
n_Γ = get_normal_vector(Γ)
dΓ = Measure(Γ,degree)</code></pre><p>We can now write the weak form of the problem.</p><pre><code class="language-julia">u(x) = x[1] - x[2] # Solution of the problem
const γd = 10.0    # Nitsche coefficient
const h = dp[1]/n  # Mesh size according to the parameters of the background grid

a(u,v) =
  ∫( ∇(v)⋅∇(u) )dΩ +
  ∫( (γd/h)*v*u  - v*(n_Γ⋅∇(u)) - (n_Γ⋅∇(v))*u )dΓ

l(v) = ∫( (γd/h)*v*u - (n_Γ⋅∇(v))*u )dΓ</code></pre><p>Once we have done all this, the rest of the pipeline follows the steps of a standard FE simulation.</p><pre><code class="language-julia">op = AffineFEOperator(a,l,U,V)
uh = solve(op)

e = u - uh

l2(u) = sqrt(sum( ∫( u*u )*dΩ ))
h1(u) = sqrt(sum( ∫( u*u + ∇(u)⋅∇(u) )*dΩ ))

el2 = l2(e)
eh1 = h1(e)
ul2 = l2(uh)
uh1 = h1(uh)

using Test
@test el2/ul2 &lt; 1.e-8
@test eh1/uh1 &lt; 1.e-7

writevtk(Ω,&quot;output_path/results.vtu&quot;,cellfields=[&quot;uh&quot;=&gt;uh])</code></pre><p><img src="../../assets/unfitted_poisson/fig_results.png" alt="fig10"/></p><p><strong>Tutorial done!</strong></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t019_TopOptEMFocus/">« 19 Topology optimization</a><a class="docs-footer-nextpage" href="../t021_poisson_amr/">21 Poisson with AMR »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 25 September 2025 00:53">Thursday 25 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
