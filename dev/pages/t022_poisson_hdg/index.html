<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>22 Poisson with HDG · Gridap tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gridap tutorials logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap tutorials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="tocitem" href="../t002_validation/">2 Code validation</a></li><li><a class="tocitem" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="tocitem" href="../t004_p_laplacian/">4 p-Laplacian</a></li><li><a class="tocitem" href="../t005_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="tocitem" href="../t006_dg_discretization/">6 Poisson equation (with DG)</a></li><li><a class="tocitem" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="tocitem" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li><li><a class="tocitem" href="../t009_stokes/">9 Stokes equation</a></li><li><a class="tocitem" href="../t010_advection_diffusion/">10 Advection-diffusion</a></li><li><a class="tocitem" href="../t011_isotropic_damage/">11 Isotropic damage model</a></li><li><a class="tocitem" href="../t012_fsi_tutorial/">12 Fluid-Structure Interaction</a></li><li><a class="tocitem" href="../t013_emscatter/">13 Electromagnetic scattering in 2D</a></li><li><a class="tocitem" href="../t014_validation_DrWatson/">14 On using DrWatson.jl</a></li><li><a class="tocitem" href="../t015_interpolation_fe/">15 Interpolation of CellFields</a></li><li><a class="tocitem" href="../t016_poisson_distributed/">16 Poisson equation on parallel distributed-memory computers</a></li><li><a class="tocitem" href="../t017_transient_linear/">17 Transient Poisson equation</a></li><li><a class="tocitem" href="../t018_transient_nonlinear/">18 Transient nonlinear equation</a></li><li><a class="tocitem" href="../t019_TopOptEMFocus/">19 Topology optimization</a></li><li><a class="tocitem" href="../t020_poisson_unfitted/">20 Poisson on unfitted meshes</a></li><li><a class="tocitem" href="../t021_poisson_amr/">21 Poisson with AMR</a></li><li class="is-active"><a class="tocitem" href>22 Poisson with HDG</a><ul class="internal"><li><a class="tocitem" href="#HDG-Discretization-1"><span>HDG Discretization</span></a></li><li><a class="tocitem" href="#Manufactured-Solution-1"><span>Manufactured Solution</span></a></li><li><a class="tocitem" href="#Geometry-1"><span>Geometry</span></a></li><li><a class="tocitem" href="#PatchTopology-and-PatchTriangulation-1"><span>PatchTopology and PatchTriangulation</span></a></li><li><a class="tocitem" href="#FESpaces-1"><span>FESpaces</span></a></li><li><a class="tocitem" href="#MultiField-Structure-1"><span>MultiField Structure</span></a></li><li><a class="tocitem" href="#Weak-Form-and-integration-1"><span>Weak Form and integration</span></a></li><li><a class="tocitem" href="#Static-Condensation-and-Solution-1"><span>Static Condensation and Solution</span></a></li><li><a class="tocitem" href="#Going-Further-1"><span>Going Further</span></a></li></ul></li><li><a class="tocitem" href="../t023_poisson_hho/">23 Poisson with HHO on polytopal meshes</a></li><li><a class="tocitem" href="../t024_stokes_blocks/">24 Block assembly and solvers: Incompressible Stokes example</a></li><li><a class="tocitem" href="../t025_lagrange_multipliers/">25 Lagrange multipliers</a></li><li><a class="tocitem" href="../t026_poisson_dev_fe/">26 Low-level API - Poisson equation</a></li><li><a class="tocitem" href="../t027_geometry_dev/">27 Low-level API - Geometry</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>22 Poisson with HDG</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>22 Poisson with HDG</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Tutorials/blob/master/src/poisson_hdg.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="poisson_hdg.jl-1"><a class="docs-heading-anchor" href="#poisson_hdg.jl-1">Tutorial 22: Poisson with HDG</a><a class="docs-heading-anchor-permalink" href="#poisson_hdg.jl-1" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t022_poisson_hdg.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t022_poisson_hdg.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will implement a Hybridizable Discontinuous Galerkin (HDG) method for solving the Poisson equation. The HDG method is an efficient variant of DG methods that introduces an auxiliary variable m on mesh interfaces to reduce the global system size.</p><h2 id="HDG-Discretization-1"><a class="docs-heading-anchor" href="#HDG-Discretization-1">HDG Discretization</a><a class="docs-heading-anchor-permalink" href="#HDG-Discretization-1" title="Permalink"></a></h2><p>We consider the Poisson equation with Dirichlet boundary conditions:</p><div>\[\begin{aligned}
-\Delta u &amp;= f \quad \text{in} \quad \Omega\\
u &amp;= g \quad \text{in} \quad \partial\Omega
\end{aligned}\]</div><p>The HDG method first rewrites the problem as a first-order system:</p><div>\[\begin{aligned}
\boldsymbol{q} + \nabla u &amp;= \boldsymbol{0} \quad \text{in} \quad \Omega\\
\nabla \cdot \boldsymbol{q} &amp;= f \quad \text{in} \quad \Omega\\
u &amp;= g \quad \text{on} \quad \partial\Omega
\end{aligned}\]</div><p>The HDG discretization introduces three variables:</p><ul><li><span>$\boldsymbol{q}_h$</span>: the approximation to the flux <span>$\boldsymbol{q}$</span></li><li><span>$u_h$</span>: the approximation to the solution <span>$u$</span></li><li><span>$m_h$</span>: the approximation to the trace of <span>$u$</span> on element faces</li></ul><p>Numerical fluxes are defindes as</p><div>\[\widehat{\boldsymbol{q}}_h = \boldsymbol{q}_h + \tau(u_h - m_h)\boldsymbol{n}\]</div><p>where <span>$\tau$</span> is a stabilization parameter.</p><p>First, let&#39;s load the required Gridap packages:</p><pre><code class="language-julia">using Gridap
using Gridap.Geometry
using Gridap.FESpaces
using Gridap.MultiField
using Gridap.CellData</code></pre><h2 id="Manufactured-Solution-1"><a class="docs-heading-anchor" href="#Manufactured-Solution-1">Manufactured Solution</a><a class="docs-heading-anchor-permalink" href="#Manufactured-Solution-1" title="Permalink"></a></h2><p>We use the method of manufactured solutions to verify our implementation. We choose a solution u and derive the corresponding source term f:</p><pre><code class="language-julia">u(x) = sin(2*π*x[1])*sin(2*π*x[2])
q(x) = -∇(u)(x)  # Define the flux q = -∇u
f(x) = (∇ ⋅ q)(x) # Source term f = -Δu = -∇⋅(∇u)$</code></pre><h2 id="Geometry-1"><a class="docs-heading-anchor" href="#Geometry-1">Geometry</a><a class="docs-heading-anchor-permalink" href="#Geometry-1" title="Permalink"></a></h2><p>We generate a D-dimensional simplicial mesh from a Cartesian grid:</p><pre><code class="language-julia">D = 2  # Problem dimension
nc = Tuple(fill(8, D))  # 4 cells in each direction
domain = Tuple(repeat([0, 1], D))  # Unit cube domain
model = simplexify(CartesianDiscreteModel(domain,nc))</code></pre><p>From this mesh, we will require two triangulations where to define our HDG spaces:</p><ol><li>A cell triangulation <span>$\Omega$</span>, for the volume variables</li><li>A face triangulation <span>$\Gamma$</span>, for the skeleton variables</li></ol><p>These are given by</p><pre><code class="language-julia">Ω = Triangulation(ReferenceFE{D}, model)  # Volume triangulation
Γ = Triangulation(ReferenceFE{D-1}, model)  # Skeleton triangulation</code></pre><h2 id="PatchTopology-and-PatchTriangulation-1"><a class="docs-heading-anchor" href="#PatchTopology-and-PatchTriangulation-1">PatchTopology and PatchTriangulation</a><a class="docs-heading-anchor-permalink" href="#PatchTopology-and-PatchTriangulation-1" title="Permalink"></a></h2><p>A key aspect of hybrid methods is the use of static condensation, which is the elimination of cell unknowns to reduce the size of the global system. To achieve this, we need to be able to assemble and solve local problems on each cell, that involve</p><ul><li>contributions from the cell itself</li><li>contributions from the cell faces</li></ul><p>To this end, Gridap provides a general framework for patch-assembly and solves. The idea is to define a patch decomposition of the mesh (in this case, a patch is a cell and its sourrounding faces). We can then gather contributions for each patch, solve the local problems, and assemble the results into the global system.</p><p>The following code creates the required <code>PatchTopology</code> for the problem at hand. We then take d-dimensional slices of it by the means of <code>PatchTriangulation</code> and <code>PatchBoundaryTriangulation</code>. These are the <code>Triangulation</code>s we will integrate our weakform over.</p><pre><code class="language-julia">ptopo = Geometry.PatchTopology(model)
Ωp = Geometry.PatchTriangulation(model,ptopo)  # Patch volume triangulation
Γp = Geometry.PatchBoundaryTriangulation(model,ptopo)  # Patch skeleton triangulation</code></pre><h2 id="FESpaces-1"><a class="docs-heading-anchor" href="#FESpaces-1">FESpaces</a><a class="docs-heading-anchor-permalink" href="#FESpaces-1" title="Permalink"></a></h2><p>HDG uses three different finite element spaces:</p><ol><li>A vector-valued space for the flux q (Q)</li><li>A scalar space for the solution u (V)</li><li>A scalar space for the interface variable m (M)</li></ol><p>We then define discontinuous finite element spaces of the approppriate order, locally <span>$\mathbb{P}^k$</span>. Note that only the skeletal space has Dirichlet boundary conditions.</p><pre><code class="language-julia">order = 1  # Polynomial order
reffe_Q = ReferenceFE(lagrangian, VectorValue{D, Float64}, order; space=:P)
reffe_V = ReferenceFE(lagrangian, Float64, order; space=:P)
reffe_M = ReferenceFE(lagrangian, Float64, order; space=:P)

V = TestFESpace(Ω, reffe_V; conformity=:L2)  # Discontinuous vector space
Q = TestFESpace(Ω, reffe_Q; conformity=:L2)  # Discontinuous scalar space
M = TestFESpace(Γ, reffe_M; conformity=:L2, dirichlet_tags=&quot;boundary&quot;)  # Interface space
N = TrialFESpace(M, u)</code></pre><h2 id="MultiField-Structure-1"><a class="docs-heading-anchor" href="#MultiField-Structure-1">MultiField Structure</a><a class="docs-heading-anchor-permalink" href="#MultiField-Structure-1" title="Permalink"></a></h2><p>Since we are doing static condensation, we need assemble by blocks. In particular, the <code>StaticCondensationOperator</code> expects the variables to be groupped in two blocks:</p><ul><li>The eliminated variables (in this case, the volume variables q and u)</li><li>The retained variables (in this case, the interface variable m)</li></ul><p>We will assemble by blocks using the <code>BlockMultiFieldStyle</code> API.</p><pre><code class="language-julia">mfs = BlockMultiFieldStyle(2,(2,1))  # Special blocking for efficient static condensation
X = MultiFieldFESpace([V, Q, N]; style=mfs)</code></pre><h2 id="Weak-Form-and-integration-1"><a class="docs-heading-anchor" href="#Weak-Form-and-integration-1">Weak Form and integration</a><a class="docs-heading-anchor-permalink" href="#Weak-Form-and-integration-1" title="Permalink"></a></h2><pre><code class="language-julia">degree = 2*(order+1)  # Integration degree
dΩp = Measure(Ωp,degree)  # Volume measure, on the patch triangulation
dΓp = Measure(Γp,degree)  # Surface measure, on the patch boundary triangulation

τ = 1.0 # HDG stabilization parameter

n = get_normal_vector(Γp)  # Face normal vector
Πn(u) = u⋅n  # Normal component
Π(u) = change_domain(u,Γp,DomainStyle(u))  # Project to skeleton

a((uh,qh,sh),(vh,wh,lh)) = ∫( qh⋅wh - uh*(∇⋅wh) - qh⋅∇(vh) )dΩp + ∫(sh*Πn(wh))dΓp +
                           ∫((Πn(qh) + τ*(Π(uh) - sh))*(Π(vh) + lh))dΓp
l((vh,wh,lh)) = ∫( f*vh )dΩp</code></pre><h2 id="Static-Condensation-and-Solution-1"><a class="docs-heading-anchor" href="#Static-Condensation-and-Solution-1">Static Condensation and Solution</a><a class="docs-heading-anchor-permalink" href="#Static-Condensation-and-Solution-1" title="Permalink"></a></h2><p>With all these ingredients, we can now build our statically-condensed operator ans solve the problem. Note that we are solving a scatically-condensed system. We can retrieve the internal <code>AffineFEOperator</code> from <code>op.sc_op</code>.</p><pre><code class="language-julia">op = MultiField.StaticCondensationOperator(ptopo,X,a,l)
uh, qh, sh = solve(op)

dΩ = Measure(Ω,degree)
eh = uh - u
l2_uh = sqrt(sum(∫(eh⋅eh)*dΩ))

mkpath(&quot;output_path&quot;)
writevtk(Ω,&quot;output_path/results&quot;,cellfields=[&quot;uh&quot;=&gt;uh,&quot;qh&quot;=&gt;qh,&quot;eh&quot;=&gt;eh])</code></pre><h2 id="Going-Further-1"><a class="docs-heading-anchor" href="#Going-Further-1">Going Further</a><a class="docs-heading-anchor-permalink" href="#Going-Further-1" title="Permalink"></a></h2><p>By modifying the stabilisation term, HDG can also work on polytopal meshes. An driver solving the same problem on a polytopal mesh is available <a href="https://github.com/gridap/Gridap.jl/blob/75efc9a7a7e286c27e7ca3ddef5468e591845484/test/GridapTests/HDGPolytopalTests.jl">in the Gridap repository</a>. A tutorial for HHO on polytopal meshes is also available.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t021_poisson_amr/">« 21 Poisson with AMR</a><a class="docs-footer-nextpage" href="../t023_poisson_hho/">23 Poisson with HHO on polytopal meshes »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 25 September 2025 00:53">Thursday 25 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
