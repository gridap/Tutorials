<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>23 Poisson with HHO on polytopal meshes · Gridap tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gridap tutorials logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap tutorials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="tocitem" href="../t002_validation/">2 Code validation</a></li><li><a class="tocitem" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="tocitem" href="../t004_p_laplacian/">4 p-Laplacian</a></li><li><a class="tocitem" href="../t005_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="tocitem" href="../t006_dg_discretization/">6 Poisson equation (with DG)</a></li><li><a class="tocitem" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="tocitem" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li><li><a class="tocitem" href="../t009_stokes/">9 Stokes equation</a></li><li><a class="tocitem" href="../t010_advection_diffusion/">10 Advection-diffusion</a></li><li><a class="tocitem" href="../t011_isotropic_damage/">11 Isotropic damage model</a></li><li><a class="tocitem" href="../t012_fsi_tutorial/">12 Fluid-Structure Interaction</a></li><li><a class="tocitem" href="../t013_emscatter/">13 Electromagnetic scattering in 2D</a></li><li><a class="tocitem" href="../t014_validation_DrWatson/">14 On using DrWatson.jl</a></li><li><a class="tocitem" href="../t015_interpolation_fe/">15 Interpolation of CellFields</a></li><li><a class="tocitem" href="../t016_poisson_distributed/">16 Poisson equation on parallel distributed-memory computers</a></li><li><a class="tocitem" href="../t017_transient_linear/">17 Transient Poisson equation</a></li><li><a class="tocitem" href="../t018_transient_nonlinear/">18 Transient nonlinear equation</a></li><li><a class="tocitem" href="../t019_TopOptEMFocus/">19 Topology optimization</a></li><li><a class="tocitem" href="../t020_poisson_unfitted/">20 Poisson on unfitted meshes</a></li><li><a class="tocitem" href="../t021_poisson_amr/">21 Poisson with AMR</a></li><li><a class="tocitem" href="../t022_poisson_hdg/">22 Poisson with HDG</a></li><li class="is-active"><a class="tocitem" href>23 Poisson with HHO on polytopal meshes</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement-1"><span>Problem statement</span></a></li><li><a class="tocitem" href="#HHO-discretization-1"><span>HHO discretization</span></a></li><li><a class="tocitem" href="#Geometry-1"><span>Geometry</span></a></li><li><a class="tocitem" href="#FESpaces-1"><span>FESpaces</span></a></li><li><a class="tocitem" href="#MultiField-Structure-1"><span>MultiField Structure</span></a></li><li><a class="tocitem" href="#PatchTopology-and-PatchTriangulation-1"><span>PatchTopology and PatchTriangulation</span></a></li><li><a class="tocitem" href="#Local-operators-1"><span>Local operators</span></a></li><li><a class="tocitem" href="#Weakform-and-assembly-1"><span>Weakform and assembly</span></a></li><li><a class="tocitem" href="#Going-further-1"><span>Going further</span></a></li></ul></li><li><a class="tocitem" href="../t024_stokes_blocks/">24 Block assembly and solvers: Incompressible Stokes example</a></li><li><a class="tocitem" href="../t025_lagrange_multipliers/">25 Lagrange multipliers</a></li><li><a class="tocitem" href="../t026_poisson_dev_fe/">26 Low-level API - Poisson equation</a></li><li><a class="tocitem" href="../t027_geometry_dev/">27 Low-level API - Geometry</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>23 Poisson with HHO on polytopal meshes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>23 Poisson with HHO on polytopal meshes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Tutorials/blob/master/src/poisson_hho.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="poisson_hho.jl-1"><a class="docs-heading-anchor" href="#poisson_hho.jl-1">Tutorial 23: Poisson with HHO on polytopal meshes</a><a class="docs-heading-anchor-permalink" href="#poisson_hho.jl-1" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t023_poisson_hho.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t023_poisson_hho.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will learn how to implement a mixed-order Hybrid High-Order (HHO) method for solving the Poisson equation. HHO methods are a class of modern hybridizable finite element methods that provide optimal convergence rates while enabling static condensation for efficient solution.</p><p>HHO is a mathematically complex method. This tutorial will <strong>NOT</strong> cover the method nor its mathematical foundations. You should be familiar with both before going into the tutorial itself. We also recommend going through the HDG tutorial first, which shares many of the same concepts but is simpler to understand.</p><h2 id="Problem-statement-1"><a class="docs-heading-anchor" href="#Problem-statement-1">Problem statement</a><a class="docs-heading-anchor-permalink" href="#Problem-statement-1" title="Permalink"></a></h2><p>We consider the Poisson equation with Dirichlet boundary conditions:</p><div>\[\begin{aligned}
-\Delta u &amp;= f \quad \text{in } \Omega \\
u &amp;= g \quad \text{on } \partial\Omega
\end{aligned}\]</div><p>where <span>$\Omega$</span> is a bounded domain in <span>$\mathbb{R}^2$</span>, f is a source term, and <span>$g$</span> is the prescribed boundary value.</p><h2 id="HHO-discretization-1"><a class="docs-heading-anchor" href="#HHO-discretization-1">HHO discretization</a><a class="docs-heading-anchor-permalink" href="#HHO-discretization-1" title="Permalink"></a></h2><p>The HHO method introduces two types of unknowns:</p><ol><li>Cell unknowns defined in the volume of each mesh cell</li><li>Face unknowns defined on the mesh facets</li></ol><p>This hybrid structure allows for efficient static condensation by eliminating the cell unknowns algebraically at the element level.</p><p>We start by loading the required packages</p><pre><code class="language-julia">using Gridap
using Gridap.Geometry, Gridap.FESpaces, Gridap.MultiField
using Gridap.CellData, Gridap.Fields, Gridap.Helpers
using Gridap.ReferenceFEs
using Gridap.Arrays</code></pre><h2 id="Geometry-1"><a class="docs-heading-anchor" href="#Geometry-1">Geometry</a><a class="docs-heading-anchor-permalink" href="#Geometry-1" title="Permalink"></a></h2><p>We generate a 2-dimensional simplicial mesh from a Cartesian grid, then taking its Voronoi dual to create a polytopal mesh.</p><pre><code class="language-julia">u(x) = sin(2*π*x[1])*sin(2*π*x[2])
f(x) = -Δ(u)(x)

n = 10
base_model = simplexify(CartesianDiscreteModel((0,1,0,1),(n,n)))
model = Geometry.voronoi(base_model)</code></pre><p>From this mesh, we will require two triangulations where to define our HDG spaces:</p><ol><li>A cell triangulation <span>$\Omega$</span>, for the volume variables</li><li>A face triangulation <span>$\Gamma$</span>, for the skeleton variables</li></ol><p>These are given by</p><pre><code class="language-julia">D = num_cell_dims(model)
Ω = Triangulation(ReferenceFE{D}, model)
Γ = Triangulation(ReferenceFE{D-1}, model)</code></pre><h2 id="FESpaces-1"><a class="docs-heading-anchor" href="#FESpaces-1">FESpaces</a><a class="docs-heading-anchor-permalink" href="#FESpaces-1" title="Permalink"></a></h2><p>HHO uses two different finite element spaces:</p><ol><li>A scalar space for the bulk variable uT (V)</li><li>A scalar space for the skeleton variable uF (M)</li></ol><p>We then define discontinuous finite element spaces of the approppriate order, locally <span>$\mathbb{P}^k$</span>. Because we are using a mixed-order scheme, the bulk space has a higher polynomial order than the skeleton space. Note that only the skeletal space has Dirichlet boundary conditions.</p><pre><code class="language-julia">order = 1
V = FESpaces.PolytopalFESpace(Ω, Float64, order+1; space=:P) # Bulk space
M = FESpaces.PolytopalFESpace(Γ, Float64, order; space=:P, dirichlet_tags=&quot;boundary&quot;) # Skeleton space
N = TrialFESpace(M,u)</code></pre><h2 id="MultiField-Structure-1"><a class="docs-heading-anchor" href="#MultiField-Structure-1">MultiField Structure</a><a class="docs-heading-anchor-permalink" href="#MultiField-Structure-1" title="Permalink"></a></h2><p>Since we are doing static condensation, we need assemble by blocks. In particular, the <code>StaticCondensationOperator</code> expects the variables to be groupped in two blocks:</p><ul><li>The eliminated variables (in this case, the volume variables q and u)</li><li>The retained variables (in this case, the interface variable m)</li></ul><p>We will assemble by blocks using the <code>BlockMultiFieldStyle</code> API.</p><pre><code class="language-julia">mfs = MultiField.BlockMultiFieldStyle(2,(1,1))
X   = MultiFieldFESpace([V, N];style=mfs)
Y   = MultiFieldFESpace([V, M];style=mfs)</code></pre><h2 id="PatchTopology-and-PatchTriangulation-1"><a class="docs-heading-anchor" href="#PatchTopology-and-PatchTriangulation-1">PatchTopology and PatchTriangulation</a><a class="docs-heading-anchor-permalink" href="#PatchTopology-and-PatchTriangulation-1" title="Permalink"></a></h2><p>A key aspect of hybrid methods is the use of static condensation, which is the elimination of cell unknowns to reduce the size of the global system. To achieve this, we need to be able to assemble and solve local problems on each cell, that involve</p><ul><li>contributions from the cell itself</li><li>contributions from the cell faces</li></ul><p>To this end, Gridap provides a general framework for patch-assembly and solves. The idea is to define a patch decomposition of the mesh (in this case, a patch is a cell and its sourrounding faces). We can then gather contributions for each patch, solve the local problems, and assemble the results into the global system.</p><p>The following code creates the required <code>PatchTopology</code> for the problem at hand. We then take d-dimensional slices of it by the means of <code>PatchTriangulation</code> and <code>PatchBoundaryTriangulation</code>. These are the <code>Triangulation</code>s we will integrate our weakform over.</p><pre><code class="language-julia">ptopo = Geometry.PatchTopology(model)
Ωp = Geometry.PatchTriangulation(model,ptopo)
Γp = Geometry.PatchBoundaryTriangulation(model,ptopo)

qdegree = 2*(order+1)
dΩp = Measure(Ωp,qdegree)
dΓp = Measure(Γp,qdegree)</code></pre><h2 id="Local-operators-1"><a class="docs-heading-anchor" href="#Local-operators-1">Local operators</a><a class="docs-heading-anchor-permalink" href="#Local-operators-1" title="Permalink"></a></h2><p>A key feature of HHO is the use of local solves to define local projections of our bulk and skeleton variables. Just like for static condensation, we will use patch assembly to gather the contributions from each patch and solve the local problems. The result is then an element of the space we are projecting to, given as a linear combination of the basis of that space. This whole abstraction is taken care of by the <code>LocalOperator</code> object.</p><p>For the mixed-order Poisson problem, we require two local projections.</p><h3 id="L2-projection-operator-1"><a class="docs-heading-anchor" href="#L2-projection-operator-1">L2 projection operator</a><a class="docs-heading-anchor-permalink" href="#L2-projection-operator-1" title="Permalink"></a></h3><p>First, an L2 local projection operator onto the mesh faces. This is the simplest operator we can define, such that given <span>$u$</span> in some undefined space, we find <span>$Pu \in V$</span> st</p><div>\[(Pu,q) = (u,q) \forall q \in V\]</div><p>This signature for the <code>LocalOperator</code> assumes that the rhs and lhs for each local problem are given by a single cell contribution (no patch assembly required). Note also the use of <code>FESpaceWithoutBCs</code>, which strips the boundary conditions from the space <code>V</code>. This is because we do not want to take into account boundary conditions when projecting onto the space. The local solve map is given by <code>LocalSolveMap</code>, which by default uses Julia&#39;s LU factorization to solve the local problem exactly.</p><pre><code class="language-julia">function projection_operator(V, Ω, dΩ)
  Π(u,Ω) = change_domain(u,Ω,DomainStyle(u))
  mass(u,v) = ∫(u⋅Π(v,Ω))dΩ
  V0 = FESpaces.FESpaceWithoutBCs(V)
  P = LocalOperator(
    LocalSolveMap(), V0, mass, mass; trian_out = Ω
  )
  return P
end</code></pre><h3 id="Reconstruction-operator-1"><a class="docs-heading-anchor" href="#Reconstruction-operator-1">Reconstruction operator</a><a class="docs-heading-anchor-permalink" href="#Reconstruction-operator-1" title="Permalink"></a></h3><p>Finally, we build the so-called reconstruction operator. This operator is highly tied to the ellipic projector, and projects our bulk-skeleton variable pair onto a bulk space of higher order.</p><p>It&#39;s definition can be found in HHO literature, and requires solving a constrained local problem on each cell and its faces. We therefore use patch assembly, and impose our constraint using an additional space <code>Λ</code> as a local Lagrange multiplier. Naturally, we want to eliminate the multiplier and return a solution in the reconstructed space <code>L</code>. This is taken care of by the <code>LocalPenaltySolveMap</code>, and the kwarg <code>space_out = L</code> which overrides the default behavior of returning a solution in the test space <code>Y</code>.</p><pre><code class="language-julia">function reconstruction_operator(ptopo,order,X,Ω,Γp,dΩp,dΓp)
  L = FESpaces.PolytopalFESpace(Ω, Float64, order+1; space=:P)
  Λ = FESpaces.PolytopalFESpace(Ω, Float64, 0; space=:P)

  n = get_normal_vector(Γp)
  Πn(v) = ∇(v)⋅n
  Π(u,Ω) = change_domain(u,Ω,DomainStyle(u))
  lhs((u,λ),(v,μ))   = ∫( (∇(u)⋅∇(v)) + (μ*u) + (λ*v) )dΩp
  rhs((uT,uF),(v,μ)) =  ∫( (∇(uT)⋅∇(v)) + (uT*μ) )dΩp + ∫( (uF - Π(uT,Γp))*(Πn(v)) )dΓp

  Y = FESpaces.FESpaceWithoutBCs(X)
  W = MultiFieldFESpace([L,Λ];style=BlockMultiFieldStyle())
  R = LocalOperator(
    LocalPenaltySolveMap(), ptopo, W, Y, lhs, rhs; space_out = L
  )
  return R
end

PΓ = projection_operator(M, Γp, dΓp)
R  = reconstruction_operator(ptopo,order,Y,Ωp,Γp,dΩp,dΓp)</code></pre><h2 id="Weakform-and-assembly-1"><a class="docs-heading-anchor" href="#Weakform-and-assembly-1">Weakform and assembly</a><a class="docs-heading-anchor-permalink" href="#Weakform-and-assembly-1" title="Permalink"></a></h2><p>We can now define:</p><ul><li>The consistency term <code>a</code></li><li>The stabilization term <code>s</code></li><li>The rhs term <code>l</code></li></ul><pre><code class="language-julia">hTinv = CellField(1 ./ collect(get_array(∫(1)dΩp)), Ωp)

function a(u,v)
  Ru_Ω, Ru_Γ = R(u)
  Rv_Ω, Rv_Γ = R(v)
  return ∫(∇(Ru_Ω)⋅∇(Rv_Ω) + ∇(Ru_Γ)⋅∇(Rv_Ω) + ∇(Ru_Ω)⋅∇(Rv_Γ) + ∇(Ru_Γ)⋅∇(Rv_Γ))dΩp
end

function s(u,v)
  function SΓ(u)
    u_Ω, u_Γ = u
    return PΓ(u_Ω) - u_Γ
  end
  return ∫(hTinv * (SΓ(u)⋅SΓ(v)))dΓp
end

l((vΩ,vΓ)) = ∫(f⋅vΩ)dΩp</code></pre><h3 id="Patch-FESpaces-1"><a class="docs-heading-anchor" href="#Patch-FESpaces-1">Patch-FESpaces</a><a class="docs-heading-anchor-permalink" href="#Patch-FESpaces-1" title="Permalink"></a></h3><p>An additional difficulty in HHO methods is that our reconstructed functions <code>R(u)</code> are hard to assemble. They are defined on the cells, but depend on skeleton degrees of freedom. We therefore cannot assemble them using the original FESpace <code>N</code>. Instead, we will create <br/>view of the original space that is defined on the patches, and can be used to assemble the local contributions depending on <code>R</code>. It can be done by the means of <code>PatchFESpace</code>:</p><pre><code class="language-julia">Xp  = FESpaces.PatchFESpace(X,ptopo)</code></pre><h3 id="Assembly-without-static-condensation-1"><a class="docs-heading-anchor" href="#Assembly-without-static-condensation-1">Assembly without static condensation</a><a class="docs-heading-anchor-permalink" href="#Assembly-without-static-condensation-1" title="Permalink"></a></h3><p>We can now proceed to evaluate and assemble all our contributions. Note that some of the contributions depend on the reconstructed variables, e.g <code>a(u,v)</code>, and need to be assembled using the <code>PatchFESpace</code> <code>Xp</code>, while others can be assembled using the original FESpace <code>X</code> (e.g. <code>s(u,v)</code> and <code>l(v)</code>). Assembly is therefore somewhat more complex than in the standard case. We need to collect the contributions for every (test,trial) pair, and then merge them into a single data structure that can be passed to the assembler. In the case of mixed-order HHO, we only have two combinations, (<code>Xp</code>, <code>Xp</code>) and (<code>X</code>, <code>X</code>), but the cross-terms appear also in the case of the original HHO formulation.</p><pre><code class="language-julia">global_assem = SparseMatrixAssembler(X,Y)

function weakform()
  u, v = get_trial_fe_basis(X), get_fe_basis(Y)
  data = FESpaces.collect_and_merge_cell_matrix_and_vector(
    (Xp, Xp, a(u,v), DomainContribution(), zero(Xp)),
    (X, Y, s(u,v), l(v), zero(X))
  )
  assemble_matrix_and_vector(global_assem,data)
end

A, b = weakform()
x = A \ b

ui, ub = FEFunction(X,x)
eu  = ui - u
l2u = sqrt(sum( ∫(eu * eu)dΩp))
h1u = l2u + sqrt(sum( ∫(∇(eu) ⋅ ∇(eu))dΩp))</code></pre><h3 id="Assembly-with-static-condensation-1"><a class="docs-heading-anchor" href="#Assembly-with-static-condensation-1">Assembly with static condensation</a><a class="docs-heading-anchor-permalink" href="#Assembly-with-static-condensation-1" title="Permalink"></a></h3><pre><code class="language-julia">patch_assem = FESpaces.PatchAssembler(ptopo,X,Y)

function patch_weakform()
  u, v = get_trial_fe_basis(X), get_fe_basis(Y)
  data = FESpaces.collect_and_merge_cell_matrix_and_vector(patch_assem,
    (Xp, Xp, a(u,v), DomainContribution(), zero(Xp)),
    (X, Y, s(u,v), l(v), zero(X))
  )
  return assemble_matrix_and_vector(patch_assem,data)
end

op = MultiField.StaticCondensationOperator(X,patch_assem,patch_weakform())
ui, ub = solve(op)

eu  = ui - u
l2u = sqrt(sum( ∫(eu * eu)dΩp))
h1u = l2u + sqrt(sum( ∫(∇(eu) ⋅ ∇(eu))dΩp))</code></pre><h2 id="Going-further-1"><a class="docs-heading-anchor" href="#Going-further-1">Going further</a><a class="docs-heading-anchor-permalink" href="#Going-further-1" title="Permalink"></a></h2><p>This tutorial has introduced the basic concepts of HHO methods using the simplest their simplest form, e.g. mixed-order HHO for the Poisson equation. More advanced drivers can be found with Gridap&#39;s tests. In particular:</p><ul><li><a href="https://github.com/gridap/Gridap.jl/blob/75efc9a7a7e286c27e7ca3ddef5468e591845484/test/GridapTests/HHOPolytopalTests.jl">Poisson with original HHO formulation</a></li><li><a href="https://github.com/gridap/Gridap.jl/blob/75efc9a7a7e286c27e7ca3ddef5468e591845484/test/GridapTests/HHOMixedStokesPolytopal.jl">Incompressible Stokes</a></li><li><a href="https://github.com/gridap/Gridap.jl/blob/75efc9a7a7e286c27e7ca3ddef5468e591845484/test/GridapTests/HHOMixedElasticity.jl">Linear Elasticity</a></li></ul><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t022_poisson_hdg/">« 22 Poisson with HDG</a><a class="docs-footer-nextpage" href="../t024_stokes_blocks/">24 Block assembly and solvers: Incompressible Stokes example »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 1 September 2025 22:01">Monday 1 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
