<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>24 Block assembly and solvers: Incompressible Stokes example · Gridap tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gridap tutorials logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap tutorials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="tocitem" href="../t002_validation/">2 Code validation</a></li><li><a class="tocitem" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="tocitem" href="../t004_p_laplacian/">4 p-Laplacian</a></li><li><a class="tocitem" href="../t005_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="tocitem" href="../t006_dg_discretization/">6 Poisson equation (with DG)</a></li><li><a class="tocitem" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="tocitem" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li><li><a class="tocitem" href="../t009_stokes/">9 Stokes equation</a></li><li><a class="tocitem" href="../t010_advection_diffusion/">10 Advection-diffusion</a></li><li><a class="tocitem" href="../t011_isotropic_damage/">11 Isotropic damage model</a></li><li><a class="tocitem" href="../t012_fsi_tutorial/">12 Fluid-Structure Interaction</a></li><li><a class="tocitem" href="../t013_emscatter/">13 Electromagnetic scattering in 2D</a></li><li><a class="tocitem" href="../t014_validation_DrWatson/">14 On using DrWatson.jl</a></li><li><a class="tocitem" href="../t015_interpolation_fe/">15 Interpolation of CellFields</a></li><li><a class="tocitem" href="../t016_poisson_distributed/">16 Poisson equation on parallel distributed-memory computers</a></li><li><a class="tocitem" href="../t017_transient_linear/">17 Transient Poisson equation</a></li><li><a class="tocitem" href="../t018_transient_nonlinear/">18 Transient nonlinear equation</a></li><li><a class="tocitem" href="../t019_TopOptEMFocus/">19 Topology optimization</a></li><li><a class="tocitem" href="../t020_poisson_unfitted/">20 Poisson on unfitted meshes</a></li><li><a class="tocitem" href="../t021_poisson_amr/">21 Poisson with AMR</a></li><li><a class="tocitem" href="../t022_poisson_hdg/">22 Poisson with HDG</a></li><li><a class="tocitem" href="../t023_poisson_hho/">23 Poisson with HHO on polytopal meshes</a></li><li class="is-active"><a class="tocitem" href>24 Block assembly and solvers: Incompressible Stokes example</a><ul class="internal"><li><a class="tocitem" href="#Block-structure-1"><span>Block structure</span></a></li><li><a class="tocitem" href="#Solution-strategy-1"><span>Solution strategy</span></a></li><li><a class="tocitem" href="#Geometry-and-FESpaces-1"><span>Geometry and FESpaces</span></a></li><li><a class="tocitem" href="#Block-multi-field-spaces-1"><span>Block multi-field spaces</span></a></li><li><a class="tocitem" href="#Weak-form-and-integration-1"><span>Weak form and integration</span></a></li><li><a class="tocitem" href="#Block-solvers-1"><span>Block solvers</span></a></li><li><a class="tocitem" href="#Going-further-1"><span>Going further</span></a></li></ul></li><li><a class="tocitem" href="../t025_lagrange_multipliers/">25 Lagrange multipliers</a></li><li><a class="tocitem" href="../t026_poisson_dev_fe/">26 Low-level API - Poisson equation</a></li><li><a class="tocitem" href="../t027_geometry_dev/">27 Low-level API - Geometry</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>24 Block assembly and solvers: Incompressible Stokes example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>24 Block assembly and solvers: Incompressible Stokes example</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Tutorials/blob/master/src/stokes_blocks.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="stokes_blocks.jl-1"><a class="docs-heading-anchor" href="#stokes_blocks.jl-1">Tutorial 24: Block assembly and solvers: Incompressible Stokes example</a><a class="docs-heading-anchor-permalink" href="#stokes_blocks.jl-1" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t024_stokes_blocks.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t024_stokes_blocks.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>This example solves the incompressible Stokes equations, given by</p><div>\[\left\lbrace
\begin{aligned}
-\Delta u - \nabla p &amp;= f \quad \text{in} \quad \Omega, \\
\nabla \cdot u &amp;= 0 \quad \text{in} \quad \Omega, \\
u &amp;= \hat{x} \quad \text{in} \quad \Gamma_\text{top} \subset \partial \Omega, \\
u &amp;= 0 \quad \text{in} \quad \partial \Omega \backslash \Gamma_\text{top} \\
\end{aligned}
\right.\]</div><p>where <span>$\Omega = [0,1]^d$</span>.</p><p>We use a mixed finite-element scheme, with <span>$Q_k \times P_{k-1}^{-}$</span> elements for the velocity-pressure pair.</p><p>To solve the linear system, we use a FGMRES solver preconditioned by a block-diagonal or block-triangular Shur-complement-based preconditioner.</p><h2 id="Block-structure-1"><a class="docs-heading-anchor" href="#Block-structure-1">Block structure</a><a class="docs-heading-anchor-permalink" href="#Block-structure-1" title="Permalink"></a></h2><p>The discretized system has a natural 2×2 block structure:</p><div>\[\begin{bmatrix}
A &amp; B^T \\
B &amp; 0
\end{bmatrix}
\begin{bmatrix}
u \\
p
\end{bmatrix} =
\begin{bmatrix}
f \\
0
\end{bmatrix}\]</div><p>where:</p><ul><li><div>\[A\]</div>: Vector Laplacian (velocity block)</li><li><div>\[B\]</div>: Divergence operator</li><li><div>\[B^T\]</div>: Gradient operator</li></ul><h2 id="Solution-strategy-1"><a class="docs-heading-anchor" href="#Solution-strategy-1">Solution strategy</a><a class="docs-heading-anchor-permalink" href="#Solution-strategy-1" title="Permalink"></a></h2><p>We use a FGMRES solver preconditioned by an upper block-triangular preconditioner:</p><div>\[P = \begin{bmatrix}
A &amp; B^T \\
0 &amp; -\hat{S}
\end{bmatrix}\]</div><p>where <span>$\hat{S}$</span> is an approximation of the Schur complement <span>$S = BA^{-1}B^T$</span>, which we will approximate using a pressure mass matrix.</p><pre><code class="language-julia">using LinearAlgebra
using BlockArrays

using Gridap
using Gridap.MultiField

using GridapSolvers
using GridapSolvers.LinearSolvers
using GridapSolvers.BlockSolvers: LinearSystemBlock, BiformBlock
using GridapSolvers.BlockSolvers: BlockDiagonalSolver, BlockTriangularSolver</code></pre><h2 id="Geometry-and-FESpaces-1"><a class="docs-heading-anchor" href="#Geometry-and-FESpaces-1">Geometry and FESpaces</a><a class="docs-heading-anchor-permalink" href="#Geometry-and-FESpaces-1" title="Permalink"></a></h2><p>See the basic Stokes tutorial for a detailed explanation.</p><pre><code class="language-julia">nc = (8,8)
Dc = length(nc)
domain = (Dc == 2) ? (0,1,0,1) : (0,1,0,1,0,1)

model = CartesianDiscreteModel(domain,nc)
labels = get_face_labeling(model)
if Dc == 2
  add_tag_from_tags!(labels,&quot;top&quot;,[6])
  add_tag_from_tags!(labels,&quot;walls&quot;,[1,2,3,4,5,7,8])
else
  add_tag_from_tags!(labels,&quot;top&quot;,[22])
  add_tag_from_tags!(labels,&quot;walls&quot;,[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,24,25,26])
end

order = 2
qdegree = 2*(order+1)
reffe_u = ReferenceFE(lagrangian,VectorValue{Dc,Float64},order)
reffe_p = ReferenceFE(lagrangian,Float64,order-1;space=:P)

u_walls = (Dc==2) ? VectorValue(0.0,0.0) : VectorValue(0.0,0.0,0.0)
u_top = (Dc==2) ? VectorValue(1.0,0.0) : VectorValue(1.0,0.0,0.0)

V = TestFESpace(model,reffe_u,dirichlet_tags=[&quot;walls&quot;,&quot;top&quot;]);
U = TrialFESpace(V,[u_walls,u_top]);
Q = TestFESpace(model,reffe_p;conformity=:L2,constraint=:zeromean)</code></pre><h2 id="Block-multi-field-spaces-1"><a class="docs-heading-anchor" href="#Block-multi-field-spaces-1">Block multi-field spaces</a><a class="docs-heading-anchor-permalink" href="#Block-multi-field-spaces-1" title="Permalink"></a></h2><p>Our first difference will come from how we define our multi-field spaces: Because we want to be able to use the block-structure of the linear system, we have to assemble our problem by blocks. The block structure of the resulting linear system is determined by the <code>BlockMultiFieldStyle</code> we use to define the multi-field spaces.</p><p>A <code>BlockMultiFieldStyle</code> takes three arguments:</p><ul><li><code>N</code>: The number of blocks we want</li><li><code>S</code>: An N-tuple with the number of fields in each block</li><li><code>P</code>: A permutation of the fields in the multi-field space, which determines      how fields are grouped into blocks.</li></ul><p>By default, we create as many blocks as there are fields in the multi-field space, and each block contains a single field with no permutation.</p><pre><code class="language-julia">mfs = BlockMultiFieldStyle(2,(1,1),(1,2))
X = MultiFieldFESpace([U,Q];style=mfs)
Y = MultiFieldFESpace([V,Q];style=mfs)</code></pre><h2 id="Weak-form-and-integration-1"><a class="docs-heading-anchor" href="#Weak-form-and-integration-1">Weak form and integration</a><a class="docs-heading-anchor-permalink" href="#Weak-form-and-integration-1" title="Permalink"></a></h2><pre><code class="language-julia">Ω = Triangulation(model)
dΩ = Measure(Ω,qdegree)

α = 1.e1
f = (Dc==2) ? VectorValue(1.0,1.0) : VectorValue(1.0,1.0,1.0)
a((u,p),(v,q)) = ∫(∇(v)⊙∇(u))dΩ - ∫(divergence(v)*p)dΩ - ∫(divergence(u)*q)dΩ
l((v,q)) = ∫(v⋅f)dΩ

op = AffineFEOperator(a,l,X,Y)</code></pre><h3 id="Block-structure-of-the-linear-system-1"><a class="docs-heading-anchor" href="#Block-structure-of-the-linear-system-1">Block structure of the linear system</a><a class="docs-heading-anchor-permalink" href="#Block-structure-of-the-linear-system-1" title="Permalink"></a></h3><p>As per usual, we can extract the matrix and vector of the linear system from the operator. Notice now that unlike in previous examples, the matrix is a <code>BlockMatrix</code> type, from the <code>BlockArrays.jl</code> package, which allows us to work with block-structured matrices.</p><pre><code class="language-julia">A = get_matrix(op)
b = get_vector(op)</code></pre><h2 id="Block-solvers-1"><a class="docs-heading-anchor" href="#Block-solvers-1">Block solvers</a><a class="docs-heading-anchor-permalink" href="#Block-solvers-1" title="Permalink"></a></h2><p>We will now setup two types of block preconditioners for the Stokes system. In both cases, we will use the preconditioners to solve the linear system using a Flexible GMRES solver. The idea behind these preconditioners is the well-known property that the Schur complement of the velocity block can be well approximated by a scaled pressure mass matrix. Moreover, in our pressure discretization is discontinuous which means that the pressure mass matrix is block-diagonal and easily invertible. In this example, we will use an exact LU solver for the velocity block and a CG solver with Jacobi preconditioner for the pressure block.</p><h3 id="Block-diagonal-preconditioner-1"><a class="docs-heading-anchor" href="#Block-diagonal-preconditioner-1">Block diagonal preconditioner</a><a class="docs-heading-anchor-permalink" href="#Block-diagonal-preconditioner-1" title="Permalink"></a></h3><p>The simplest block preconditioner is the block-diagonal preconditioner. The only ingredients required are</p><ul><li>the sub-solvers for each diagonal block and</li><li>the diagonal blocks we want to use.</li></ul><p>The sub-solvers are defined as follows:</p><pre><code class="language-julia">u_solver = LUSolver()
p_solver = CGSolver(JacobiLinearSolver();maxiter=20,atol=1e-14,rtol=1.e-6)</code></pre><p>The block structure is defined using the block API. We provide different types of blocks, that might have different uses depending on the problem at hand. We will here use two of the most common block types:</p><ul><li>The <code>LinearSystemBlock</code> defines a block that is taken directly (and aliased) form the linear system matrix <code>A</code>. We will use this for the velocity block.</li><li>For the pressure block, however, the pressure mass matrix is not directly available in the system matrix. Instead, we will have to integrate it using the Gridap API, as usual. These abstract concept is implemented in the <code>BiformBlock</code> type, which allows the user to define a block from a bilinear form.</li></ul><p>All in all, we define the block structure as follows:</p><pre><code class="language-julia">u_block = LinearSystemBlock()
p_block = BiformBlock((p,q) -&gt; ∫(-(1.0/α)*p*q)dΩ,Q,Q)</code></pre><p>With these ingredients, we can now define the block diagonal preconditioner as follows:</p><pre><code class="language-julia">PD = BlockDiagonalSolver([u_block,p_block],[u_solver,p_solver])
solver_PD = FGMRESSolver(20,PD;atol=1e-10,rtol=1.e-12,verbose=true)

uh, ph = solve(solver_PD, op)</code></pre><h3 id="Block-upper-triangular-preconditioner-1"><a class="docs-heading-anchor" href="#Block-upper-triangular-preconditioner-1">Block upper-triangular preconditioner</a><a class="docs-heading-anchor-permalink" href="#Block-upper-triangular-preconditioner-1" title="Permalink"></a></h3><p>A slighly more elaborate preconditioner (but also more robust) is the block upper-triangular preconditioner. The ingredients are similar:</p><ul><li>the sub-solvers for each diagonal block</li><li>the blocks that define the block structure, now including the off-diagonal blocks</li><li>the coefficients for the off-diagonal blocks, where zero coefficients indicate that the block is not used.</li></ul><p>We will also represent the off-diagonal blocks using the <code>LinearSystemBlock</code> type.</p><pre><code class="language-julia">sblocks = [     u_block        LinearSystemBlock();
           LinearSystemBlock()      p_block       ]
coeffs = [1.0 1.0;
          0.0 1.0]
PU = BlockTriangularSolver(sblocks,[u_solver,p_solver],coeffs,:upper)
solver_PU = FGMRESSolver(20,PU;atol=1e-10,rtol=1.e-12,verbose=true)

uh, ph = solve(solver_PU, op)</code></pre><p>As you can see, the block upper-triangular preconditioner is quite better than the block diagonal one.</p><h2 id="Going-further-1"><a class="docs-heading-anchor" href="#Going-further-1">Going further</a><a class="docs-heading-anchor-permalink" href="#Going-further-1" title="Permalink"></a></h2><p>If you want to see more examples of how to use the block solvers, you can check the documentation in <a href="https://gridap.github.io/GridapSolvers.jl/stable/">GridapSolvers.jl</a>, as well as it&#39;s <code>test/Applications</code> folder.</p><p>There you will find more complicated examples, such as using a GMG solver to solve the velocity block.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t023_poisson_hho/">« 23 Poisson with HHO on polytopal meshes</a><a class="docs-footer-nextpage" href="../t025_lagrange_multipliers/">25 Lagrange multipliers »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 1 September 2025 22:01">Monday 1 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
