<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>26 Low-level API - Poisson equation · Gridap tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gridap tutorials logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap tutorials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="tocitem" href="../t002_validation/">2 Code validation</a></li><li><a class="tocitem" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="tocitem" href="../t004_p_laplacian/">4 p-Laplacian</a></li><li><a class="tocitem" href="../t005_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="tocitem" href="../t006_dg_discretization/">6 Poisson equation (with DG)</a></li><li><a class="tocitem" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="tocitem" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li><li><a class="tocitem" href="../t009_stokes/">9 Stokes equation</a></li><li><a class="tocitem" href="../t010_advection_diffusion/">10 Advection-diffusion</a></li><li><a class="tocitem" href="../t011_isotropic_damage/">11 Isotropic damage model</a></li><li><a class="tocitem" href="../t012_fsi_tutorial/">12 Fluid-Structure Interaction</a></li><li><a class="tocitem" href="../t013_emscatter/">13 Electromagnetic scattering in 2D</a></li><li><a class="tocitem" href="../t014_validation_DrWatson/">14 On using DrWatson.jl</a></li><li><a class="tocitem" href="../t015_interpolation_fe/">15 Interpolation of CellFields</a></li><li><a class="tocitem" href="../t016_poisson_distributed/">16 Poisson equation on parallel distributed-memory computers</a></li><li><a class="tocitem" href="../t017_transient_linear/">17 Transient Poisson equation</a></li><li><a class="tocitem" href="../t018_transient_nonlinear/">18 Transient nonlinear equation</a></li><li><a class="tocitem" href="../t019_TopOptEMFocus/">19 Topology optimization</a></li><li><a class="tocitem" href="../t020_poisson_unfitted/">20 Poisson on unfitted meshes</a></li><li><a class="tocitem" href="../t021_poisson_amr/">21 Poisson with AMR</a></li><li><a class="tocitem" href="../t022_poisson_hdg/">22 Poisson with HDG</a></li><li><a class="tocitem" href="../t023_poisson_hho/">23 Poisson with HHO on polytopal meshes</a></li><li><a class="tocitem" href="../t024_stokes_blocks/">24 Block assembly and solvers: Incompressible Stokes example</a></li><li><a class="tocitem" href="../t025_lagrange_multipliers/">25 Lagrange multipliers</a></li><li class="is-active"><a class="tocitem" href>26 Low-level API - Poisson equation</a><ul class="internal"><li><a class="tocitem" href="#Introduction-and-caveat-1"><span>Introduction and caveat</span></a></li><li><a class="tocitem" href="#Including-Gridap&#39;s-low-level-API-1"><span>Including Gridap&#39;s low-level API</span></a></li><li><a class="tocitem" href="#Discrete-model-and-FE-spaces-set-up-using-high-level-API-1"><span>Discrete model and FE spaces set up using high-level API</span></a></li><li><a class="tocitem" href="#The-CellDatum-abstract-type-and-(some-of)-its-subtypes-1"><span>The <code>CellDatum</code> abstract type and (some of) its subtypes</span></a></li><li><a class="tocitem" href="#Exploring-our-first-CellField-objects-1"><span>Exploring our first <code>CellField</code> objects</span></a></li><li><a class="tocitem" href="#Exploring-another-type-of-CellField-objects-1"><span>Exploring another type of <code>CellField</code> objects</span></a></li><li><a class="tocitem" href="#The-geometrical-model-1"><span>The geometrical model</span></a></li><li><a class="tocitem" href="#A-low-level-definition-of-the-cell-map-1"><span>A low-level definition of the cell map</span></a></li><li><a class="tocitem" href="#Computing-the-gradients-of-the-trial-and-test-FE-space-bases-1"><span>Computing the gradients of the trial and test FE space bases</span></a></li><li><a class="tocitem" href="#A-low-level-implementation-of-the-residual-integration-and-assembly-1"><span>A low-level implementation of the residual integration and assembly</span></a></li><li><a class="tocitem" href="#Assembling-a-residual-1"><span>Assembling a residual</span></a></li><li><a class="tocitem" href="#A-low-level-implementation-of-the-Jacobian-integration-and-assembly-1"><span>A low-level implementation of the Jacobian integration and assembly</span></a></li></ul></li><li><a class="tocitem" href="../t027_geometry_dev/">27 Low-level API - Geometry</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>26 Low-level API - Poisson equation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>26 Low-level API - Poisson equation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Tutorials/blob/master/src/poisson_dev_fe.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="poisson_dev_fe.jl-1"><a class="docs-heading-anchor" href="#poisson_dev_fe.jl-1">Tutorial 26: Low-level API - Poisson equation</a><a class="docs-heading-anchor-permalink" href="#poisson_dev_fe.jl-1" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t026_poisson_dev_fe.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t026_poisson_dev_fe.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><h2 id="Introduction-and-caveat-1"><a class="docs-heading-anchor" href="#Introduction-and-caveat-1">Introduction and caveat</a><a class="docs-heading-anchor-permalink" href="#Introduction-and-caveat-1" title="Permalink"></a></h2><p>This tutorial is advanced and you only need to go through this if you want to know the internals of <code>Gridap</code> and what it does under the hood. Even though you will likely want to use the high-level APIs in <code>Gridap</code>, this tutorial will (hopefully) help if you want to become a <code>Gridap</code> developer, not just a user. We also consider that this tutorial shows how powerful and expressive the <code>Gridap</code> kernel is, and how mastering it you can implement new algorithms not currently provided by the library.</p><p>As any other Gridap tutorial, this tutorial is primarily designed to be executed in a Jupyter notebook environment. However, the usage of a Julia debugger (typically outside of a Jupyter notebook environment), such as, e.g., the Julia REPL-based <a href="https://github.com/JuliaDebug/Debugger.jl"><code>Debugger.jl</code></a> package, or the one which comes along with the Visual Studio Code (VSCode) extension for the Julia programming language, may help the reader eager to understand the full detail of the explanations given. Some of the observations that come along with the code snippets are quite subtle/technical and may require a deeper exploration of the underlying code using a debugger.</p><h2 id="Including-Gridap&#39;s-low-level-API-1"><a class="docs-heading-anchor" href="#Including-Gridap&#39;s-low-level-API-1">Including Gridap&#39;s low-level API</a><a class="docs-heading-anchor-permalink" href="#Including-Gridap&#39;s-low-level-API-1" title="Permalink"></a></h2><p>Let us start including <code>Gridap</code> and some of its submodules, to have access to a rich set of not so high-level methods. Note that the module <code>Gridap</code> provides the high-level API, whereas the submodules such as, e.g., <code>Gridap.FESpaces</code>, provide access to the different parts of the low-level API.</p><pre><code class="language-julia">using Gridap
using Gridap.FESpaces
using Gridap.ReferenceFEs
using Gridap.Arrays
using Gridap.Geometry
using Gridap.Fields
using Gridap.CellData
using FillArrays
using Test
using InteractiveUtils</code></pre><h2 id="Discrete-model-and-FE-spaces-set-up-using-high-level-API-1"><a class="docs-heading-anchor" href="#Discrete-model-and-FE-spaces-set-up-using-high-level-API-1">Discrete model and FE spaces set up using high-level API</a><a class="docs-heading-anchor-permalink" href="#Discrete-model-and-FE-spaces-set-up-using-high-level-API-1" title="Permalink"></a></h2><p>We first create the geometry model and FE spaces using the high-level API. In this tutorial, we are not going to describe the geometrical machinery in detail, only what is relevant for the discussion. To simplify the analysis of the outputs, you can consider a 2D mesh, i.e., <code>D=2</code> (everything below works for any spatial dimension without any extra complication). In order to make things slightly more interesting, i.e., having non-constant Jacobians, we have considered a mesh that is a stretching of an equal-sized structured mesh.</p><pre><code class="language-julia">L = 2 # Domain length in each space dimension
D = 2 # Number of spatial dimensions
n = 4 # Partition (i.e., number of cells per space dimension)

function stretching(x::Point)
   m = zeros(length(x))
   m[1] = x[1]^2
   for i in 2:D
     m[i] = x[i]
   end
   Point(m)
end

pmin = Point(Fill(0,D))
pmax = Point(Fill(L,D))
partition = Tuple(Fill(n,D))
model = CartesianDiscreteModel(pmin,pmax,partition,map=stretching)</code></pre><p>The next step is to build the global FE space of functions from which we are going to extract the unknown function of the differential problem at hand. This tutorial explores the Galerkin discretization of the scalar Poisson equation. Thus, we need to build H1-conforming global FE spaces. This can be achieved using <span>$C^0$</span> continuous functions made of piece(cell)-wise polynomials. This is precisely the purpose of the following lines of code.</p><p>First, we build a scalar-valued (<code>T = Float64</code>) Lagrangian reference FE of order <code>order</code> atop a reference n-cube of dimension <code>D</code>. To this end, we first need to create a <code>Polytope</code> using an array of dimension <code>D</code> with the parameter <code>HEX_AXIS</code>, which encodes the reference representation of the cells in the mesh. Then, we create the Lagrangian reference FE using the reference geometry just created in the previous step. It is not the purpose of this tutorial to describe the (key) abstract concept of <code>ReferenceFE</code> in Gridap.</p><pre><code class="language-julia">T = Float64
order = 1
pol = Polytope(Fill(HEX_AXIS,D)...)
reffe = LagrangianRefFE(T,pol,order)</code></pre><p>Second, we build the test (Vₕ) and trial (Uₕ) global finite element (FE) spaces out of <code>model</code> and <code>reffe</code>. At this point we also specify the notion of conformity that we are willing to satisfy, i.e., H1-conformity, and the region of the domain in which we want to (strongly) impose Dirichlet boundary conditions, the whole boundary of the box in this case.</p><pre><code class="language-julia">Vₕ = FESpace(model,reffe;conformity=:H1,dirichlet_tags=&quot;boundary&quot;)
u(x) = x[1]            # Analytical solution (for Dirichlet data)
Uₕ = TrialFESpace(Vₕ,u)</code></pre><h2 id="The-CellDatum-abstract-type-and-(some-of)-its-subtypes-1"><a class="docs-heading-anchor" href="#The-CellDatum-abstract-type-and-(some-of)-its-subtypes-1">The <code>CellDatum</code> abstract type and (some of) its subtypes</a><a class="docs-heading-anchor-permalink" href="#The-CellDatum-abstract-type-and-(some-of)-its-subtypes-1" title="Permalink"></a></h2><p>We also want to extract the triangulation out of the model and create a numerical quadrature. We use a quadrature rule with a higher number integration points than those strictly needed to integrate a mass matrix exactly, i.e., <code>4*order</code>, instead of <code>2*order</code> We do so in order to help the reader distinguish the axis used for quadrature points, and the one used for DoFs in multi-dimensional arrays, which contain the result of evaluating fields (or a differential operator acting on these) in a set of quadrature rule evaluation points.</p><pre><code class="language-julia">Tₕ = Triangulation(model)
Qₕ = CellQuadrature(Tₕ,4*order)</code></pre><p>Qₕ is an instance of type <code>CellQuadrature</code>, a subtype of the <code>CellDatum</code> abstract data type.</p><pre><code class="language-julia">isa(Qₕ,CellDatum)

subtypes(CellDatum)</code></pre><p><code>CellDatum</code> is the root of one out of three main type hierarchies in Gridap (along with the ones rooted at the abstract types <code>Map</code> and <code>Field</code>) on which the evaluation of variational methods in finite-dimensional spaces is grounded on. Any developer of Gridap should familiarize with these three hierarchies to some extent. Along this tutorial we will give some insight on the rationale underlying these, with some examples, but more effort in the form of self-research is expected from the reader as well.</p><p>Conceptually, an instance of a <code>CellDatum</code> represents a collection of quantities (e.g., points in a reference system, or scalar-, vector- or tensor-valued fields, or arrays made of these), once per each cell of a triangulation. Using the <code>get_data</code> generic function one can extract an array with such quantities. For example, in the case of Qₕ, we get an array of quadrature rules for numerical integration.</p><pre><code class="language-julia">Qₕ_cell_data = get_data(Qₕ)</code></pre><pre><code class="language-julia">@test length(Qₕ_cell_data) == num_cells(Tₕ)</code></pre><p>In this case we get the same quadrature rule in all cells (note that the returned array is of type <code>Fill</code>). Gridap also supports different quadrature rules to be used in different cells. Exploring such feature is out of scope of the present tutorial.</p><p>Any <code>CellDatum</code> has a trait, the so-called <code>DomainStyle</code> trait. This information is consumed by <code>Gridap</code> in different parts of the code. It specifies whether the quantities in it are either expressed in the reference (<code>ReferenceDomain</code>) or the physical (<code>PhysicalDomain</code>) domain. We can indeed check the <code>DomainStyle</code> of a <code>CellDatum</code> using the <code>DomainStyle</code> generic function:</p><pre><code class="language-julia">DomainStyle(Qₕ) == ReferenceDomain()</code></pre><pre><code class="language-julia">DomainStyle(Qₕ) == PhysicalDomain()</code></pre><p>If we evaluate the two expressions above, we can see that the <code>DomainStyle</code> trait of Qₕ is <code>ReferenceDomain</code>. This means that the local FE space in the physical space in which our problem is posed is expressed in terms of the composition of a space in a reference FE in a parametric space (which is being shared by many or all FEs in the physical space) and the inverse of the geometrical map (from the parametric to the physical space).</p><p>In practise, the integration in the physical space is transformed into a numerical integration in the reference space (via a change of variables) using a quadrature. We can exploit this property for <code>ReferenceDomain</code> FE spaces to reduce computations, i.e., to avoid applying the geometrical map to the quadrature points within Qₕ and its inverse at the shape functions in the physical space.</p><p>We note that, while finite elements may not be defined in this parametric space (it is though standard practice with Lagrangian FEs, and other FEs, because of performance reasons), finite element functions are always integrated in such a parametric space. However, for FE spaces that are genuinely defined in the physical space, i.e., the ones with the <code>PhysicalDomain</code> trait, the transformation of quadrature points from the reference to the physical space is required.</p><p>In fact, the <code>DomainStyle</code> metadata of <code>CellDatum</code> allows <code>Gridap</code> to do the right thing (as soon as it is implemented) for all combinations of points and FE spaces (both either expressed in the reference or physical space). This is accomplished by the <code>change_domain</code> function in the API of <code>CellDatum</code>.</p><p>Using the array of quadrature rules <code>Qₕ_cell_data</code>, we can access specific entries. The object retrieved provides an array of points (<code>Point</code> data type in <code>Gridap</code>) in the cell reference parametric space <span>$[0,1]^d$</span> and their corresponding weights.</p><pre><code class="language-julia">q = Qₕ_cell_data[rand(1:num_cells(Tₕ))]</code></pre><pre><code class="language-julia">p = get_coordinates(q)</code></pre><pre><code class="language-julia">w = get_weights(q)</code></pre><p>However, there is a more convenient way (for reasons made clear above) to work with the evaluation points of quadratures rules in <code>Gridap</code>. Namely, using the <code>get_cell_points</code> function we can extract a <code>CellPoint</code> object out of a <code>CellQuadrature</code>.</p><pre><code class="language-julia">Qₕ_cell_point = get_cell_points(Qₕ)</code></pre><p><code>CellPoint</code> (just as <code>CellQuadrature</code>) is a subtype of <code>CellDatum</code> as well</p><pre><code class="language-julia">@test isa(Qₕ_cell_point, CellDatum)</code></pre><p>and thus we can ask for the value of its <code>DomainStyle</code> trait, and get an array of quantities out of it using the <code>get_data</code> generic function</p><pre><code class="language-julia">@test DomainStyle(Qₕ_cell_point) == ReferenceDomain()</code></pre><pre><code class="language-julia">qₖ = get_data(Qₕ_cell_point)</code></pre><p>Not surprisingly, the <code>DomainStyle</code> trait of the <code>CellPoint</code> object is <code>ReferenceDomain</code>, and we get a (cell) array with an array of <code>Point</code>s per each cell out of a <code>CellPoint</code>. As seen in the sequel, <code>CellPoint</code>s are relevant objects because they are the ones that one can use in order to evaluate the so-called <code>CellField</code> objects on the set of points of a <code>CellPoint</code>.</p><p><code>CellField</code> is an abstract type rooted at a hierarchy that plays a cornerstone role in the implementation of the finite element method in <code>Gridap</code>. At this point, the reader should keep in mind that the finite element method works with global spaces of functions which are defined piece-wise on each cell of the triangulation. In a nutshell (more in the sections below), a <code>CellField</code>, as it being a subtype of <code>CellDatum</code>, might be understood as a collection of <code>Field</code>s (or arrays made out them) per each triangulation cell. <code>Field</code> represents a <a href="https://simple.wikipedia.org/wiki/Field_(physics)">field</a>, e.g., a scalar, vector, or tensor field. Thus, the domain of a <code>Field</code> are points in the physical domain (represented by a type <code>Point</code> in <code>Gridap</code>, which is a <code>VectorValue</code> with a dimension matching that of the environment space) and the range is a scalar, vector (represented by <code>VectorValue</code>) or tensor (represented by <code>TensorValue</code>).</p><p>Unlike a plain array of <code>Field</code>s, a <code>CellField</code> is associated to a triangulation and is specifically designed having in mind FEs. For example, a global finite element function, or the collection of shape basis functions in the local FE space of each cell are examples of <code>CellField</code> objects. As commented above, these fields can be defined in the physical or a reference space (combined with a geometrical map provided by the triangulation object for each cell). Thus, <code>CellField</code> (as a sub-type of <code>CellDatum</code>) has the <code>DomainStyle</code> metadata that is used, e.g., for point-wise evaluations (as indicated above) of the fields and their derivatives (by implementing the transformations when taking a differential operators, e.g., the pull-back of the gradients).</p><h2 id="Exploring-our-first-CellField-objects-1"><a class="docs-heading-anchor" href="#Exploring-our-first-CellField-objects-1">Exploring our first <code>CellField</code> objects</a><a class="docs-heading-anchor-permalink" href="#Exploring-our-first-CellField-objects-1" title="Permalink"></a></h2><p>Let us work with our first <code>CellField</code> objects, namely <code>FEBasis</code> objects, and its evaluation. In particular, let us extract out of the global test space, Vₕ, and trial space, Uₕ, a collection of local test and trial finite element shape basis functions, respectively.</p><pre><code class="language-julia">dv = get_fe_basis(Vₕ)</code></pre><pre><code class="language-julia">du = get_trial_fe_basis(Uₕ)</code></pre><p>The objects returned are of <code>FEBasis</code> type, one of the subtypes of <code>CellField</code>. Apart from <code>DomainStyle</code>, <code>FEBasis</code> objects also have an additional trait, <code>BasisStyle</code>, which specifies whether the cell-local shape basis functions are either of test or trial type (in the Galerkin method). This information is consumed in different parts of the code.</p><pre><code class="language-julia">@test Gridap.FESpaces.BasisStyle(dv) == Gridap.FESpaces.TestBasis()</code></pre><pre><code class="language-julia">@test Gridap.FESpaces.BasisStyle(du) == Gridap.FESpaces.TrialBasis()</code></pre><p>As expected, <code>dv</code> is made out of test shape functions, and <code>du</code>, of trial shape functions. We can also confirm that both <code>dv</code> and <code>du</code> are <code>CellField</code> and <code>CellDatum</code> objects (i.e., recall that <code>FEBasis</code> is a subtype of <code>CellField</code>, and the latter is a subtype of <code>CellDatum</code>).</p><pre><code class="language-julia">@test isa(dv,CellField) &amp;&amp; isa(dv,CellDatum)</code></pre><pre><code class="language-julia">@test isa(du,CellField) &amp;&amp; isa(du,CellDatum)</code></pre><p>Thus, one may check the value of their <code>DomainStyle</code> trait.</p><pre><code class="language-julia">@test DomainStyle(dv) == ReferenceDomain()</code></pre><pre><code class="language-julia">@test DomainStyle(du) == ReferenceDomain()</code></pre><p>We can see that the <code>DomainStyle</code> of both <code>FEBasis</code> objects is <code>ReferenceDomain</code>. In the case of <code>CellField</code> objects, this specifies that the point coordinates on which we evaluate the cell-local shape basis functions should be provided in the parametric space of the reference cell (to avoid the need to use the inverse of the geometrical map). However, the output from evaluation, as usual in finite elements defined parametrically, is the cell-local shape function in the physical domain evaluated at the corresponding mapped point.</p><p>Recall from above that <code>CellField</code> objects are designed to be evaluated at <code>CellPoint</code> objects, and that we extracted a <code>CellPoint</code> object, <code>Qₕ_cell_point</code>, out of a <code>CellQuadrature</code>, of <code>ReferenceDomain</code> trait <code>DomainStyle</code>. Thus, we can evaluate <code>dv</code> and <code>du</code> at the quadrature rule evaluation points, on all cells, straight away as:</p><pre><code class="language-julia">dv_at_Qₕ = evaluate(dv,Qₕ_cell_point)</code></pre><pre><code class="language-julia">du_at_Qₕ = evaluate(du,Qₕ_cell_point)</code></pre><p>There are a pair of worth noting observations on the result of the previous two instructions. First, both <code>dv_at_Qₕ</code> and <code>du_at_Qₕ</code> are arrays of type <code>Fill</code> (i.e., a constant array that only stores the entry once) because we are using the same quadrature and reference FE for all cells. This (same entry) is justified by: (1) the local shape functions are evaluated at the same set of points in the reference cell parametric space for all cells (i.e., the quadrature rule points), and (2) the shape functions in physical space have these very same values at the corresponding mapped points in the physical space for all cells. Thus they provide the same entry for whatever index we provide.</p><pre><code class="language-julia">dv_at_Qₕ[rand(1:num_cells(Tₕ))]</code></pre><pre><code class="language-julia">du_at_Qₕ[rand(1:num_cells(Tₕ))]</code></pre><p>At this point, the reader may want to observe which object results from the evaluation of, e.g., <code>dv_at_Qₕ</code>, at a different set points for each cell (e.g. by building its own array of arrays of <code>Points</code>).</p><p>Going back to our example, any entry of <code>dv_at_Qₕ</code> is a rank-2 array of size 9x4 that provides in position <code>[i,j]</code> the j-th test shape function at the i-th quadrature rule evaluation point. On the other hand, any entry of <code>du_at_Qₕ</code> is a rank-3 array of size <code>9x1x4</code> that provides in position <code>[i,1,j]</code> the j-th trial shape function at the i-th quadrature point. The reader might be wondering why the rank of these two arrays are different. The rationale is that, by means of the Julia <a href="https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting">broadcasting</a> of the <code>*</code> operation on these two arrays, we get the 9x4x4 array where the <code>[i,j,k]</code> entry stores the product of the j-th test and k-th trial functions, both evaluated at the i-th quadrature point. If we sum over the <span>$i$</span>-index, we obtain part of the data required to compute the cell-local matrix that we assemble into the global matrix in order to get a mass matrix. For those readers more used to traditional finite element codes, the broadcast followed by the sum over i, provides the data required in order to implement the following triple standard for-nested loop:</p><pre><code class="language-none"> M[:,:]=0.0
 Loop over quadrature points i
   detJK_wi=det(JK)*w[i]
   Loop over shape test functions j
     Loop over shape trial functions k
        M[j,k]+=shape_test[i,j]*shape_trial[i,k]*detJK_wi</code></pre><p>where <code>det(JK)</code> represents the determinant of the reference-physical mapping of the current cell, and <code>w[i]</code> the quadrature rule weight corresponding to the i-th evaluation point. Using Julia built-in support for broadcasting, we can vectorize the full operation, and get much higher performance.</p><p>The highest-level possible way of performing the aforementioned broadcasted <code>*</code> is by building a &quot;new&quot; <code>CellField</code> instance by multiplying the two <code>FEBasis</code> objects, and then evaluating the resulting object at the points in <code>Qₕ_cell_point</code>. This is something common in <code>Gridap</code>. One can create new <code>CellField</code> objects out of existing ones, e.g., by performing operations among them, or by applying a differential operator, such as the gradient.</p><pre><code class="language-julia">dv_mult_du = du*dv</code></pre><pre><code class="language-julia">dv_mult_du_at_Qₕ = evaluate(dv_mult_du,Qₕ_cell_point)</code></pre><p>We can check that any entry of the resulting <code>Fill</code> array is the <code>9x4x4</code> array resulting from the broadcasted <code>*</code> of the two aforementioned arrays. In order to do so, we can use the so-called <code>Broadcasting(*)</code> <code>Gridap</code> <code>Map</code> (one of the cornerstones of <code>Gridap</code>).</p><p>A <code>Map</code> represents a (general) function (a.k.a. map or mapping) that takes elements in its domain and return elements in its range. A <code>Field</code> is a sub-type of <code>Map</code> for the particular domain and ranges of physical fields detailed above. Why do we need to define the <code>Map</code> type in <code>Gridap</code> instead of using the Julia <code>Function</code>? <code>Map</code> is essential for performance, as we will explain later on.</p><p>The <code>Map</code> below is a map that broadcasts the <code>*</code> operation. When applied to arrays of numbers, it essentially translates into the built-in Julia broadcast (check that below!). However, as we will see along the tutorial, such a <code>Map</code> can also be applied to, e.g., (cell) arrays of <code>Field</code>s (arrays of <code>Field</code>s, resp.) to build new (cell) arrays of <code>Fields</code> (arrays of <code>Field</code>s, resp.). This becomes extremely useful to build and evaluate discrete variational forms.</p><pre><code class="language-julia">m=Broadcasting(*)</code></pre><pre><code class="language-julia">A=evaluate(m,dv_at_Qₕ[rand(1:num_cells(Tₕ))],du_at_Qₕ[rand(1:num_cells(Tₕ))])</code></pre><pre><code class="language-julia">B=broadcast(*,dv_at_Qₕ[rand(1:num_cells(Tₕ))],du_at_Qₕ[rand(1:num_cells(Tₕ))])</code></pre><pre><code class="language-julia">@test all(A .≈ B)</code></pre><pre><code class="language-julia">@test all(A .≈ dv_mult_du_at_Qₕ[rand(1:num_cells(Tₕ))])</code></pre><p>Recall from above that <code>CellField</code> objects are also <code>CellDatum</code> objects. Thus, one can use the <code>get_data</code> generic function to extract, in an array, the collection of quantities, one per each cell of the triangulation, out of them. As one may expect, in the case of our <code>FEBasis</code> objects <code>dv</code> and <code>du</code> at hand, <code>get_data</code> returns a (cell) array of arrays of <code>Field</code> objects, i.e., the cell-local shape basis functions:</p><pre><code class="language-julia">dv_array = get_data(dv)</code></pre><pre><code class="language-julia">du_array = get_data(du)</code></pre><pre><code class="language-julia">@test isa(dv_array,AbstractVector{&lt;:AbstractVector{&lt;:Field}})</code></pre><pre><code class="language-julia">@test isa(du_array,AbstractVector{&lt;:AbstractArray{&lt;:Field,2}})</code></pre><pre><code class="language-julia">@test length(dv_array) == num_cells(Tₕ)</code></pre><pre><code class="language-julia">@test length(du_array) == num_cells(Tₕ)</code></pre><p>As expected, both <code>dv_array</code> and <code>du_array</code> are (<em>conceptually</em>) vectors (i.e, rank-1 arrays) with as many entries as cells. The concrete type of each vector differs, though, i.e., <code>Fill</code> and <code>LazyArray</code>, resp. (We will come back to <code>LazyArray</code>s below, as they play a fundamental role in the way in which the finite element method is implemented in <code>Gridap</code>.) For each cell, we have arrays of <code>Field</code> objects. Recall from above that <code>Map</code> and <code>Field</code> (with <code>Field</code> a subtype of <code>Map</code>), and <code>CellDatum</code> and <code>CellField</code> (with <code>CellField</code> a subtype of <code>CellDatum</code>) and the associated type hierarchies, are fundamental in <code>Gridap</code> for the implementation of variational methods in finite-dimensional spaces. <code>Field</code> conceptually represents a physical (scalar, vector, or tensor) field. <code>Field</code> objects can be evaluated at single <code>Point</code> objects (or at an array of them in one shot), and they return scalars (i.e., a sub-type of Julia <code>Number</code>), <code>VectorValue</code>, or <code>TensorValue</code> objects (or an array of them, resp.)</p><p>In order to evaluate a <code>Field</code> object at a <code>Point</code> object, or at an array of <code>Points</code>, we can use the <code>evaluate</code> generic function in its <code>API</code>. For example, the following statement</p><pre><code class="language-julia">ϕ₃ = dv_array[1][3]
evaluate(ϕ₃,[Point(0,0),Point(1,0),Point(0,1),Point(1,1)])</code></pre><p>evaluates the 3rd test shape function of the local space of the first cell at the 4 vertices of the cell (recall from above that, for the implementation of Lagrangian finite elements being used in this tutorial, shape functions are thought to be evaluated at point coordinates expressed in the parametric space of the reference cell). As expected, ϕ₃ evaluates to one at the 3rd vertex of the cell, and to zero at the rest of vertices, as ϕ₃ is the shape function associated to the Lagrangian node/ DOF located at the 3rd vertex. We can also evaluate all shape functions of the local space of the first cell (i.e., an array of <code>Field</code>s) at once at an array of <code>Points</code></p><pre><code class="language-julia">ϕ = dv_array[1]
evaluate(ϕ,[Point(0,0),Point(1,0),Point(0,1),Point(1,1)])</code></pre><p>As expected, we get the Identity matrix, as the shape functions of the local space have, by definition, the Kronecker delta property.</p><p>However, and here comes one of the main take-aways of this tutorial, in <code>Gridap</code>, (cell-wise) arrays of <code>Fields</code> (or arrays of <code>Fields</code>) are definitely NOT conceived to be evaluated following the approach that we used in the previous examples, i.e., by manually extracting the <code>Field</code> (array of <code>Field</code>s) corresponding to a cell, and then evaluating it (them) at a given set of <code>Point</code>s. Instead, one uses the <code>lazy_map</code> generic function, which combined with the <code>evaluate</code> function, represents the operation of walking over all cells, and evaluating the fields, cell by cell, as a whole. This is illustrated in the following piece of code:</p><pre><code class="language-julia">dv_array_at_qₖ = lazy_map(evaluate,dv_array,qₖ)</code></pre><pre><code class="language-julia">du_array_at_qₖ = lazy_map(evaluate,du_array,qₖ)</code></pre><p>We note that the results of these two expressions are equivalent to the ones of <code>evaluate(dv, Qₕ_cell_point)</code> and <code>evaluate(du,Qₕ_cell_point)</code>, resp. (check it!) In fact, these latter two expressions translate under the hood into the calls to <code>lazy_map</code> above. These calls to <code>lazy_map</code> return an array of the same length of the input arrays, with their i-th entry conceptually defined, e.g., as <code>evaluate(du_array[i],qₖ[i])</code> in the case of the second array. To be &quot;conceptually defined as&quot; does not mean that they are actually computed as <code>evaluate(du_array[i],qₖ[i])</code>. Indeed they don&#39;t, this would not be high performant.</p><p>You might now be wondering what the main point behind <code>lazy_map</code> is. <code>lazy_map</code> turns out to be a cornerstone in <code>Gridap</code>. (At this point, you may execute <code>methods(lazy_map)</code> to observe that a large amount of programming logic is devoted to it.) Let us try to answer it more abstractly now. However, this will be revisited along the tutorial with additional examples.</p><p><code>lazy_map</code> can be applied to a <code>Map</code> and an array or a set of arrays, all with the same layout, that provide at every entry the arguments of the map. It conceptually returns the array that results from applying the <code>Map</code> to the arguments in each index of the argument array(s). Usually, the resulting type is a <code>LazyArray</code>.</p><p>When the resulting <code>LazyArray</code> entries are also <code>Map</code>s, one could <code>evaluate</code> the <code>LazyArray</code> on the array(s) that provide the argument(s) (i.e., its domain) using again a <code>lazy_map</code>. E.g., for the sub-type <code>Field</code>, one can create an array of fields, e.g., cell shape function, apply a <code>Map</code> over this array, e.g., a scaling of the shape functions, using <code>lazy_map</code>. The resulting array (conceptually also an array of <code>Field</code>s) can be evaluated in a set of points applying <code>evaluate</code> using <code>lazy_map</code>, as in the two code lines above.</p><p>These lazy objects are cornerstones of <code>Gridap</code> for the following reasons:</p><ol><li><p>To keep memory allocation (and consumption) at very low levels, <code>lazy_map</code> NEVER returns an array that stores the result at all cells at once. In the two examples above, this is achieved using <code>Fill</code> arrays. However, this is only possible in very particular scenarios (see discussion above). In more general cases, the array resulting from <code>lazy_map</code> does not have the same entry in all cells. In such cases, <code>lazy_map</code> returns a <code>LazyArray</code>, which is another essential component of <code>Gridap</code>. In a nutshell, a <code>LazyArray</code> is an array that applies entry-wise arrays of <code>Map</code>s (functions, operations) over array(s) that provide the <code>Map</code>s arguments. These operations are only computed when accessing the corresponding index, thus the name lazy. Besides, the entries of these are computed in an efficient way, using a set of mechanisms that will be illustrated below with examples (e.g., using cache to store the entry-wise data without the need to allocate memory each time we access the <code>LazyArray</code>).</p></li><li><p>Apart from <code>Function</code> objects, such as <code>evaluate</code>, <code>lazy_map</code> can also be used to apply <code>Map</code>s to arguments. For example, <code>Broadcasting(*)</code> presented above. A <code>Map</code> (or its sub-type <code>Field</code>) can be applied via <code>lazy_map</code> to other <code>Map</code>s (or arrays of <code>Map</code>s) to build a new <code>Map</code> (or array of <code>Map</code>s). Thus, the recursive application of <code>lazy_map</code> lets us build complex operation trees among arrays of <code>Map</code>s as the ones required for the implementation of variational forms. While building these trees, by virtue of Julia support for multiple type dispatching, there are plenty of opportunities for optimization by changing the order in which the operations are performed. These optimizations typically come in the form of a significant saving of FLOPs by exploiting the particular properties of the <code>Map</code>s at hand, but could also come from higher granularity for vectorized array operations when the expressions are actually evaluated. Indeed, the arrays that one usually obtains from <code>lazy_map</code> differ in some cases from the trivial <code>LazyArray</code>s that one would expect from a naive combination of the arguments to <code>lazy_map</code></p></li><li><p>Using <code>lazy_map</code> we are hiding thousands of cell loops across the code (as the one for the computation of the element matrices above). As a result, <code>Gridap</code> is much more expressive for cell-wise implementations.</p></li></ol><h2 id="Exploring-another-type-of-CellField-objects-1"><a class="docs-heading-anchor" href="#Exploring-another-type-of-CellField-objects-1">Exploring another type of <code>CellField</code> objects</a><a class="docs-heading-anchor-permalink" href="#Exploring-another-type-of-CellField-objects-1" title="Permalink"></a></h2><p>Let us now work with another type of <code>CellField</code> objects, the ones that are used to represent an arbitrary element of a global FE space of functions, i.e., a FE function. A global FE function can be understood conceptually as a collection of <code>Field</code>s, one per each cell of the triangulation. The <code>Field</code> corresponding to a cell represents the restriction of the global FE function to the cell. (Recall that in finite elements, global functions are defined piece-wise on each cell.) As we did in the previous section, we will explore, at different levels, how FE functions are evaluated. However, we will dig deeper into this by illustrating some of the aforementioned mechanisms on which <code>LazyArray</code> relies in order to efficiently implement the entry-wise application of an operation (or array of operations) to a set of input arrays.</p><p>Let us now build a FE function belonging to the global trial space of functions Uₕ, with <a href="https://docs.julialang.org/en/v1/stdlib/Random/#Base.rand">rand</a> free DOF values. Using <code>Gridap</code> higher-level API, this can be achieved as follows</p><pre><code class="language-julia">uₕ = FEFunction(Uₕ,rand(num_free_dofs(Uₕ)))</code></pre><p>As expected from the discussion above, the returned object is a <code>CellField</code> object:</p><pre><code class="language-julia">@test isa(uₕ,CellField)</code></pre><p>Thus, we can, e.g., query the value of its <code>DomainStyle</code> trait, that turns out to be <code>ReferenceDomain</code></p><pre><code class="language-julia">@test DomainStyle(uₕ) == ReferenceDomain()</code></pre><p>Thus, in order to evaluate the <code>Field</code> object that represents the restriction of the FE function to a given cell, we have to provide <code>Point</code>s in the parametric space of the reference cell, and we get the value of the FE function at the corresponding mapped <code>Point</code>s in the physical domain. This should not come as a surprise as we have that: (1) the restriction of the FE function to a given cell is mathematically defined as a linear combination of the local shape functions of the cell (with coefficients given by the values of the DOFs at the cell). (2) As observed in the previous section, the shape functions are such that their value at <code>Point</code>s that are mapped from the reference cell to the physical cell by the cell geometrical map can be simply be obtained by evaluating the corresponding shape function in the reference FE at the same <code>Point</code>s in the parametric space (without the need to compute the geometrical map and its inverse, i.e., exploiting the fact that the combination of this two is the identity map). This property is thus transferred to the FE function.</p><p>As FE functions are <code>CellField</code> objects, we can evaluate them at <code>CellPoint</code> objects. Let us do it at the points within <code>Qₕ_cell_point</code> (see above for a justification of why this is possible):</p><pre><code class="language-julia">uₕ_at_Qₕ = evaluate(uₕ,Qₕ_cell_point)</code></pre><p>We note that internally this is just the application of <code>evaluate</code> via <code>lazy_map</code> for the raw (i.e., without the <code>CellDatum</code> metadata) cell arrays of <code>uₕ</code> and <code>Qₕ_cell_point</code> (obtained via <code>get_data</code>). Internally, a <code>change_domain</code> is invoked if required, i.e., the two <code>CellDatum</code> do not have the same <code>DomainStyle</code> trait value (not the case here). You can check it by getting into this call using the VSCode debugger (write <code>@enter</code> at the beginning of the line and run it). In any case, we provide many more details below.</p><p>For the first time in this tutorial, we have obtained a cell array of type <code>LazyArray</code> from evaluating a <code>CellField</code> at a <code>CellPoint</code>.</p><pre><code class="language-julia">@test isa(uₕ_at_Qₕ,LazyArray)</code></pre><p>This makes sense as a finite element function restricted to a cell is, in general, different in each cell, i.e., it evaluates to different values at the quadrature rule evaluation points. In other words, the <code>Fill</code> array optimization that was performed for the evaluation of the cell-wise local shape functions <code>dv</code> and <code>du</code> does not apply here, and a <code>LazyArray</code> has to be used instead.</p><p>Although it is hard to understand the full concrete type name of <code>uₕ_at_Qₕ</code> at this time</p><pre><code class="language-julia">print(typeof(uₕ_at_Qₕ))</code></pre><p>we will dissect <code>LazyArray</code>s in this section up to an extent that will allow us to have a better grasp of it. By now, the most important thing for you to keep in mind is that <code>LazyArray</code>s objects encode a recipe to produce its entries just-in-time when they are accessed. They NEVER store all of its entries at once. Even if the expression <code>uₕ_at_Qₕ</code> typed in the REPL, (or inline evaluations in your code editor) show the array with all of its entries at once, don&#39;t get confused. This is because the Julia REPL is evaluating the array at all indices and collecting the result just for printing purposes.</p><p>Just as we did with <code>FEBasis</code>, we can extract an array of <code>Field</code> objects out of <code>uₕ_at_Qₕ</code>, as <code>uₕ_at_Qₕ</code> is also a <code>CellBasis</code> object.</p><pre><code class="language-julia">uₕ_array = get_data(uₕ)</code></pre><p>As expected, <code>uₕ_array</code> is (conceptually) a vector (i.e., rank-1 array) of <code>Field</code> objects.</p><pre><code class="language-julia">@test isa(uₕ_array,AbstractVector{&lt;:Field})</code></pre><p>Its concrete type is, though, <code>LazyArray</code></p><pre><code class="language-julia">@test isa(uₕ_array,Gridap.Fields.LazyArray)</code></pre><p>with full name, as above, of a certain complexity (to say the least):</p><pre><code class="language-julia">print(typeof(uₕ_array))</code></pre><p>As mentioned above, <code>lazy_map</code> returns <code>LazyArray</code>s in the most general scenarios. Thus, it is reasonable to think that <code>get_data(uₕ)</code> returns an array that has been built via <code>lazy_map</code>. (We advance now that this is indeed the case.) On the other hand, as <code>uₕ_array</code> is (conceptually) a vector (i.e., rank-1 array) of <code>Field</code> objects, this also tells us that the <code>lazy_map</code>/<code>LazyArray</code> pair does not only play a fundamental role in the evaluation of (e.g., cell) arrays of <code>Field</code>s on (e.g., cell) arrays of arrays of <code>Point</code>s, but also in building new cell arrays of <code>Field</code>s (i.e., the local restriction of a FE function to each cell) out of existing ones (i.e., the cell array with the local shape functions). In the words of the previous section, we can use <code>lazy_map</code> to build complex operation trees among arrays of <code>Field</code>s, as required by the computer implementation of variational methods.</p><p>The key question now is: what is the point behind <code>get_data(uₕ)</code> returning a <code>LazyArray</code> of <code>Field</code>s, and not just a plain Julia array of <code>Field</code>s? At the end of the day, <code>Field</code> objects themselves have very low memory demands, they only need to hold the necessary information to encode their action (evaluation) on a <code>Point</code>/array of <code>Point</code>s. This is in contrast to the evaluation of (e.g., cell) arrays of <code>Field</code>s (or arrays of <code>Field</code>s) at an array of <code>Point</code>s, which does consume a significantly allocation of memory (if all entries are to be stored at once in memory, and not by demand). The short answer is higher performance. Using <code>LazyArray</code>s to encode operation trees among cell arrays of <code>Field</code>s, we can apply optimizations when evaluating these operation trees that would not be possible if we just computed a plain array of <code>Field</code>s. If all this sounds quite abstract, (most probably it does), we are going to dig into this further in the rest of the section.</p><p>As mentioned above, <code>uₕ_array</code> can be conceptually seen as an array of <code>Field</code>s. Thus, if we access to a particular entry of it, we should get a <code>Field</code> object. (Although possible, this is not the way in which <code>uₕ_array</code> is conceived to be used, as was also mentioned in the previous section.) This is indeed confirmed when accessing, e.g., the third entry of <code>uₕ_array</code>:</p><pre><code class="language-julia">uₕ³ = uₕ_array[3]</code></pre><pre><code class="language-julia">@test isa(uₕ³,Field)</code></pre><p>The concrete type of <code>uₕ³</code> is <code>LinearCombinationField</code>. This type represents a <code>Field</code> defined as a linear combination of an existing vector of <code>Field</code>s. This sort of <code>Field</code>s can be built using the <code>linear_combination</code> generic function. Among its methods, there is one which takes (1) a vector of scalars (i.e., Julia <code>Number</code>s) with the coefficients of the expansion and (2) a vector of <code>Field</code>s as its two arguments, and returns a <code>LinearCombinationField</code> object. As mentioned above, this is the exact mathematical definition of a FE function restricted to a cell.</p><p>Let us manually build uₕ³. In order to do so, we can first use the <code>get_cell_dof_values</code> generic function, which extracts out of uₕ a cell array of arrays with the DOF values of uₕ restricted to all cells of the triangulation (defined from a conceptual point of view).</p><pre><code class="language-julia">Uₖ = get_cell_dof_values(uₕ)</code></pre><p>(The returned array turns to be of concrete type <code>LazyArray</code>, again to keep memory allocation low, but let us skip this detail for the moment.) If we restrict <code>Uₖ</code> and <code>dv_array</code> to the third cell</p><pre><code class="language-julia">Uₖ³ = Uₖ[3]</code></pre><pre><code class="language-julia">ϕₖ³ = dv_array[3]</code></pre><p>we get the two arguments that we need to invoke <code>linear_combination</code> in order to build our manually built version of uₕ³</p><pre><code class="language-julia">manual_uₕ³ = linear_combination(Uₖ³,ϕₖ³)</code></pre><p>We can double-check that <code>uₕ³</code> and <code>manual_uₕ³</code> are equivalent by evaluating them at the quadrature rule evaluation points, and comparing the result:</p><pre><code class="language-julia">@test evaluate(uₕ³,qₖ[3]) ≈ evaluate(manual_uₕ³,qₖ[3])</code></pre><p>Following this idea, we can go even further and manually build a plain Julia vector of <code>LinearCombinationField</code> objects as follows:</p><pre><code class="language-julia">manual_uₕ_array = [linear_combination(Uₖ[i],dv_array[i]) for i=1:num_cells(Tₕ)]</code></pre><p>And we can (lazily) evaluate this manually-built array of <code>Field</code>s at a cell array of arrays of <code>Point</code>s (i.e., at <code>qₖ</code>) using <code>lazy_map</code>:</p><pre><code class="language-julia">manual_uₕ_array_at_qₖ = lazy_map(evaluate,manual_uₕ_array,qₖ)</code></pre><p>The entries of the resulting array are equivalent to those of the array that we obtained from <code>Gridap</code> automatically, i.e., <code>uₕ_at_Qₕ</code></p><pre><code class="language-julia">@test all( uₕ_at_Qₕ .≈ manual_uₕ_array_at_qₖ )</code></pre><p>However, and here it comes the key of the discussion, the concrete types of <code>uₕ_at_Qₕ</code> and <code>manual_uₕ_array_at_qₖ</code> do not match.</p><pre><code class="language-julia">@test typeof(uₕ_at_Qₕ) != typeof(manual_uₕ_array_at_qₖ)</code></pre><p>This is because <code>evaluate(uₕ,Qₕ_cell_point)</code> does not follow the (naive) approach that we followed to build <code>manual_uₕ_array_at_qₖ</code>, but it instead calls <code>lazy_map</code> under the hood as follows</p><pre><code class="language-julia">uₕ_array_at_qₖ = lazy_map(evaluate,uₕ_array,qₖ)</code></pre><p>Now we can see that the types of <code>uₕ_array_at_qₖ</code> and <code>uₕ_at_Qₕ</code> match:</p><pre><code class="language-julia">@test typeof(uₕ_array_at_qₖ) == typeof(uₕ_at_Qₕ)</code></pre><p>Therefore, why <code>Gridap</code> does not build <code>manual_uₕ_array_at_qₖ</code>? what&#39;s wrong with it? Let us first try to answer this quantitatively. Let us assume that we want to sum all entries of a <code>LazyArray</code>. In the case of <code>LazyArray</code>s of arrays, this operation is only well-defined if the size of the arrays of all entries matches. This is the case of the <code>uₕ_array_at_qₖ</code> and <code>manual_uₕ_array_at_qₖ</code> arrays, as we have the same quadrature rule at all cells. We can write this function following the <code>Gridap</code> internals&#39; way.</p><pre><code class="language-julia">function smart_sum(a::LazyArray)
  cache=array_cache(a)             #Create cache out of a
  sum=copy(getindex!(cache,a,1))   #We have to copy the output
                                   #from get_index! to avoid array aliasing
  for i in 2:length(a)
    ai = getindex!(cache,a,i)      #Compute the i-th entry of a
                                   #re-using work arrays in cache
    sum .= sum .+ ai
  end
  sum
end</code></pre><p>The function uses the so-called &quot;cache&quot; of a <code>LazyArray</code>. In a nutshell, this cache can be thought as a place-holder of work arrays that can be re-used among different evaluations of the entries of the <code>LazyArray</code> (e.g., the work array in which the result of the computation of an entry of the array is stored.) This way, the code is more performant, as the cache avoids that these work arrays are created repeatedly when traversing the <code>LazyArray</code> and computing its entries. It turns out that <code>LazyArray</code>s are not the only objects in <code>Gridap</code> that (can) work with caches. <code>Map</code> and <code>Field</code> objects also provide caches for reusing temporary storage among their repeated evaluation on different arguments of the same types. (For the eager reader, the cache can be obtained out of a <code>Map</code>/<code>Field</code> with the <code>return_cache</code> abstract method; see also <code>return_type</code>, <code>return_value</code>, and <code>evaluate!</code> functions of the abstract API of <code>Map</code>s). When a <code>LazyArray</code> is created out of objects that in turn rely on caches (e.g., a <code>LazyArray</code> with entries defined as the entry-wise application of a <code>Map</code> to two <code>LazyArrays</code>), the caches of the latter objects are also handled by the former object, so that this scheme naturally accommodates top-down recursion, as per-required in the evaluation of complex operation trees among arrays of <code>Field</code>s, and their evaluation at a set of <code>Point</code>s. We warn the reader this is a quite complex mechanism. The reader is encouraged to follow with a debugger, step by step, the execution of the <code>smart_sum</code> function with the <code>LazyArray</code>s built above in order to gain some familiarity with this mechanism.</p><p>If we @time the <code>smart_sum</code> function with <code>uₕ_array_at_qₖ</code> and <code>manual_uₕ_array_at_qₖ</code></p><pre><code class="language-julia">smart_sum(uₕ_array_at_qₖ)        # Execute once before to neglect JIT-compilation time
smart_sum(manual_uₕ_array_at_qₖ) # Execute once before to neglect JIT-compilation time</code></pre><pre><code class="language-julia">@time begin
        for i in 1:100_000
         smart_sum(uₕ_array_at_qₖ)
        end
      end</code></pre><pre><code class="language-julia">@time begin
        for i in 1:100_000
          smart_sum(manual_uₕ_array_at_qₖ)
        end
      end</code></pre><p>we can observe that the array returned by <code>Gridap</code> can be summed in significantly less time, using significantly less allocations.</p><p>Let us try to answer the question now qualitatively. In order to do so, we can take a look at the structure of both <code>LazyArray</code>s using the <code>print_op_tree</code> function provided by <code>Gridap</code></p><pre><code class="language-julia">print_op_tree(uₕ_array_at_qₖ)</code></pre><pre><code class="language-julia">print_op_tree(manual_uₕ_array_at_qₖ)</code></pre><p>We can observe from the output of these calls the following:</p><ol><li><p><code>uₕ_array_at_qₖ</code> is a <code>LazyArray</code> whose entries are defined as the result of applying a <code>Fill</code> array of <code>LinearCombinationMap{Colon}</code> <code>Map</code>s to a <code>LazyArray</code> and a <code>Fill</code> array. The first array provides the FE function DOF values restricted to each cell, and the second the local basis shape functions evaluated at the quadrature points. As the shape functions in physical space have the same values in all cells at the corresponding mapped points in physical space, there is no need to re-evaluate them at each cell, we can evaluate them only once. And this is what the second <code>Fill</code> array stores as its unique entry, i.e., a matrix <code>M[i,j]</code> defined as the value of the j-th <code>Field</code> (i.e., shape function) evaluated at the i-th <code>Point</code>. <em>This is indeed the main optimization that <code>lazy_map</code> applies compared to our manual construction of <code>uₕ_array_at_qₖ</code>.</em> It is worth noting that, if <code>v</code> denotes the linear combination coefficients, and <code>M</code> the matrix resulting from the evaluation of an array of <code>Fields</code> at a set of <code>Points</code>, with <code>M[i,j]</code> being the value of the j-th <code>Field</code> evaluated at the i-th point, the evaluation of <code>LinearCombinationMap{Colon}</code> at <code>v</code> and <code>M</code> returns a vector <code>w</code> with <code>w[i]</code> defined as <code>w[i]=sum_k v[k]*M[i,k]</code>, i.e., the FE function evaluated at the i-th point. <code>uₕ_array_at_qₖ</code> handles the cache of <code>LinearCombinationMap{Colon}</code> (which holds internal storage for <code>w</code>) and that of the first <code>LazyArray</code>, so that when it retrieves the DOF values <code>v</code> of a given cell, and then applies <code>LinearCombinationMap{Colon}</code> to <code>v</code> and <code>M</code>, it does not have to allocate any temporary working arrays, but re-uses the ones stored in the different caches.</p></li><li><p><code>manual_uₕ_array_at_qₖ</code> is also a <code>LazyArray</code>, but structured rather differently to <code>uₕ_array_at_qₖ</code>. In particular, its entries are defined as the result of applying a plain array of <code>LinearCombinationField</code>s to a <code>Fill</code> array of <code>Point</code>s that holds the coordinates of the quadrature rule evaluation points in the parametric space of the reference cell (which are equivalent for all cells, thus the <code>Fill</code> array). The evaluation of a <code>LinearCombinationField</code> on a set of <code>Point</code>s ultimately depends on <code>LinearCombinationMap</code>. As seen in the previous point, the evaluation of this <code>Map</code> requires a vector <code>v</code> and a matrix <code>M</code>. <code>v</code> was built in-situ when building each <code>LinearCombinationField</code>, and stored within these instances. However, in contrast to <code>uₕ_array_at_qₖ</code>, <code>M</code> is not part of <code>manual_uₕ_array_at_qₖ</code>, and thus it has to be (re-)computed each time that we evaluate a new <code>LinearCombinationField</code> instance on a set of points. This is the main source of difference on the computation times observed. By eagerly constructing our array of <code>LinearCombinationField</code>s instead of deferring it until (lazy) evaluation via <code>lazy_map</code>, we lost optimization opportunities. We stress that <code>manual_uₕ_array_at_qₖ</code> also handles the cache of <code>LinearCombinationField</code> (that in turn handles the one of <code>LinearCombinationMap</code>), so that we do not need to allocate <code>M</code> at each cell, we re-use the space within the cache of <code>LinearCombinationField</code>.</p></li></ol><p>To conclude the section, we expect the reader to be convinced of the negative consequences in performance that an eager (early) evaluation of the entries of the array returned by a <code>lazy_map</code> call can have in performance. The leitmotif of <code>Gridap</code> is <em>laziness</em>. When building new arrays of <code>Field</code>s (or arrays of <code>Field</code>s), out of existing ones, or when evaluating them at a set of <code>Point</code>s, ALWAYS use <code>lazy_map</code>. This may expand across several recursion levels when building complex operation trees among arrays of <code>Field</code>s. The more we defer the actual computation of the entries of <code>LazyArray</code>s, the more optimizations will be available at the <code>Gridap</code>&#39;s disposal by re-arranging the order of operations via exploitation of the particular properties of the arrays at hand. And this is indeed what we are going to do in the rest of the tutorial, namely calling <code>lazy_map</code> to build new cell arrays out of existing ones, to end in a lazy cell array whose entries are the cell matrices and cell vectors contributions to the global linear system.</p><p>Let us, e.g., build Uₖ manually using this idea. First, we extract out of uₕ and Uₕ two arrays with the free and fixed (due to strong Dirichlet boundary conditions) DOF values of uₕ</p><pre><code class="language-julia">uₕ_free_dof_values = get_free_dof_values(uₕ)</code></pre><pre><code class="language-julia">uₕ_dirichlet_dof_values = get_dirichlet_dof_values(Uₕ)</code></pre><p>So far these are plain arrays, nothing is lazy. Then we extract out of Uₕ the global indices of the DOFs in each cell, the well-known local-to-global map in FE methods.</p><pre><code class="language-julia">σₖ = get_cell_dof_ids(Uₕ)</code></pre><p>Finally, we call lazy_map to build a <code>LazyArray</code>, whose entries, when computed, contain the global FE function DOFs restricted to each cell.</p><pre><code class="language-julia">m = Broadcasting(PosNegReindex(uₕ_free_dof_values,uₕ_dirichlet_dof_values))</code></pre><pre><code class="language-julia">manual_Uₖ = lazy_map(m,σₖ)</code></pre><p><code>PosNegReindex</code> is a <code>Map</code> that is built out of two vectors. We evaluate it at indices of array entries. When we give it a positive index, it returns the entry of the first vector corresponding to this index, and when we give it a negative index, it returns the entry of the second vector corresponding to the flipped-sign index. We can check this with the following expressions</p><pre><code class="language-julia">@test evaluate(PosNegReindex(uₕ_free_dof_values,uₕ_dirichlet_dof_values),3) == uₕ_free_dof_values[3]</code></pre><pre><code class="language-julia">@test evaluate(PosNegReindex(uₕ_free_dof_values,uₕ_dirichlet_dof_values),-7) == uₕ_dirichlet_dof_values[7]</code></pre><p>The <code>Broadcasting(op)</code> <code>Map</code> lets us, in this particular example, broadcast the <code>PosNegReindex(uₕ_free_dof_values,uₕ_dirichlet_dof_values)</code> <code>Map</code> to an array a global DOF ids, to obtain the corresponding cell DOF values. As regular, <code>Broadcasting(op)</code> provides a cache with the work array required to store its result. <code>LazyArray</code> uses this cache to reduce the number of allocations while computing its entries just-in-time. Please note that in <code>Gridap</code> we put negative labels to fixed DOFs and positive to free DOFs in σₖ, thus we use an array that combines σₖ with the two arrays of free and fixed DOF values accessing the right one depending on the index. But everything is lazy, only computed when accessing the array. As mentioned multiple times, laziness is one f the leitmotifs in Gridap, the other being immutability.</p><p>Immutability is a feature that comes from functional programming. An immutable object cannot be modified after created. Since objects cannot change, one does not require to track how they change, i.e., there is no need to design (and understand) state diagrams. A code that strictly sticks to this principle is much more readable. Due to laziness, <code>Gridap</code> objects are light-weight, and the (lazy) modification of existing (lazy) objects is highly efficient. You can find this action many times in the code above, in which we use <code>lazy_map</code> to perform actions over lazy objects (e.g., <code>LazyArray</code> or <code>Fill</code> arrays) to create new lazy objects. However, strictly conforming to immutability can be inefficient in some very specific scenarios. <code>Gridap</code> departs from immutability in the linear algebra part, since we want to re-use the memory allocation as much as possible for global arrays or symbolic/numeric factorisations in linear solvers.</p><h2 id="The-geometrical-model-1"><a class="docs-heading-anchor" href="#The-geometrical-model-1">The geometrical model</a><a class="docs-heading-anchor-permalink" href="#The-geometrical-model-1" title="Permalink"></a></h2><p>From the triangulation we can also extract the cell map, i.e., the geometrical map that takes points in the parametric space <span>$[0,1]^D$</span> (the <code>SEGMENT</code>, <code>QUAD</code>, or <code>HEX</code> in 1, 2, or 3D, resp.) and maps it to the cell in the physical space <span>$\Omega$</span>.</p><pre><code class="language-julia">ξₖ = get_cell_map(Tₕ)</code></pre><p>We note that this map is just a <code>LazyArray</code> of <code>Field</code>s. The metadata related to <code>CellField</code> is not required here, the cell map can only go from the reference to physical space, and its domain can only be a reference cell. For this reason, it is not a <code>CellField</code>.</p><p>The cell map takes at each cell points in the parametric space and returns the mapped points in the physical space. Even though this space does not need a global definition (nothing has to be solved here), it is continuous across interior faces.</p><p>As usual, this cell_map is a <code>LazyArray</code>. At each cell, it provides the <code>Field</code> that maps <code>Point</code>s in the parametric space of the reference cell to <code>Point</code>s in physical space.</p><p>The node coordinates can be extracted from the triangulation, returning a global array of <code>Point</code>s. You can see that such array is stored using Cartesian indices instead of linear indices. It is more natural for Cartesian meshes.</p><pre><code class="language-julia">X = get_node_coordinates(Tₕ)</code></pre><p>You can also extract a cell-wise array that provides the node indices per cell</p><pre><code class="language-julia">cell_node_ids = get_cell_node_ids(Tₕ)</code></pre><p>or the cell-wise nodal coordinates, combining the previous two arrays</p><pre><code class="language-julia">_Xₖ = get_cell_coordinates(Tₕ)</code></pre><h2 id="A-low-level-definition-of-the-cell-map-1"><a class="docs-heading-anchor" href="#A-low-level-definition-of-the-cell-map-1">A low-level definition of the cell map</a><a class="docs-heading-anchor-permalink" href="#A-low-level-definition-of-the-cell-map-1" title="Permalink"></a></h2><p>Now, let us create the geometrical map almost from scratch, using the concepts that we have learned so far. In this example, we consider that the geometry is represented with a bilinear map, and we thus use a first-order, scalar-valued FE space to represent the nodal coordinate values. To this end, as we did before with the global space of FE functions, we first need to create a Polytope using an array of dimension <code>D</code> with the parameter <code>HEX_AXIS</code>. Then, this is used to create the scalar first order Lagrangian reference FE.</p><pre><code class="language-julia">pol = Polytope(Fill(HEX_AXIS,D)...)
reffe_g = LagrangianRefFE(Float64,pol,1)</code></pre><p>Next, we extract the basis of shape functions out of this Reference FE, which is a set of <code>Field</code>s, as many as shape functions. We note that these <code>Field</code>s have as domain the parametric space <span>$[0,1]^D$</span>. Thus, they can readily be evaluated for points in the parametric space.</p><pre><code class="language-julia">ϕrg = get_shapefuns(reffe_g)</code></pre><p>Now, we create a global cell array that has the same reference FE basis for all cells.</p><pre><code class="language-julia">ϕrgₖ = Fill(ϕrg,num_cells(Tₕ))</code></pre><p>Next, we use <code>lazy_map</code> to build a <code>LazyArray</code> that provides the coordinates of the nodes of each cell in physical space. To this end, we use the <code>Broadcasting(Reindex(X))</code> and apply it to <code>cell_node_ids</code>.</p><pre><code class="language-julia">Xₖ = lazy_map(Broadcasting(Reindex(X)),cell_node_ids)</code></pre><p><code>Reindex</code> is a <code>Map</code> that is built out of a single vector, <code>X</code> in this case. We evaluate it at indices of array entries, and it just returns the entry of the vector from which it is built corresponding to this index. We can check this with the following expressions:</p><pre><code class="language-julia">@test evaluate(Reindex(X),3) == X[3]</code></pre><p>If we combine <code>Broadcasting</code> and <code>Reindex</code>, then we can evaluate efficiently the <code>Reindex</code> <code>Map</code> at arrays of node ids, i.e., at each of the entries of <code>cell_node_ids</code>. <code>lazy_map</code> is used for reasons hopefully clear at this point (low memory consumption, efficient computation of the entries via caches, further opportunities for optimizations when combined with other <code>lazy_map</code> calls, etc.). Finally, we can check that <code>Xₖ</code> is equivalent to the array returned by <code>Gridap</code>, i.e, <code>_Xₖ</code></p><pre><code class="language-julia">@test Xₖ == _Xₖ == get_cell_coordinates(Tₕ) # check</code></pre><p>Next, we can compute the geometrical map as the linear combination of these shape functions in the parametric space with the node coordinates (at each cell)</p><pre><code class="language-julia">ψₖ = lazy_map(linear_combination,Xₖ,ϕrgₖ)</code></pre><p>This is the mathematical definition of the geometrical map in FEs! (see above for a description of the <code>linear_combination</code> generic function). As expected, the FE map that we have built manually is equivalent to the one internally built by <code>Gridap</code>.</p><pre><code class="language-julia">@test lazy_map(evaluate,ψₖ,qₖ) == lazy_map(evaluate,ξₖ,qₖ) # check</code></pre><p>It is good to stress (if it was not fully grasped yet) that <code>lazy_map(k,a,b)</code>, with <code>k</code> being a callable Julia object, is semantically (conceptually) equivalent to <code>map(k,a,b)</code> but, among others, with a lazy result instead of a plain Julia array. A Julia object is callable if it makes sense to pass arguments to it. For example, objects <code>k</code> such that <code>isa(k,Map)==true</code> are callable.  For these objects, <code>k(x...)</code> is equivalent to <code>evaluate(k,x...)</code>.</p><p>Following the same ideas, we can compute the Jacobian of the geometrical map (cell-wise). The Jacobian of the transformation is simply its gradient. The gradient in the parametric space can be built using two equivalent approaches. On the one hand, we can apply the <code>Broadcasting(∇)</code> <code>Map</code> to the array of <code>Fields</code> with the local shape basis functions (i.e., <code>ϕrg</code>). This results in an array of <code>Field</code>s with the gradients, (Recall that <code>Map</code>s can be applied to array of <code>Field</code>s in order to get new array of <code>Field</code>s) that we use to build a <code>Fill</code> array with the result. Finally, we build the lazy array with the cell-wise Jacobians of the map as the linear combination of the node coordinates and the gradients of the local cell shape basis functions:</p><pre><code class="language-julia">∇ϕrg  = Broadcasting(∇)(ϕrg)</code></pre><pre><code class="language-julia">∇ϕrgₖ = Fill(∇ϕrg,num_cells(model))</code></pre><pre><code class="language-julia">J = lazy_map(linear_combination,Xₖ,∇ϕrgₖ)</code></pre><p>We note that <code>lazy_map</code> is not required in the first expression, as we are not actually working with cell arrays. On the other hand, using <code>lazy_map</code>, we can apply <code>Broadcasting(∇)</code> to the cell array of <code>Field</code>s with the geometrical map.</p><pre><code class="language-julia">lazy_map(Broadcasting(∇),ψₖ)</code></pre><p>As mentioned above, those two approaches are equivalent</p><pre><code class="language-julia">@test typeof(J) == typeof(lazy_map(Broadcasting(∇),ψₖ))</code></pre><pre><code class="language-julia">@test lazy_map(evaluate,J,qₖ) == lazy_map(evaluate,lazy_map(Broadcasting(∇),ψₖ),qₖ)</code></pre><h2 id="Computing-the-gradients-of-the-trial-and-test-FE-space-bases-1"><a class="docs-heading-anchor" href="#Computing-the-gradients-of-the-trial-and-test-FE-space-bases-1">Computing the gradients of the trial and test FE space bases</a><a class="docs-heading-anchor-permalink" href="#Computing-the-gradients-of-the-trial-and-test-FE-space-bases-1" title="Permalink"></a></h2><p>Another salient feature of Gridap is that we can directly take the gradient of finite element bases. (In general, of any <code>CellField</code> object.) In the following code snippet, we do so for <code>dv</code> and <code>du</code></p><pre><code class="language-julia">grad_dv = ∇(dv)</code></pre><pre><code class="language-julia">grad_du = ∇(du)</code></pre><p>The result of this operation when applied to a <code>FEBasis</code> object is a new <code>FEBasis</code> object.</p><pre><code class="language-julia">@test isa(grad_dv, Gridap.FESpaces.FEBasis)</code></pre><pre><code class="language-julia">@test isa(grad_du, Gridap.FESpaces.FEBasis)</code></pre><p>We can also extract an array of arrays of <code>Fields</code>, as we have done before with <code>FEBasis</code> objects.</p><pre><code class="language-julia">grad_dv_array = get_data(grad_dv)</code></pre><pre><code class="language-julia">grad_du_array = get_data(grad_du)</code></pre><p>The resulting <code>LazyArray</code>s encode the so-called pull back transformation of the gradients. We need this transformation in order to compute the gradients in physical space. The gradients in physical space are indeed the ones that we need to integrate in the finite element method, not the reference ones, even if we always evaluate the integrals in the parametric space of the reference cell. We can also check that the <code>DomainStyle</code> trait of <code>grad_dv</code> and <code>grad_du</code> is <code>ReferenceDomain</code></p><pre><code class="language-julia">@test DomainStyle(grad_dv) == ReferenceDomain()</code></pre><pre><code class="language-julia">@test DomainStyle(grad_du) == ReferenceDomain()</code></pre><p>This should not come as a surprise, as this is indeed the nature of the pull back transformation of the gradients. We provide <code>Point</code>s in the parametric space of the reference cell, and we get back the gradients in physical space evaluated at the mapped <code>Point</code>s in physical space.</p><p>We can manually build <code>grad_dv_array</code> and <code>grad_du_array</code> as follows</p><pre><code class="language-julia">ϕr                   = get_shapefuns(reffe)
∇ϕr                  = Broadcasting(∇)(ϕr)
∇ϕrₖ                 = Fill(∇ϕr,num_cells(Tₕ))
manual_grad_dv_array = lazy_map(Broadcasting(push_∇),∇ϕrₖ,ξₖ)</code></pre><pre><code class="language-julia">∇ϕrᵀ                 = Broadcasting(∇)(transpose(ϕr))
∇ϕrₖᵀ                = Fill(∇ϕrᵀ,num_cells(Tₕ))
manual_grad_du_array = lazy_map(Broadcasting(push_∇),∇ϕrₖᵀ,ξₖ)</code></pre><p>We note the use of the <code>Broadcasting(push_∇)</code> <code>Map</code> at the last step. For Lagrangian FE spaces, this <code>Map</code> represents the pull back of the gradients. This transformation requires the gradients of the shape functions in the reference space, and the (gradient of the) geometrical map. The last step, e.g., the construction of <code>manual_grad_dv_array</code>, actually translates into the combination of the following calls to <code>lazy_map</code> to build the final transformation:</p><p>Build array of <code>Field</code>s with the Jacobian transposed at each cell</p><pre><code class="language-julia">Jt     = lazy_map(Broadcasting(∇),ξₖ)</code></pre><p>Build array of <code>Field</code>s with the inverse of the Jacobian transposed at each cell</p><pre><code class="language-julia">inv_Jt = lazy_map(Operation(inv),Jt)</code></pre><p>Build array of arrays of <code>Field</code>s defined as the broadcasted single contraction of the Jacobian inverse transposed and the gradients of the shape functions in the reference space</p><pre><code class="language-julia">low_level_manual_gradient_dv_array = lazy_map(Broadcasting(Operation(⋅)),inv_Jt,∇ϕrₖ)</code></pre><p>As always, we check that all arrays built are are equivalent</p><pre><code class="language-julia">@test typeof(grad_dv_array) == typeof(manual_grad_dv_array)</code></pre><pre><code class="language-julia">@test lazy_map(evaluate,grad_dv_array,qₖ) == lazy_map(evaluate,manual_grad_dv_array,qₖ)</code></pre><pre><code class="language-julia">@test lazy_map(evaluate,grad_dv_array,qₖ) == lazy_map(evaluate,low_level_manual_gradient_dv_array,qₖ)</code></pre><pre><code class="language-julia">@test lazy_map(evaluate,grad_dv_array,qₖ) == evaluate(grad_dv,Qₕ_cell_point)</code></pre><p>With the lessons learned so far in this section, it is left as an exercise for the reader to manually build the array that <code>get_data</code> returns when we call it with the <code>CellField</code> object resulting from taking the gradient of uₕ as an argument, i.e., <code>get_data(∇(uₕ))</code>.</p><h2 id="A-low-level-implementation-of-the-residual-integration-and-assembly-1"><a class="docs-heading-anchor" href="#A-low-level-implementation-of-the-residual-integration-and-assembly-1">A low-level implementation of the residual integration and assembly</a><a class="docs-heading-anchor-permalink" href="#A-low-level-implementation-of-the-residual-integration-and-assembly-1" title="Permalink"></a></h2><p>In the rest of the tutorial we aim to solve a Poisson equation with homogeneous source term, i.e., <span>$f=0$</span> and non-homogeneous Dirichlet boundary conditions <span>$u=g_0$</span> on <span>$\Gamma_D$</span>, with  <span>$\Gamma_D$</span> being the whole boundary of the model. While the strong imposition of non-homogeneous Dirichlet boundary conditions in Gridap is done under the hood by modifying the global assembly process by subtracting the contributions of boundary conditions from the right hand side of the linear system, in this tutorial, for simplicity, we follow a different approach. This approach requires: (1) to be able to assemble the residual of the PDE for an arbitrary finite element function <span>$\hat{u}_h$</span> (current section); (2) to be able to assemble the coefficient matrix of the finite element linear system (next section). We briefly outline this solution approach in the sequel.</p><p>The discretized variational form of the Poisson problem reads as:</p><blockquote><p>Find <span>$u_h \in V_h^{\Gamma_D}=\{v_h \in V_h:v_h=g^h_0 \; on \; \Gamma_D\}$</span> such that</p><div>\[a(u_h,v_h)=l(v_h)\quad \forall v_h \in V_h^0\]</div><p>where <span>$V_h^0=\{v_h \in V_h:v_h=0 \; on \; \Gamma_D\}$</span> and <span>$g^h_0$</span> is the interpolation of <span>$g_0$</span> on the Dirichlet boundary.</p></blockquote><p>If we take an arbitrary function <span>$\hat{u}_h \in V_h^{\Gamma_D}$</span>, and compute <span>$w_h \in V_h^0$</span> as the solution of the following discrete variational problem:</p><div>\[a(w_h,v_h)=a(\hat{u}_h,v_h)-l(v_h)\quad \forall v_h,w_h \in V_h^0,\]</div><p>then, it is easy to see that <span>$\mathbf{ u_h=\hat{u}_h-w_h }$</span>. This is the strategy that we implement in the sequel. Note that, in previous section, we created a FE function using <code>rand</code> for initializing the values of the degrees of freedom. This function indeed plays the role of <span>$\hat{u}_h$</span>.</p><p>Let us now create manually an array of <code>Field</code>s uₖ that returns the FE function uₕ at each cell, and another array with its gradients, ∇uₖ. We hope that the next set of instructions can be already understood with the material covered so far</p><pre><code class="language-julia">ϕrₖ = Fill(ϕr,num_cells(Tₕ))</code></pre><pre><code class="language-julia">∇ϕₖ = manual_grad_dv_array</code></pre><pre><code class="language-julia">uₖ  = lazy_map(linear_combination,Uₖ,ϕrₖ)</code></pre><pre><code class="language-julia">∇uₖ = lazy_map(linear_combination,Uₖ,∇ϕₖ)</code></pre><p>Let us consider now the integration of (bi)linear forms. The idea is to compute first the following residual for our random function uₕ</p><pre><code class="language-julia">intg = ∇(uₕ)⋅∇(dv)</code></pre><p>but we are going to do it using low-level methods instead.</p><p>First, we create an array that for each cell returns the dot product of the gradients</p><pre><code class="language-julia">Iₖ = lazy_map(Broadcasting(Operation(⋅)),∇uₖ,∇ϕₖ)</code></pre><p>This array is equivalent to the one within the <code>intg</code> <code>CellField</code> object</p><pre><code class="language-julia">@test all(lazy_map(evaluate,Iₖ,qₖ) .≈ lazy_map(evaluate,get_data(intg),qₖ))</code></pre><p>Now, we can finally compute the cell-wise residual array, which using the high-level <code>integrate</code> function is</p><pre><code class="language-julia">res = integrate(∇(uₕ)⋅∇(dv),Qₕ)</code></pre><p>In a low-level, what we do is to apply (create a <code>LazyArray</code>) the <code>IntegrationMap</code> <code>Map</code> over the integrand evaluated at the integration points, the quadrature rule weights, and the Jacobian evaluated at the integration points</p><pre><code class="language-julia">Jq = lazy_map(evaluate,J,qₖ)
intq = lazy_map(evaluate,Iₖ,qₖ)
iwq = lazy_map(IntegrationMap(),intq,Qₕ.cell_weight,Jq)</code></pre><pre><code class="language-julia">@test all(res .≈ iwq)</code></pre><p>The result is the cell-wise residual (previous to assembly). This is a lazy array but you could collect the element residuals into a plain Julia array if you want</p><pre><code class="language-julia">collect(iwq)</code></pre><p>Alternatively, we can use the following syntactic sugar</p><pre><code class="language-julia">cellvals = ∫( ∇(dv)⋅∇(uₕ) )*Qₕ</code></pre><p>and check that we get the same cell-wise residual as the one defined above</p><pre><code class="language-julia">@test all(cellvals .≈ iwq)</code></pre><h2 id="Assembling-a-residual-1"><a class="docs-heading-anchor" href="#Assembling-a-residual-1">Assembling a residual</a><a class="docs-heading-anchor-permalink" href="#Assembling-a-residual-1" title="Permalink"></a></h2><p>Now, we need to assemble these cell-wise (lazy) residual contributions in a global (non-lazy) array. With all this, we can assemble our vector using the cell-wise residual contributions and the assembler. Let us create a standard assembler struct for the finite element spaces at hand. This will create a vector of size global number of DOFs, and a <code>SparseMatrixCSC</code>, to which we can add contributions.</p><pre><code class="language-julia">assem = SparseMatrixAssembler(Uₕ,Vₕ)</code></pre><p>We create a tuple with 1-entry arrays with the cell vectors (i.e., <code>iwq</code>) and cell-wise global DOF identifiers (i.e., <code>σₖ</code>). If we had additional terms, we would have more entries in the array. You can take a look at the <code>SparseMatrixAssembler</code> struct for more details.</p><pre><code class="language-julia">rs = ([iwq],[σₖ])</code></pre><pre><code class="language-julia">b = allocate_vector(assem,rs)</code></pre><pre><code class="language-julia">assemble_vector!(b,assem,rs)</code></pre><h2 id="A-low-level-implementation-of-the-Jacobian-integration-and-assembly-1"><a class="docs-heading-anchor" href="#A-low-level-implementation-of-the-Jacobian-integration-and-assembly-1">A low-level implementation of the Jacobian integration and assembly</a><a class="docs-heading-anchor-permalink" href="#A-low-level-implementation-of-the-Jacobian-integration-and-assembly-1" title="Permalink"></a></h2><p>After computing the residual, we use similar ideas for the Jacobian. The process is the same as above, so it does not require additional explanations</p><pre><code class="language-julia">∇ϕₖᵀ = manual_grad_du_array
int = lazy_map(Broadcasting(Operation(⋅)),∇ϕₖ,∇ϕₖᵀ)</code></pre><pre><code class="language-julia">@test all(collect(lazy_map(evaluate,int,qₖ)) .==
            collect(lazy_map(evaluate,get_data(∇(du)⋅∇(dv)),qₖ)))</code></pre><pre><code class="language-julia">intq = lazy_map(evaluate,int,qₖ)
Jq = lazy_map(evaluate,J,qₖ)
iwq = lazy_map(IntegrationMap(),intq,Qₕ.cell_weight,Jq)</code></pre><pre><code class="language-julia">jac = integrate(∇(dv)⋅∇(du),Qₕ)</code></pre><pre><code class="language-julia">@test collect(iwq) == collect(jac)</code></pre><pre><code class="language-julia">rs = ([iwq],[σₖ],[σₖ])</code></pre><pre><code class="language-julia">A = allocate_matrix(assem,rs)</code></pre><pre><code class="language-julia">A = assemble_matrix!(A,assem,rs)</code></pre><p>Now we can obtain the free DOFs by subtracting the solution from the initial guess</p><pre><code class="language-julia">x = A \ b
uf = get_free_dof_values(uₕ) - x
ufₕ = FEFunction(Uₕ,uf)</code></pre><pre><code class="language-julia">@test sum(integrate((u-ufₕ)*(u-ufₕ),Qₕ)) &lt;= 10^-8</code></pre><p>or if you like Unicode symbols</p><pre><code class="language-julia">@test ∑(∫(((u-ufₕ)*(u-ufₕ)))Qₕ) &lt;= 10^-8</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t025_lagrange_multipliers/">« 25 Lagrange multipliers</a><a class="docs-footer-nextpage" href="../t027_geometry_dev/">27 Low-level API - Geometry »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 1 September 2025 22:01">Monday 1 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
