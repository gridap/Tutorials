<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>27 Low-level API - Geometry · Gridap tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gridap tutorials logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap tutorials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="tocitem" href="../t002_validation/">2 Code validation</a></li><li><a class="tocitem" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="tocitem" href="../t004_p_laplacian/">4 p-Laplacian</a></li><li><a class="tocitem" href="../t005_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="tocitem" href="../t006_dg_discretization/">6 Poisson equation (with DG)</a></li><li><a class="tocitem" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="tocitem" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li><li><a class="tocitem" href="../t009_stokes/">9 Stokes equation</a></li><li><a class="tocitem" href="../t010_advection_diffusion/">10 Advection-diffusion</a></li><li><a class="tocitem" href="../t011_isotropic_damage/">11 Isotropic damage model</a></li><li><a class="tocitem" href="../t012_fsi_tutorial/">12 Fluid-Structure Interaction</a></li><li><a class="tocitem" href="../t013_emscatter/">13 Electromagnetic scattering in 2D</a></li><li><a class="tocitem" href="../t014_validation_DrWatson/">14 On using DrWatson.jl</a></li><li><a class="tocitem" href="../t015_interpolation_fe/">15 Interpolation of CellFields</a></li><li><a class="tocitem" href="../t016_poisson_distributed/">16 Poisson equation on parallel distributed-memory computers</a></li><li><a class="tocitem" href="../t017_transient_linear/">17 Transient Poisson equation</a></li><li><a class="tocitem" href="../t018_transient_nonlinear/">18 Transient nonlinear equation</a></li><li><a class="tocitem" href="../t019_TopOptEMFocus/">19 Topology optimization</a></li><li><a class="tocitem" href="../t020_poisson_unfitted/">20 Poisson on unfitted meshes</a></li><li><a class="tocitem" href="../t021_poisson_amr/">21 Poisson with AMR</a></li><li><a class="tocitem" href="../t022_poisson_hdg/">22 Poisson with HDG</a></li><li><a class="tocitem" href="../t023_poisson_hho/">23 Poisson with HHO on polytopal meshes</a></li><li><a class="tocitem" href="../t024_stokes_blocks/">24 Block assembly and solvers: Incompressible Stokes example</a></li><li><a class="tocitem" href="../t025_lagrange_multipliers/">25 Lagrange multipliers</a></li><li><a class="tocitem" href="../t026_poisson_dev_fe/">26 Low-level API - Poisson equation</a></li><li class="is-active"><a class="tocitem" href>27 Low-level API - Geometry</a><ul class="internal"><li><a class="tocitem" href="#Required-Packages-1"><span>Required Packages</span></a></li><li><a class="tocitem" href="#Table-of-Contents-1"><span>Table of Contents</span></a></li><li><a class="tocitem" href="#.-Utility-Functions-1"><span>1. Utility Functions</span></a></li><li><a class="tocitem" href="#.-The-DiscreteModel-Structure-1"><span>2. The DiscreteModel Structure</span></a></li><li><a class="tocitem" href="#.-Working-with-Topology-1"><span>3. Working with Topology</span></a></li><li><a class="tocitem" href="#.-Geometric-Mappings-1"><span>4. Geometric Mappings</span></a></li><li><a class="tocitem" href="#.-High-order-Grids-1"><span>5. High-order Grids</span></a></li><li><a class="tocitem" href="#.-Periodicity-in-Gridap-1"><span>6. Periodicity in Gridap</span></a></li><li><a class="tocitem" href="#.-FaceLabelings-and-boundary-conditions-1"><span>7. FaceLabelings and boundary conditions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>27 Low-level API - Geometry</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>27 Low-level API - Geometry</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Tutorials/blob/master/src/geometry_dev.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="geometry_dev.jl-1"><a class="docs-heading-anchor" href="#geometry_dev.jl-1">Tutorial 27: Low-level API - Geometry</a><a class="docs-heading-anchor-permalink" href="#geometry_dev.jl-1" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=dev/notebooks/t027_geometry_dev.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/dev/notebooks/t027_geometry_dev.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will learn</p><ul><li>How the <code>DiscreteModel</code> and its components work.</li><li>How to extract topological information from a <code>GridTopology</code>.</li><li>How to extract geometrical information from a <code>Grid</code>.</li><li>How periodicity is handled in Gridap, and the difference between nodes and vertices.</li><li>How to create a periodic model from scratch, use the example of a Mobius strip.</li><li>How to create and manipulate <code>FaceLabeling</code> objects, which are used to handle boundary conditions.</li></ul><h2 id="Required-Packages-1"><a class="docs-heading-anchor" href="#Required-Packages-1">Required Packages</a><a class="docs-heading-anchor-permalink" href="#Required-Packages-1" title="Permalink"></a></h2><pre><code class="language-julia">using Gridap
using Gridap.Geometry, Gridap.ReferenceFEs, Gridap.Arrays
using Plots</code></pre><h2 id="Table-of-Contents-1"><a class="docs-heading-anchor" href="#Table-of-Contents-1">Table of Contents</a><a class="docs-heading-anchor-permalink" href="#Table-of-Contents-1" title="Permalink"></a></h2><ol><li>Utility Functions</li><li>The DiscreteModel Structure</li><li>Working with Topology</li><li>Geometric Mappings</li><li>High-order Grids</li><li>Periodicity in Gridap</li><li>FaceLabelings</li></ol><h2 id=".-Utility-Functions-1"><a class="docs-heading-anchor" href="#.-Utility-Functions-1">1. Utility Functions</a><a class="docs-heading-anchor-permalink" href="#.-Utility-Functions-1" title="Permalink"></a></h2><p>We begin by defining helper functions that will be essential throughout this tutorial. These functions help us visualize and work with our mesh structures.</p><p>Convert a <code>CartesianDiscreteModel</code> to an <code>UnstructuredDiscreteModel</code> for more generic handling.</p><pre><code class="language-julia">function cartesian_model(args...; kwargs...)
  UnstructuredDiscreteModel(CartesianDiscreteModel(args...; kwargs...))
end</code></pre><p>Visualization function to plot nodes with their IDs. Input:</p><ul><li>node_coords: Array of node coordinates.</li><li>node_ids: Array of corresponding node IDs.</li></ul><pre><code class="language-julia">function plot_node_numbering(node_coords, node_ids)
  x = map(c -&gt; c[1], node_coords)
  y = map(c -&gt; c[2], node_coords)
  a = text.(node_ids, halign=:left, valign=:bottom)
  scatter(x, y, series_annotations = a, legend=false)
  hline!(unique(x), linestyle=:dash, color=:grey)
  vline!(unique(y), linestyle=:dash, color=:grey)
end</code></pre><p>Overloaded method to plot node numbering directly from a model. This function extracts the necessary information from the model and calls the base plotting function.</p><pre><code class="language-julia">function plot_node_numbering(model)
  D = num_cell_dims(model)
  topo = get_grid_topology(model)
  node_coords = Geometry.get_node_coordinates(model)
  cell_node_ids = get_cell_node_ids(model)
  cell_vertex_ids = Geometry.get_faces(topo, D, 0)

  node_to_vertex = zeros(Int, length(node_coords))
  for (nodes,vertices) in zip(cell_node_ids, cell_vertex_ids)
    node_to_vertex[nodes] .= vertices
  end

  plot_node_numbering(node_coords, node_to_vertex)
end</code></pre><h2 id=".-The-DiscreteModel-Structure-1"><a class="docs-heading-anchor" href="#.-The-DiscreteModel-Structure-1">2. The DiscreteModel Structure</a><a class="docs-heading-anchor-permalink" href="#.-The-DiscreteModel-Structure-1" title="Permalink"></a></h2><p>The <code>DiscreteModel</code> in Gridap is a fundamental structure that represents a discretized computational domain. It consists of three main components, each serving a specific purpose:</p><ul><li><p>The <code>GridTopology</code>: Defines the connectivity of the mesh elements</p><ul><li>Stores how vertices, edges, faces, and cells are connected</li><li>Enables neighbor queries and traversal of the mesh</li><li>Pure topological information, no geometric data</li></ul></li><li><p>The <code>Grid</code>: Contains the geometric information of the mesh</p><ul><li>Stores coordinates of mesh nodes</li><li>Provides mappings between reference and physical elements</li><li>Handles curved elements and high-order geometries</li></ul></li><li><p>The <code>FaceLabeling</code>: Manages mesh labels and markers</p><ul><li>Identifies boundary regions</li><li>Tags different material regions</li><li>Essential for applying boundary conditions</li></ul></li></ul><h3 id="Key-Concept:-Nodes-vs.-Vertices-1"><a class="docs-heading-anchor" href="#Key-Concept:-Nodes-vs.-Vertices-1">Key Concept: Nodes vs. Vertices</a><a class="docs-heading-anchor-permalink" href="#Key-Concept:-Nodes-vs.-Vertices-1" title="Permalink"></a></h3><p>A very important distinction in Gridap is between nodes and vertices:</p><ul><li><p><strong>Vertices</strong> (Topological entities):</p><ul><li>0-dimensional entities in the <code>GridTopology</code></li><li>Define the connectivity of the mesh</li><li>Used for neighbor queries and mesh traversal</li><li>Number of vertices depends only on topology</li></ul></li><li><p><strong>Nodes</strong> (Geometrical entities):</p><ul><li>Control points stored in the <code>Grid</code></li><li>Define the geometry of elements</li><li>Used for interpolation and mapping</li><li>Number of nodes depends on the geometric order</li></ul></li></ul><p>While nodes and vertices often coincide in simple meshes, they differ in two important cases:</p><ol><li>Periodic meshes: Where multiple nodes may correspond to the same vertex</li><li>High-order meshes: Where additional nodes are needed to represent curved geometries</li></ol><h2 id=".-Working-with-Topology-1"><a class="docs-heading-anchor" href="#.-Working-with-Topology-1">3. Working with Topology</a><a class="docs-heading-anchor-permalink" href="#.-Working-with-Topology-1" title="Permalink"></a></h2><p>Let&#39;s explore how to extract and work with topological information. We&#39;ll start by creating a simple 3x3 cartesian mesh:</p><pre><code class="language-julia">model = cartesian_model((0,1,0,1),(3,3))</code></pre><p>First, let&#39;s get the topology component and count the mesh entities:</p><pre><code class="language-julia">topo = get_grid_topology(model)

n_vertices = num_faces(topo,0)  # Number of vertices (0-dimensional entities)
n_edges = num_faces(topo,1)     # Number of edges (1-dimensional entities)
n_cells = num_faces(topo,2)     # Number of cells (2-dimensional entities)</code></pre><h3 id="Connectivity-Queries-1"><a class="docs-heading-anchor" href="#Connectivity-Queries-1">Connectivity Queries</a><a class="docs-heading-anchor-permalink" href="#Connectivity-Queries-1" title="Permalink"></a></h3><p>Gridap provides various methods to query the connectivity between different mesh entities. Here are some common queries:</p><p>Get vertices of each cell (cell → vertex connectivity)</p><pre><code class="language-julia">cell_to_vertices = get_faces(topo,2,0)</code></pre><p>Get edges of each cell (cell → edge connectivity)</p><pre><code class="language-julia">cell_to_edges = get_faces(topo,2,1)</code></pre><p>Get cells adjacent to each edge (edge → cell connectivity)</p><pre><code class="language-julia">edge_to_cells = get_faces(topo,1,2)</code></pre><p>Get vertices of each edge (edge → vertex connectivity)</p><pre><code class="language-julia">edge_to_vertices = get_faces(topo,1,0)</code></pre><h3 id="Advanced-Connectivity:-Finding-Cell-Neighbors-1"><a class="docs-heading-anchor" href="#Advanced-Connectivity:-Finding-Cell-Neighbors-1">Advanced Connectivity: Finding Cell Neighbors</a><a class="docs-heading-anchor-permalink" href="#Advanced-Connectivity:-Finding-Cell-Neighbors-1" title="Permalink"></a></h3><p>Finding cells that share entities (like vertices or edges) requires more work. A direct query for cell-to-cell connectivity returns an identity map:</p><pre><code class="language-julia">cell_to_cells = get_faces(topo,2,2)  # Returns identity table</code></pre><p>To find actual cell neighbors, we need to traverse through lower-dimensional entities. Here&#39;s a utility function that builds a face-to-face connectivity graph:</p><pre><code class="language-julia">function get_face_to_face_graph(topo,Df)
  n_faces = num_faces(topo,Df)
  face_to_vertices = get_faces(topo,Df,0)  # Get vertices of each face
  vertex_to_faces = get_faces(topo,0,Df)   # Get faces incident to each vertex

  face_to_face = Vector{Vector{Int}}(undef,n_faces)
  for face in 1:n_faces
    nbors = Int[]
    for vertex in face_to_vertices[face]
      append!(nbors,vertex_to_faces[vertex]) # Add incident faces
    end
    face_to_face[face] = filter(!isequal(face),unique(nbors)) # Remove self-reference and duplicates
  end

  return face_to_face
end</code></pre><p>Now we can find neighboring cells and edges:</p><pre><code class="language-julia">cell_to_cells = get_face_to_face_graph(topo,2)  # Cells sharing vertices
edge_to_edges = get_face_to_face_graph(topo,1)  # Edges sharing vertices</code></pre><h2 id=".-Geometric-Mappings-1"><a class="docs-heading-anchor" href="#.-Geometric-Mappings-1">4. Geometric Mappings</a><a class="docs-heading-anchor-permalink" href="#.-Geometric-Mappings-1" title="Permalink"></a></h2><p>The geometry of our mesh is defined by mappings from reference elements to physical space. Let&#39;s explore how these mappings work in Gridap:</p><pre><code class="language-julia">grid = get_grid(model)</code></pre><p>First, we extract the basic geometric information:</p><pre><code class="language-julia">cell_map = get_cell_map(grid)          # Mapping from reference to physical space
cell_to_nodes = get_cell_node_ids(grid) # Node IDs for each cell
node_coordinates = get_node_coordinates(grid) # Physical coordinates of nodes</code></pre><h3 id="Computing-Cell-wise-Node-Coordinates-1"><a class="docs-heading-anchor" href="#Computing-Cell-wise-Node-Coordinates-1">Computing Cell-wise Node Coordinates</a><a class="docs-heading-anchor-permalink" href="#Computing-Cell-wise-Node-Coordinates-1" title="Permalink"></a></h3><p>There are two ways to get the coordinates of nodes for each cell:</p><p>A) Using standard Julia mapping:</p><pre><code class="language-julia">cell_to_node_coords = map(nodes -&gt; node_coordinates[nodes], cell_to_nodes)</code></pre><p>B) Using Gridap&#39;s lazy evaluation system (more efficient for large meshes):</p><pre><code class="language-julia">cell_to_node_coords = lazy_map(Broadcasting(Reindex(node_coordinates)),cell_to_nodes)</code></pre><h3 id="Geometric-Mappings-1"><a class="docs-heading-anchor" href="#Geometric-Mappings-1">Geometric Mappings</a><a class="docs-heading-anchor-permalink" href="#Geometric-Mappings-1" title="Permalink"></a></h3><p>The mapping from reference to physical space is defined by cell-wise linear combination of:</p><ol><li>Reference element shape functions (basis)</li><li>Physical node coordinates (coefficients)</li></ol><pre><code class="language-julia">cell_reffes = get_cell_reffe(grid)     # Get reference elements for each cell
cell_basis = lazy_map(get_shapefuns,cell_reffes)  # Get basis functions
cell_map = lazy_map(linear_combination,cell_to_node_coords,cell_basis)</code></pre><h2 id=".-High-order-Grids-1"><a class="docs-heading-anchor" href="#.-High-order-Grids-1">5. High-order Grids</a><a class="docs-heading-anchor-permalink" href="#.-High-order-Grids-1" title="Permalink"></a></h2><p>High-order geometric representations are essential for accurately modeling curved boundaries and complex geometries. Let&#39;s explore this by creating a curved mesh:</p><h3 id="Example:-Creating-a-Half-Cylinder-1"><a class="docs-heading-anchor" href="#Example:-Creating-a-Half-Cylinder-1">Example: Creating a Half-Cylinder</a><a class="docs-heading-anchor-permalink" href="#Example:-Creating-a-Half-Cylinder-1" title="Permalink"></a></h3><p>First, we define a mapping that transforms our planar mesh into a half-cylinder:</p><pre><code class="language-julia">function F(x)
  θ = x[1]*pi   # Map x-coordinate to angle [0,π]
  z = x[2]      # Keep y-coordinate as height
  VectorValue(cos(θ),sin(θ),z)  # Convert to cylindrical coordinates
end</code></pre><p>Apply the mapping to our node coordinates:</p><pre><code class="language-julia">new_node_coordinates = map(F,node_coordinates)</code></pre><p>Create new cell mappings with the transformed coordinates:</p><pre><code class="language-julia">new_cell_to_node_coords = lazy_map(Broadcasting(Reindex(new_node_coordinates)),cell_to_nodes)
new_cell_map = lazy_map(linear_combination,new_cell_to_node_coords,cell_basis)</code></pre><p>Create a new grid with the transformed geometry:</p><pre><code class="language-julia">reffes, cell_types = compress_cell_data(cell_reffes)
new_grid = UnstructuredGrid(new_node_coordinates,cell_to_nodes,reffes,cell_types)</code></pre><p>Save for visualization:</p><pre><code class="language-julia">mkpath(&quot;output_path&quot;)
writevtk(new_grid,&quot;output_path/half_cylinder_linear&quot;)</code></pre><p>If we visualize the result, we&#39;ll notice that despite applying a curved mapping, our half-cylinder looks faceted. This is because we&#39;re still using linear elements (straight edges) to approximate the curved geometry.</p><h3 id="Example:-High-order-Elements-1"><a class="docs-heading-anchor" href="#Example:-High-order-Elements-1">Example: High-order Elements</a><a class="docs-heading-anchor-permalink" href="#Example:-High-order-Elements-1" title="Permalink"></a></h3><p>To accurately represent curved geometries, we need high-order elements:</p><p>Create quadratic reference elements:</p><pre><code class="language-julia">order = 2  # Polynomial order
new_reffes = [LagrangianRefFE(Float64,QUAD,order)]  # Quadratic quadrilateral elements
new_cell_reffes = expand_cell_data(new_reffes,cell_types)</code></pre><p>Create a finite element space to handle the high-order geometry:</p><pre><code class="language-julia">space = FESpace(model,new_cell_reffes)
new_cell_to_nodes = get_cell_dof_ids(space)</code></pre><p>Get the quadratic nodes in the reference element:</p><pre><code class="language-julia">cell_dofs = lazy_map(get_dof_basis,new_cell_reffes)
cell_basis = lazy_map(get_shapefuns,new_cell_reffes)
cell_to_ref_coordinates = lazy_map(get_nodes,cell_dofs)</code></pre><p>Map the reference nodes to the physical space:</p><pre><code class="language-julia">cell_to_phys_coordinates = lazy_map(evaluate,cell_map,cell_to_ref_coordinates)</code></pre><p>Create the high-order node coordinates:</p><pre><code class="language-julia">new_n_nodes = maximum(maximum,new_cell_to_nodes)
new_node_coordinates = zeros(VectorValue{2,Float64},new_n_nodes)
for (cell,nodes) in enumerate(new_cell_to_nodes)
  for (i,node) in enumerate(nodes)
    new_node_coordinates[node] = cell_to_phys_coordinates[cell][i]
  end
end</code></pre><p>Apply our cylindrical mapping to the high-order nodes:</p><pre><code class="language-julia">new_node_coordinates = map(F,new_node_coordinates)</code></pre><p>Create the high-order grid:</p><pre><code class="language-julia">new_grid = UnstructuredGrid(new_node_coordinates,new_cell_to_nodes,new_reffes,cell_types)
writevtk(new_grid,&quot;output_path/half_cylinder_quadratic&quot;)</code></pre><p>The resulting mesh now accurately represents the curved geometry of the half-cylinder, with quadratic elements properly capturing the curvature (despite paraview still showing a linear interpolation between the nodes).</p><h2 id=".-Periodicity-in-Gridap-1"><a class="docs-heading-anchor" href="#.-Periodicity-in-Gridap-1">6. Periodicity in Gridap</a><a class="docs-heading-anchor-permalink" href="#.-Periodicity-in-Gridap-1" title="Permalink"></a></h2><p>Periodic boundary conditions are essential in many applications, such as:</p><ul><li>Modeling crystalline materials</li><li>Simulating fluid flow in periodic domains</li><li>Analyzing electromagnetic wave propagation</li></ul><p>Gridap handles periodicity through a clever approach:</p><ol><li>In the topology: Periodic vertices are &quot;glued&quot; together, creating a single topological entity</li><li>In the geometry: The corresponding nodes maintain their distinct physical positions</li></ol><p>This separation between topology and geometry allows us to:</p><ul><li>Maintain the correct geometric representation</li><li>Automatically enforce periodic boundary conditions</li><li>Avoid mesh distortion at periodic boundaries</li></ul><h3 id="Visualizing-Periodicity-1"><a class="docs-heading-anchor" href="#Visualizing-Periodicity-1">Visualizing Periodicity</a><a class="docs-heading-anchor-permalink" href="#Visualizing-Periodicity-1" title="Permalink"></a></h3><p>Let&#39;s examine how periodicity affects the mesh structure through three examples:</p><ol><li>Standard non-periodic mesh:</li></ol><pre><code class="language-julia">model = cartesian_model((0,1,0,1),(3,3))
plot_node_numbering(model)</code></pre><p><img src="../../assets/geometry/nodes_nonperiodic.png" alt/></p><ol><li>Mesh with periodicity in x-direction:</li></ol><pre><code class="language-julia">model = cartesian_model((0,1,0,1),(3,3),isperiodic=(true,false))
plot_node_numbering(model)</code></pre><p><img src="../../assets/geometry/nodes_halfperiodic.png" alt/></p><ol><li>Mesh with periodicity in both directions:</li></ol><pre><code class="language-julia">model = cartesian_model((0,1,0,1),(3,3),isperiodic=(true,true))
plot_node_numbering(model)</code></pre><p><img src="../../assets/geometry/nodes_fullperiodic.png" alt/></p><p>Notice how the vertex numbers (displayed at node positions) show the topological connectivity, while the nodes remain at their physical positions.</p><h3 id="Creating-a-Möbius-Strip-1"><a class="docs-heading-anchor" href="#Creating-a-Möbius-Strip-1">Creating a Möbius Strip</a><a class="docs-heading-anchor-permalink" href="#Creating-a-Möbius-Strip-1" title="Permalink"></a></h3><p>We&#39;ll create it by:</p><ol><li>Starting with a rectangular mesh</li><li>Making it periodic in one direction</li><li>Adding a twist before connecting the ends</li></ol><h4 id="Step-1:-Create-Base-Mesh-1"><a class="docs-heading-anchor" href="#Step-1:-Create-Base-Mesh-1">Step 1: Create Base Mesh</a><a class="docs-heading-anchor-permalink" href="#Step-1:-Create-Base-Mesh-1" title="Permalink"></a></h4><p>Start with a 3x3 cartesian mesh:</p><pre><code class="language-julia">nc = (3,3)  # Number of cells in each direction
model = cartesian_model((0,1,0,1),nc)</code></pre><p>Extract geometric and topological information:</p><pre><code class="language-julia">node_coords = get_node_coordinates(model)  # Physical positions
cell_node_ids = get_cell_node_ids(model)  # Node connectivity
cell_type = get_cell_type(model)          # Element type
reffes = get_reffes(model)                # Reference elements</code></pre><h4 id="Step-2:-Create-Periodic-Topology-1"><a class="docs-heading-anchor" href="#Step-2:-Create-Periodic-Topology-1">Step 2: Create Periodic Topology</a><a class="docs-heading-anchor-permalink" href="#Step-2:-Create-Periodic-Topology-1" title="Permalink"></a></h4><p>To create the Möbius strip, we need to:</p><ol><li>Identify vertices to be connected</li><li>Reverse one edge to create the twist</li><li>Ensure proper connectivity</li></ol><p>Create initial vertex numbering:</p><pre><code class="language-julia">np = nc .+ 1  # Number of points in each direction
mobius_ids = collect(LinearIndices(np))</code></pre><p>Create the twist by reversing the last row:</p><pre><code class="language-julia">mobius_ids[end,:] = reverse(mobius_ids[1,:])</code></pre><p>Map cell nodes to the new vertex numbering:</p><pre><code class="language-julia">cell_vertex_ids = map(nodes -&gt; mobius_ids[nodes], cell_node_ids)</code></pre><h4 id="Step-3:-Clean-Up-Vertex-Numbering-1"><a class="docs-heading-anchor" href="#Step-3:-Clean-Up-Vertex-Numbering-1">Step 3: Clean Up Vertex Numbering</a><a class="docs-heading-anchor-permalink" href="#Step-3:-Clean-Up-Vertex-Numbering-1" title="Permalink"></a></h4><p>The new vertex IDs aren&#39;t contiguous (some numbers are duplicated due to periodicity). We need to create a clean mapping:</p><p>Find unique vertices and create bidirectional mappings:</p><pre><code class="language-julia">vertex_to_node = unique(vcat(cell_vertex_ids...))
node_to_vertex = find_inverse_index_map(vertex_to_node)</code></pre><p>Renumber vertices to be contiguous:</p><pre><code class="language-julia">cell_vertex_ids = map(nodes -&gt; node_to_vertex[nodes], cell_vertex_ids)</code></pre><p>Convert to the Table format required by Gridap:</p><pre><code class="language-julia">cell_vertex_ids = Table(cell_vertex_ids)</code></pre><p>Get coordinates for the vertices:</p><pre><code class="language-julia">vertex_coords = node_coords[vertex_to_node]
polytopes = map(get_polytope,reffes)</code></pre><h4 id="Step-4:-Create-the-Model-1"><a class="docs-heading-anchor" href="#Step-4:-Create-the-Model-1">Step 4: Create the Model</a><a class="docs-heading-anchor-permalink" href="#Step-4:-Create-the-Model-1" title="Permalink"></a></h4><p>Now we can create our Möbius strip model:</p><p>Create topology with periodic connections:</p><pre><code class="language-julia">topo = UnstructuredGridTopology(
  vertex_coords, cell_vertex_ids, cell_type, polytopes
)</code></pre><p>Create grid (geometry remains unchanged):</p><pre><code class="language-julia">grid = UnstructuredGrid(
  node_coords, cell_node_ids, reffes, cell_type
)</code></pre><p>Add basic face labels:</p><pre><code class="language-julia">labels = FaceLabeling(topo)</code></pre><p>Combine into final model:</p><pre><code class="language-julia">mobius = UnstructuredDiscreteModel(grid,topo,labels)</code></pre><p>Visualize the vertex numbering:</p><pre><code class="language-julia">plot_node_numbering(mobius)</code></pre><p><img src="../../assets/geometry/mobius.png" alt/></p><h2 id=".-FaceLabelings-and-boundary-conditions-1"><a class="docs-heading-anchor" href="#.-FaceLabelings-and-boundary-conditions-1">7. FaceLabelings and boundary conditions</a><a class="docs-heading-anchor-permalink" href="#.-FaceLabelings-and-boundary-conditions-1" title="Permalink"></a></h2><p>The <code>FaceLabeling</code> component of a <code>DiscreteModel</code> is the way Gridap handles boundary conditions. The basic idea is that, similar to Gmsh, we classify the d-faces (cells, faces, edges, nodes) of the mesh into different entities (physical groups in Gmsh terminology) which in turn have one or more tags/labels associated with them. We can then query the <code>FaceLabeling</code> for the tags associated with a given d-face, or the d-faces associated with a given tag.</p><p>We will now explore ways to create and manipulate <code>Facelabeling</code> objects.</p><h3 id="Creating-FaceLabelings-1"><a class="docs-heading-anchor" href="#Creating-FaceLabelings-1">Creating FaceLabelings</a><a class="docs-heading-anchor-permalink" href="#Creating-FaceLabelings-1" title="Permalink"></a></h3><p>The simplest way to create a blank <code>FaceLabeling</code> is to use your <code>GridTopology</code>:</p><pre><code class="language-julia">model = cartesian_model((0,1,0,1),(3,3))
topo = get_grid_topology(model)

labels = FaceLabeling(topo)</code></pre><p>The above <code>FaceLabeling</code> is by default created with 2 entities and 2 tags, associated to interior and boundary d-faces respectively. The boundary facets are chosen as the ones with a single neighboring cell.</p><p>We can extract the low-level information from the <code>FaceLabeling</code> object:</p><pre><code class="language-julia">tag_names = get_tag_name(labels) # Each name is a string
tag_entities = get_tag_entities(labels) # For each tag, a vector of entities
cell_to_entity = get_face_entity(labels,2) # For each cell, its associated entity
edge_to_entity = get_face_entity(labels,1) # For each edge, its associated entity
node_to_entity = get_face_entity(labels,0) # For each node, its associated entity</code></pre><p>It is usually more convenient to visualise it in Paraview by exporting to vtk:</p><pre><code class="language-julia">writevtk(model,&quot;output_path/labels_basic&quot;,labels=labels)</code></pre><p>Another useful way to create a <code>FaceLabeling</code> is by providing a coloring for the mesh cells, where each color corresponds to a different tag. The d-faces of the mesh will have all the tags associated to the cells that share them.</p><pre><code class="language-julia">cell_to_tag = [1,1,1,2,2,3,2,2,3]
tag_to_name = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
labels_cw = Geometry.face_labeling_from_cell_tags(topo,cell_to_tag,tag_to_name)
writevtk(model,&quot;output_path/labels_cellwise&quot;,labels=labels_cw)</code></pre><p>We can also create a <code>FaceLabeling</code> from a vertex filter. The resulting <code>FaceLabeling</code> will have only one tag, gathering the d-faces whose vertices ALL fullfill <code>filter(x) == true</code>.</p><pre><code class="language-julia">vfilter(x) = abs(x[1]- 1.0) &lt; 1.e-5
labels_vf = Geometry.face_labeling_from_vertex_filter(topo, &quot;top&quot;, vfilter)
writevtk(model,&quot;output_path/labels_filter&quot;,labels=labels_vf)</code></pre><p><code>FaceLabeling</code> objects can also be merged together. The resulting <code>FaceLabeling</code> will have the union of the tags and entities of the original ones. Note that this modifies the first <code>FaceLabeling</code> in place.</p><pre><code class="language-julia">labels = merge!(labels, labels_cw, labels_vf)
writevtk(model,&quot;output_path/labels_merged&quot;,labels=labels)</code></pre><h3 id="Creating-new-tags-from-existing-ones-1"><a class="docs-heading-anchor" href="#Creating-new-tags-from-existing-ones-1">Creating new tags from existing ones</a><a class="docs-heading-anchor-permalink" href="#Creating-new-tags-from-existing-ones-1" title="Permalink"></a></h3><p>Tags in a <code>FaceLabeling</code> support all the usual set operation, i.e union, intersection, difference and complementary.</p><pre><code class="language-julia">cell_to_tag = [1,1,1,2,2,3,2,2,3]
tag_to_name = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]
labels = Geometry.face_labeling_from_cell_tags(topo,cell_to_tag,tag_to_name)</code></pre><p>Union: Takes as input a list of tags and creates a new tag that is the union of all of them.</p><pre><code class="language-julia">Geometry.add_tag_from_tags!(labels,&quot;A∪B&quot;,[&quot;A&quot;,&quot;B&quot;])</code></pre><p>Intersection: Takes as input a list of tags and creates a new tag that is the intersection of all of them.</p><pre><code class="language-julia">Geometry.add_tag_from_tags_intersection!(labels,&quot;A∩B&quot;,[&quot;A&quot;,&quot;B&quot;])</code></pre><p>Complementary: Takes as input a list of tags and creates a new tag that is the complementary of the union.</p><pre><code class="language-julia">Geometry.add_tag_from_tags_complementary!(labels,&quot;!A&quot;,[&quot;A&quot;])</code></pre><p>Set difference: Takes as input two lists of tags (tags<em>include - tags</em>exclude) and creates a new tag that contains all the d-faces that are in the first list but not in the second.</p><pre><code class="language-julia">Geometry.add_tag_from_tags_setdiff!(labels,&quot;A-B&quot;,[&quot;A&quot;],[&quot;B&quot;]) # set difference

writevtk(model,&quot;output_path/labels_setops&quot;,labels=labels)</code></pre><h3 id="FaceLabeling-queries-1"><a class="docs-heading-anchor" href="#FaceLabeling-queries-1">FaceLabeling queries</a><a class="docs-heading-anchor-permalink" href="#FaceLabeling-queries-1" title="Permalink"></a></h3><p>The most common way of query information from a <code>FaceLabeling</code> is to query a face mask for a given tag and face dimension. If multiple tags are provided, the union of the tags is returned.</p><pre><code class="language-julia">face_dim = 1
mask = get_face_mask(labels,[&quot;A&quot;,&quot;C&quot;],face_dim) # Boolean mask
ids = findall(mask) # Edge IDs</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t026_poisson_dev_fe/">« 26 Low-level API - Poisson equation</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 25 September 2025 00:53">Thursday 25 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
