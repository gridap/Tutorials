<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>7 Darcy equation (with RT) · Gridap tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Gridap tutorials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="tocitem" href="../t002_validation/">2 Code validation</a></li><li><a class="tocitem" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="tocitem" href="../t004_p_laplacian/">4 p-Laplacian</a></li><li><a class="tocitem" href="../t005_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="tocitem" href="../t006_dg_discretization/">6 Poisson equation (with DG)</a></li><li class="is-active"><a class="tocitem" href>7 Darcy equation (with RT)</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement-1"><span>Problem statement</span></a></li><li><a class="tocitem" href="#Numerical-scheme-1"><span>Numerical scheme</span></a></li><li><a class="tocitem" href="#Discrete-model-1"><span>Discrete model</span></a></li><li><a class="tocitem" href="#Multi-field-FE-spaces-1"><span>Multi-field FE spaces</span></a></li><li><a class="tocitem" href="#Numerical-integration-1"><span>Numerical integration</span></a></li><li><a class="tocitem" href="#Weak-form-1"><span>Weak form</span></a></li><li><a class="tocitem" href="#Multi-field-FE-problem-1"><span>Multi-field FE problem</span></a></li><li><a class="tocitem" href="#References-1"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li><li><a class="tocitem" href="../t009_stokes/">9 Stokes equation</a></li><li><a class="tocitem" href="../t010_isotropic_damage/">10 Isotropic damage model</a></li><li><a class="tocitem" href="../t011_fsi_tutorial/">11 Fluid-Structure Interaction</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>7 Darcy equation (with RT)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>7 Darcy equation (with RT)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Tutorials/blob/master/src/darcy.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-7:-Darcy-equation-(with-RT)-1"><a class="docs-heading-anchor" href="#Tutorial-7:-Darcy-equation-(with-RT)-1">Tutorial 7: Darcy equation (with RT)</a><a class="docs-heading-anchor-permalink" href="#Tutorial-7:-Darcy-equation-(with-RT)-1" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=v0.10.0/notebooks/t007_darcy.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/v0.10.0/notebooks/t007_darcy.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will learn</p><ul><li>How to implement multi-field PDEs</li><li>How to build div-conforming FE spaces</li><li>How to impose boundary conditions in multi-field problems</li></ul><h2 id="Problem-statement-1"><a class="docs-heading-anchor" href="#Problem-statement-1">Problem statement</a><a class="docs-heading-anchor-permalink" href="#Problem-statement-1" title="Permalink"></a></h2><p>In this tutorial, we show how to solve a multi-field PDE in Gridap. As a model problem, we consider the Darcy equations with Dirichlet and Neumann boundary conditions. The PDE we want to solve is: find the flux vector <span>$u$</span>, and the pressure <span>$p$</span> such that</p><div>\[   \left\lbrace
   \begin{aligned}
      \kappa^{-1} u + \nabla p = 0  \ &amp;\text{in} \ \Omega,\\
      \nabla \cdot u = f  \ &amp;\text{in} \ \Omega,\\
      u \cdot n = g \ &amp;\text{on}\  \Gamma_{\rm D},\\
      p = h \ &amp;\text{on}\ \Gamma_{\rm N},\\
   \end{aligned}
   \right.\]</div><p>being <span>$n$</span> the outwards unit normal vector to the boundary <span>$\partial\Omega$</span>.  In this particular tutorial, we consider the unit square <span>$\Omega \doteq (0,1)^2$</span> as the computational domain, the Neumann boundary <span>$\Gamma_{\rm N}$</span> is the right and left sides of <span>$\Omega$</span>, and <span>$\Gamma_{\rm D}$</span> is the bottom and top sides of <span>$\Omega$</span>. We consider <span>$f = g \doteq 0$</span> and <span>$h(x) \doteq x_1$</span>, i.e., <span>$h$</span> equal to 0 on the left side and 1 on the right side. The inverse of the permeability tensor, namely <span>$\kappa^{-1}(x)$</span>, is chosen equal to</p><div>\[\begin{pmatrix}
  100 &amp; 90 \\
  90 &amp; 100
\end{pmatrix}
\text{ for } \ x \in [0.4,0.6]^2, \text{ and }
\begin{pmatrix}
  1 &amp; 0 \\
  0 &amp; 1
\end{pmatrix}
\ \text	{otherwise.}\]</div><p>In order to state this problem in weak form, we introduce the following Sobolev spaces. <span>$H(\mathrm{div};\Omega)$</span> is the space of vector fields in <span>$\Omega$</span>, whose components and divergence are in <span>$L^2(\Omega)$</span>. On the other hand, <span>$H_g(\mathrm{div};\Omega)$</span> and <span>$H_0(\mathrm{div};\Omega)$</span> are the subspaces of functions in <span>$H(\mathrm{div};\Omega)$</span> such that their normal traces are equal to <span>$g$</span> and <span>$0$</span> respectively almost everywhere in <span>$\Gamma_{\rm D}$</span>. With these notations, the weak form reads: find <span>$(u,p)\in H_g(\mathrm{div};\Omega)\times L^2(\Omega)$</span> such that <span>$a((u,q),(v,q)) = b(v,q)$</span> for all <span>$(v,q)\in H_0(\mathrm{div};\Omega)\times L^2(\Omega)$</span>, where</p><div>\[\begin{aligned}
a((u,q),(v,q)) &amp;\doteq \int_{\Omega}  v \cdot \left(\kappa^{-1} u\right) \ {\rm d}\Omega - \int_{\Omega} (\nabla \cdot v)\ p \ {\rm d}\Omega + \int_{\Omega} q\ (\nabla \cdot u) \ {\rm d}\Omega,\\
b(v,q) &amp;\doteq \int_{\Omega} q\ f \ {\rm  d}\Omega - \int_{\Gamma_{\rm N}} (v\cdot n)\ h  \ {\rm  d}\Gamma.
\end{aligned}\]</div><h2 id="Numerical-scheme-1"><a class="docs-heading-anchor" href="#Numerical-scheme-1">Numerical scheme</a><a class="docs-heading-anchor-permalink" href="#Numerical-scheme-1" title="Permalink"></a></h2><p>In this tutorial, we use the Raviart-Thomas (RT)  space for the flux approximation [1]. On a reference square with sides aligned with the Cartesian axes, the \ac{rt} space of order <span>$k$</span> is represented as <span>$Q_{(k+1,k)} \times Q_{(k,k+1)}$</span>, being the polynomial space defined as follows. The component  <span>$w_\alpha$</span> of a vector field <span>$w$</span> in <span>$Q_{(k+1,k)} \times Q_{(k,k+1)}$</span> is obtained as the tensor product of univariate polynomials of order <span>$k+1$</span> in direction <span>$\alpha$</span> times univariate polynomials of order <span>$k$</span> on the other directions. That is, <span>$\nabla\cdot w \in Q_k$</span>, where <span>$Q_k$</span> is the multivariate polynomial space of degree at most <span>$k$</span> in each of the spatial coordinates. Note that the definition of the \ac{rt} space also applies to arbitrary dimensions. The global FE space for the flux <span>$V$</span> is obtained by mapping the cell-wise RT space into the physical space using the Piola transformation and enforcing continuity of normal traces across cells (see [1] for specific details).</p><p>We consider the subspace  <span>$V_0$</span> of functions in <span>$V$</span> with zero normal trace on <span>$\Gamma_{\rm D}$</span>, and the subspace <span>$V_g$</span> of functions in <span>$V$</span> with normal trace equal to the projection of <span>$g$</span> onto the space of traces of <span>$V$</span> on <span>$\Gamma_{\rm D}$</span>. With regard to the pressure, we consider the discontinuous space of cell-wise polynomials in <span>$Q_k$</span>.</p><h2 id="Discrete-model-1"><a class="docs-heading-anchor" href="#Discrete-model-1">Discrete model</a><a class="docs-heading-anchor-permalink" href="#Discrete-model-1" title="Permalink"></a></h2><p>We start the driver loading the Gridap package and constructing the geometrical model. We generate a <span>$100\times100$</span> structured mesh for the domain <span>$(0,1)^2$</span>.</p><pre><code class="language-julia">using Gridap
domain = (0,1,0,1)
partition = (100,100)
model = CartesianDiscreteModel(domain,partition)</code></pre><h2 id="Multi-field-FE-spaces-1"><a class="docs-heading-anchor" href="#Multi-field-FE-spaces-1">Multi-field FE spaces</a><a class="docs-heading-anchor-permalink" href="#Multi-field-FE-spaces-1" title="Permalink"></a></h2><p>Next, we build the FE spaces. We consider the first order RT space for the flux and the discontinuous pressure space as described above.  This mixed FE pair satisfies the inf-sup condition and, thus, it is stable.</p><pre><code class="language-julia">order = 1

V = TestFESpace(
  reffe=:RaviartThomas, order=order, valuetype=VectorValue{2,Float64},
  conformity=:HDiv, model=model, dirichlet_tags=[5,6])

Q = TestFESpace(
  reffe=:QLagrangian, order=order, valuetype=Float64,
  conformity=:L2, model=model)</code></pre><p>Note that the Dirichlet boundary for the flux are the bottom and top sides of the squared domain (identified with the boundary tags 5, and 6 respectively), whereas no Dirichlet data can be imposed on the pressure space. We select <code>conformity=:HDiv</code> for the flux (i.e., shape functions with <span>$H^1(\mathrm{div};\Omega)$</span> regularity) and <code>conformity=:L2</code> for the pressure (i.e. discontinuous shape functions).</p><p>From these objects, we construct the trial spaces. Note that we impose homogeneous boundary conditions for the flux.</p><pre><code class="language-julia">uD = VectorValue(0.0,0.0)
U = TrialFESpace(V,uD)
P = TrialFESpace(Q)</code></pre><p>When the singe-field spaces have been designed, the multi-field test and trial spaces are expressed as arrays of single-field ones in a natural way.</p><pre><code class="language-julia">Y = MultiFieldFESpace([V, Q])
X = MultiFieldFESpace([U, P])</code></pre><h2 id="Numerical-integration-1"><a class="docs-heading-anchor" href="#Numerical-integration-1">Numerical integration</a><a class="docs-heading-anchor-permalink" href="#Numerical-integration-1" title="Permalink"></a></h2><p>In this example we need to integrate in the interior of <span>$\Omega$</span> and on the Neumann boundary <span>$\Gamma_{\rm N}$</span>. For the volume integrals, we extract the triangulation from the geometrical model and define the corresponding cell-wise quadrature of degree of exactness at least 2 as follows.</p><pre><code class="language-julia">trian = Triangulation(model)
degree = 2
quad = CellQuadrature(trian,degree)</code></pre><p>In order to integrate the Neumann boundary condition, we only need to build an integration mesh for the right side of the domain (which is the only part of <span>$\Gamma_{\rm N}$</span>, where the Neumann function <span>$h$</span> is different from zero). Within the model, the right side of <span>$\Omega$</span> is identified with the boundary tag 8. Using this identifier, we extract the corresponding surface triangulation and create a quadrature with the desired degree of exactness.</p><pre><code class="language-julia">neumanntags = [8,]
btrian = BoundaryTriangulation(model,neumanntags)
bquad = CellQuadrature(btrian,degree)</code></pre><h2 id="Weak-form-1"><a class="docs-heading-anchor" href="#Weak-form-1">Weak form</a><a class="docs-heading-anchor-permalink" href="#Weak-form-1" title="Permalink"></a></h2><p>We start by defining the permeability tensors inverses commented above using the <code>@law</code> macro.</p><pre><code class="language-julia">const kinv1 = TensorValue(1.0,0.0,0.0,1.0)
const kinv2 = TensorValue(100.0,90.0,90.0,100.0)
@law function σ(x,u)
   if ((abs(x[1]-0.5) &lt;= 0.1) &amp;&amp; (abs(x[2]-0.5) &lt;= 0.1))
      return kinv2*u
   else
      return kinv1*u
   end
end</code></pre><p>With this definition, we can express the integrand of the bilinear form as follows.</p><pre><code class="language-julia">px = get_physical_coordinate(trian)

function a(x,y)
   v, q = y
   u, p = x
   v*σ(px,u) - (∇*v)*p + q*(∇*u)
end</code></pre><p>The arguments <code>x</code> and <code>y</code> of previous function represent a trial and a test function in the multi-field test and trial spaces <code>X</code> and <code>Y</code> respectively. In the first lines in the function definition, we unpack the single-field test and trial functions from the multi-field ones. E.g., <code>v</code> represents a test function for the flux and <code>q</code> for the pressure. These quantities can also be written as <code>y[1]</code> and <code>y[2]</code> respectively. From the single-field functions, we write the different terms of the bilinear form as we have done in previous tutorials.</p><p>In a similar way, we can define the forcing term related to the Neumann boundary condition.</p><pre><code class="language-julia">nb = get_normal_vector(btrian)
h = -1.0
function b_ΓN(y)
  v, q = y
  (v*nb)*h
end</code></pre><h2 id="Multi-field-FE-problem-1"><a class="docs-heading-anchor" href="#Multi-field-FE-problem-1">Multi-field FE problem</a><a class="docs-heading-anchor-permalink" href="#Multi-field-FE-problem-1" title="Permalink"></a></h2><p>Finally, we can assemble the FE problem and solve it. Note that we build the <code>AffineFEOperator</code> object using the multi-field trial and test spaces <code>Y</code> and <code>X</code>.</p><pre><code class="language-julia">t_Ω = LinearFETerm(a,trian,quad)
t_ΓN = FESource(b_ΓN,btrian,bquad)
op = AffineFEOperator(X,Y,t_Ω,t_ΓN)
xh = solve(op)
uh, ph = xh</code></pre><p>Since this is a multi-field example, the <code>solve</code> function returns a multi-field solution <code>xh</code>, which can be unpacked in order to finally recover each field of the problem. The resulting single-field objects can be visualized as in previous tutorials (see next figure).</p><pre><code class="language-julia">writevtk(trian,&quot;darcyresults&quot;,cellfields=[&quot;uh&quot;=&gt;uh,&quot;ph&quot;=&gt;ph])</code></pre><p><img src="../../assets/darcy/darcy_results.png" alt/></p><h2 id="References-1"><a class="docs-heading-anchor" href="#References-1">References</a><a class="docs-heading-anchor-permalink" href="#References-1" title="Permalink"></a></h2><p>[1] F. Brezzi and M. Fortin. <em>Mixed and hybrid finite element methods</em>. Springer-Verlag, 1991.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t006_dg_discretization/">« 6 Poisson equation (with DG)</a><a class="docs-footer-nextpage" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 5 June 2020 09:07">Friday 5 June 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
