<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>17 Transient Poisson equation · Gridap tutorials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gridap tutorials logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap tutorials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../t001_poisson/">1 Poisson equation</a></li><li><a class="tocitem" href="../t002_validation/">2 Code validation</a></li><li><a class="tocitem" href="../t003_elasticity/">3 Linear elasticity</a></li><li><a class="tocitem" href="../t004_p_laplacian/">4 p-Laplacian</a></li><li><a class="tocitem" href="../t005_hyperelasticity/">5 Hyper-elasticity</a></li><li><a class="tocitem" href="../t006_dg_discretization/">6 Poisson equation (with DG)</a></li><li><a class="tocitem" href="../t007_darcy/">7 Darcy equation (with RT)</a></li><li><a class="tocitem" href="../t008_inc_navier_stokes/">8 Incompressible Navier-Stokes</a></li><li><a class="tocitem" href="../t009_stokes/">9 Stokes equation</a></li><li><a class="tocitem" href="../t010_advection_diffusion/">10 Advection-diffusion</a></li><li><a class="tocitem" href="../t011_isotropic_damage/">11 Isotropic damage model</a></li><li><a class="tocitem" href="../t012_fsi_tutorial/">12 Fluid-Structure Interaction</a></li><li><a class="tocitem" href="../t013_emscatter/">13 Electromagnetic scattering in 2D</a></li><li><a class="tocitem" href="../t014_validation_DrWatson/">14 On using DrWatson.jl</a></li><li><a class="tocitem" href="../t015_interpolation_fe/">15 Interpolation of CellFields</a></li><li><a class="tocitem" href="../t016_poisson_distributed/">16 Poisson equation on parallel distributed-memory computers</a></li><li class="is-active"><a class="tocitem" href>17 Transient Poisson equation</a><ul class="internal"><li><a class="tocitem" href="#Problem-statement-1"><span>Problem statement</span></a></li><li><a class="tocitem" href="#Discrete-model-1"><span>Discrete model</span></a></li><li><a class="tocitem" href="#FE-spaces-1"><span>FE spaces</span></a></li><li><a class="tocitem" href="#Triangulation-and-quadrature-1"><span>Triangulation and quadrature</span></a></li><li><a class="tocitem" href="#Weak-form-1"><span>Weak form</span></a></li><li><a class="tocitem" href="#Transient-solver-1"><span>Transient solver</span></a></li><li><a class="tocitem" href="#Postprocessing-1"><span>Postprocessing</span></a></li></ul></li><li><a class="tocitem" href="../t018_transient_nonlinear/">18 Transient nonlinear equation</a></li><li><a class="tocitem" href="../t019_TopOptEMFocus/">19 Topology optimization</a></li><li><a class="tocitem" href="../t020_poisson_unfitted/">20 Poisson on unfitted meshes</a></li><li><a class="tocitem" href="../t021_poisson_amr/">21 Poisson with AMR</a></li><li><a class="tocitem" href="../t022_poisson_dev_fe/">22 Low-level API - Poisson equation</a></li><li><a class="tocitem" href="../t023_geometry_dev/">23 Low-level API - Geometry</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>17 Transient Poisson equation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>17 Transient Poisson equation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Tutorials/blob/master/src/transient_linear.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="transient_linear.jl-1"><a class="docs-heading-anchor" href="#transient_linear.jl-1">Tutorial 17: Transient Poisson equation</a><a class="docs-heading-anchor-permalink" href="#transient_linear.jl-1" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/gridap/Tutorials/gh-pages?filepath=v0.18.1/notebooks/t017_transient_linear.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/gridap/Tutorials/blob/gh-pages/v0.18.1/notebooks/t017_transient_linear.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this tutorial, we will learn</p><ul><li>How to solve a simple time-dependent PDE in Gridap</li><li>How to build a transient FE space</li><li>How to define a transient weak form</li><li>How to set up a time-marching scheme for a linear ODE</li><li>How to visualise transient results</li></ul><p>We split the presentation of the ODE module of Gridap in two parts:</p><ul><li>In this tutorial we focus on the differences between the steady and time-dependent cases, on a simple linear time-dependent PDE.</li><li><a href="../t018_transient_nonlinear/#transient_nonlinear.jl-1">Tutorial 18</a> will introduce more advanced features of the ODE module of Gridap, applied to a nonlinear time-dependent PDE.</li></ul><p>The <a href="https://gridap.github.io/Gridap.jl/dev/ODEs/">documentation of the ODE module of Gridap</a> contains a detailed description of the framework for transient problems implemented in Gridap, including a <a href="https://gridap.github.io/Gridap.jl/dev/ODEs/#Classification-of-ODEs">classification of transient problem</a>, a <a href="https://gridap.github.io/Gridap.jl/dev/ODEs/#Classification-of-numerical-schemes">classification of numerical schemes</a>, an overview of the <a href="https://gridap.github.io/Gridap.jl/dev/ODEs/#High-level-API-in-Gridap">high-level API</a> which this tutorial illustrates and of the <a href="https://gridap.github.io/Gridap.jl/dev/ODEs/#Low-level-implementation">internals of the ODE module</a>, as well as some <a href="https://gridap.github.io/Gridap.jl/dev/ODEs/#Numerical-schemes-formulation-and-implementation">notes on and analysis of the numerical schemes implemented in Gridap</a>.</p><h2 id="Problem-statement-1"><a class="docs-heading-anchor" href="#Problem-statement-1">Problem statement</a><a class="docs-heading-anchor-permalink" href="#Problem-statement-1" title="Permalink"></a></h2><p>We solve the heat equation in the two-dimensional domain <span>$\Omega = [-1, +1]^{2}$</span>. Let <span>$k$</span> denote the thermal conductivity of the material, <span>$c$</span> its specific heat capacity, <span>$\rho$</span> its density and <span>$q$</span> a rate of external heat generation. Let <span>$g$</span> denote the temperature on the boundary of the domain. Let <span>$t_{0}$</span> be the initial time, and <span>$u_{0}$</span> be the initial temperature. The strong form of the heat equation reads: find <span>$u(t): \Omega \to \mathbb{R}$</span> such that</p><div>\[\left\lbrace
\begin{aligned}
\rho(t, x) c(t, x) \partial_{t} u(t, x) - \nabla \cdot (k(t, x) \nabla u(t, x)) &amp;= q(t, x) &amp; \text{ in } \Omega, \\
u(t, x) &amp;= g(t, x) &amp; \text{ on } \partial \Omega, \\
u(t_{0}, x) &amp;= u_{0}(x) &amp; \text{ in } \Omega \\
\end{aligned}
\right.\]</div><p>We assume that the data (<span>$k$</span>, <span>$c$</span>, <span>$\rho$</span> and <span>$q$</span>) is continuous in time. Let <span>$\alpha = k / (\rho c)$</span> denote the thermal diffusivity and <span>$f = q / (\rho c)$</span> be the rate of external temperature generation. The weak form of the problem reads: find <span>$u(t) \in U_{g}(t)$</span> such that <span>$b(t, u, v) = \ell(t, v)$</span> for all <span>$t \geq t_{0}$</span> and <span>$v \in V_{0}$</span>, where the time-dependent bilinear and linear forms <span>$b(t, \cdot, \cdot)$</span> and <span>$\ell(t, \cdot)$</span> are defined as</p><div>\[\begin{aligned}
b(t, u, v) &amp;= m(t, u, v) + a(t, u, v), \\
m(t, u, v) &amp;= \int_{\Omega} v \partial_{t} u(t) \ {\rm d} \Omega, \\
a(t, u, v) &amp;= \int_{\Omega} \alpha(t) \nabla v \cdot \nabla u(t) \ {\rm d} \Omega, \\
\ell(t, v) &amp;= \int_{\Omega} v f(t) \ {\rm d} \Omega,
\end{aligned}\]</div><p>and the the functional spaces are <span>$U_{g}(t) = H^{1}_{g(t)}(\Omega)$</span> and <span>$V_{0} = H^{1}_{0}(\Omega)$</span>. In particular, the trial space <span>$U_{g}$</span> is a transient functional space, in the sense that its Dirichlet trace <span>$g$</span> depends on time. However, the test space <span>$V_{0}$</span> is time-independent (it has a constant, zero Dirichlet trace). For all <span>$t \geq t_{0}$</span>, we assume that <span>$\alpha(t) \in L^{\infty}(\Omega)$</span> is uniformly positive in <span>$\Omega$</span>, <span>$f(t) \in H^{-1}(\Omega)$</span>, <span>$g(t) \in H^{1/2}(\Omega)$</span>, and finally <span>$u_{0} \in L^{2}(\Omega)$</span>.</p><h2 id="Discrete-model-1"><a class="docs-heading-anchor" href="#Discrete-model-1">Discrete model</a><a class="docs-heading-anchor-permalink" href="#Discrete-model-1" title="Permalink"></a></h2><p>We start with the discretization of the computational domain. In our case, we consider a <span>$20 \times 20$</span> Cartesian mesh of the square <span>$[-1, +1]^{2}$</span>.</p><pre><code class="language-julia">using Gridap
domain = (-1, +1, -1, +1)
partition = (20, 20)
model = CartesianDiscreteModel(domain, partition)</code></pre><h2 id="FE-spaces-1"><a class="docs-heading-anchor" href="#FE-spaces-1">FE spaces</a><a class="docs-heading-anchor-permalink" href="#FE-spaces-1" title="Permalink"></a></h2><p>In this tutorial we use a linear Lagrangian FE space.</p><pre><code class="language-julia">order = 1
reffe = ReferenceFE(lagrangian, Float64, order)</code></pre><p>The test space is defined as for steady problems</p><pre><code class="language-julia">V0 = TestFESpace(model, reffe, dirichlet_tags=&quot;boundary&quot;)</code></pre><p>The trial space is now a <code>TransientTrialFESpace</code>, which is constructed from a <code>TestFESpace</code> and a function (or vector of functions if several Dirichlet tags are provided) for the Dirichlet boundary conditions. The Dirichlet trace has to be prescribed as a function of time and then space as follows</p><pre><code class="language-julia">g(t) = x -&gt; exp(-2 * t) * sinpi(t * x[1]) * (x[2]^2 - 1)
Ug = TransientTrialFESpace(V0, g)</code></pre><h2 id="Triangulation-and-quadrature-1"><a class="docs-heading-anchor" href="#Triangulation-and-quadrature-1">Triangulation and quadrature</a><a class="docs-heading-anchor-permalink" href="#Triangulation-and-quadrature-1" title="Permalink"></a></h2><p>As usual, we equip the model with an integration mesh and a measure</p><pre><code class="language-julia">degree = 2
Ω = Triangulation(model)
dΩ = Measure(Ω, degree)</code></pre><h2 id="Weak-form-1"><a class="docs-heading-anchor" href="#Weak-form-1">Weak form</a><a class="docs-heading-anchor-permalink" href="#Weak-form-1" title="Permalink"></a></h2><p>We define the thermal diffusivity <span>$\alpha$</span> and the rate of external temperature generation <span>$f$</span>.</p><pre><code class="language-julia">α(t) = x -&gt; 1 + sin(t) * (x[1]^2 + x[2]^2) / 4
f(t) = x -&gt; sin(t) * sinpi(x[1]) * sinpi(x[2])</code></pre><p>We are going to construct a transient linear FEOperator by providing the bilinear forms associated to <span>$\partial_{t} u$</span> and <span>$u$</span>, as well as the forcing term. Note that they now receive time as an additional argument, and the time derivative operator is <code>∂t</code>.</p><pre><code class="language-julia">m(t, dtu, v) = ∫(v * dtu)dΩ
a(t, u, v) = ∫(α(t) * ∇(v) ⋅ ∇(u))dΩ
l(t, v) = ∫(v * f(t))dΩ
op = TransientLinearFEOperator((a, m), l, Ug, V0)</code></pre><p>In our case, the mass term (<span>$m(t, \cdot, \cdot)$</span>) is constant in time. We can take advantage of that to save some computational effort, and indicate it to Gridap as follows</p><pre><code class="language-julia">op_opt = TransientLinearFEOperator((a, m), l, Ug, V0, constant_forms=(true, false))</code></pre><p>If the stiffness term (<span>$a(t, \cdot, \cdot)$</span>) had been constant in time, we could have set <code>constant_forms=(true, true)</code>.</p><h2 id="Transient-solver-1"><a class="docs-heading-anchor" href="#Transient-solver-1">Transient solver</a><a class="docs-heading-anchor-permalink" href="#Transient-solver-1" title="Permalink"></a></h2><p>Once we have defined the FE operator, we proceed with the definition of the ODE solver, i.e. the scheme that will be used for the integration in time. In this tutorial, we use the <code>ThetaMethod</code> with <span>$\theta = 1/2$</span>, resulting in a second-order scheme. The <code>ThetaMethod</code> function receives a solver for systems of equations, the time step size <span>$\Delta t$</span> (constant) and the value of <span>$\theta \in [0, 1]$</span>. Since the ODE is linear the systems of equation that will arise in the time-marching scheme will be linear so we can provide <code>ThetaMethod</code> with a linear solver.</p><pre><code class="language-julia">ls = LUSolver()
Δt = 0.05
θ = 0.5
solver = ThetaMethod(ls, Δt, θ)</code></pre><p>Gridap also implements explicit and diagonally-implicit Runge-Kutta schemes. One can access the full list of available Butcher tableaus through the exported constant <code>available_tableaus</code>. There are also constructors for explicit 2- and 3-stage schemes: <code>EXRK22(α)</code> and <code>EXRK33(α, β)</code>, <code>EXRK33_1(α)</code>, <code>EXRK33_2(α)</code> respectively, and diagonally-implicit 1- and 2-stage schemes: <code>SDIRK11(α)</code>, <code>SDIRK12()</code>, <code>SDIRK22(α, β, γ)</code>, <code>SDIRK23(λ)</code>. See the documentation of <a href="https://gridap.github.io/Gridap.jl/dev/ODEs/#Runge-Kutta">Runge-Kutta schemes in Gridap</a> for a description of the corresponding tableaus. For example, one could have chosen a two-stage singly-diagonally-implicit scheme (of order 2) as follows.</p><pre><code class="language-julia">tableau = :SDIRK_2_2
solver_rk = RungeKutta(ls, ls, Δt, tableau)</code></pre><p>Let <span>$t_{F} &gt; t_{0}$</span> be a final time, until when we want to evolve the problem. We define the solution using the <code>solve</code> function, giving the ODE solver, the transient FE operator, the initial and final times, and the initial solution. To construct the initial condition we interpolate the initial function <span>$u_{0}$</span> onto the FE space <span>$U_{g}$</span> at the initial time. In our case, <span>$u_{0}$</span> is simply <span>$g(t_{0})$</span>.</p><pre><code class="language-julia">t0, tF = 0.0, 10.0
uh0 = interpolate_everywhere(g(t0), Ug(t0))
uh = solve(solver, op, t0, tF, uh0)</code></pre><h2 id="Postprocessing-1"><a class="docs-heading-anchor" href="#Postprocessing-1">Postprocessing</a><a class="docs-heading-anchor-permalink" href="#Postprocessing-1" title="Permalink"></a></h2><p>We highlight that <code>uh</code> is an iterable function and the result at each time step is only computed lazily when iterating over it. We can post-process the results and generate the corresponding <code>vtk</code> files using the <code>createpvd</code> and <code>createvtk</code> functions. The former will create a <code>.pvd</code> file with the collection of <code>.vtu</code> files saved at each time step by <code>createvtk</code>. The computation of the problem solutions will be triggered in the following loop:</p><pre><code class="language-julia">if !isdir(&quot;tmp&quot;)
  mkdir(&quot;tmp&quot;)
end

createpvd(&quot;results&quot;) do pvd
  pvd[0] = createvtk(Ω, &quot;tmp/results_0&quot; * &quot;.vtu&quot;, cellfields=[&quot;u&quot; =&gt; uh0])
  for (tn, uhn) in uh
    pvd[tn] = createvtk(Ω, &quot;tmp/results_$tn&quot; * &quot;.vtu&quot;, cellfields=[&quot;u&quot; =&gt; uhn])
  end
end</code></pre><p><img src="../../assets/transient_linear/result.gif" alt/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../t016_poisson_distributed/">« 16 Poisson equation on parallel distributed-memory computers</a><a class="docs-footer-nextpage" href="../t018_transient_nonlinear/">18 Transient nonlinear equation »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 9 March 2025 11:36">Sunday 9 March 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
